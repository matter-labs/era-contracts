{
  "contractAddress": "0x0000000000000000000000000000000000010002",
  "codeFormat": "solidity-standard-json-input",
  "sourceCode": {
    "language": "Solidity",
    "sources": {
      "contracts/bridge/BridgeHelper.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts-v4/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ETH_TOKEN_ADDRESS} from \"../common/Config.sol\";\nimport {DataEncoding} from \"../common/libraries/DataEncoding.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Helper library for working with native tokens on both L1 and L2.\n */\nlibrary BridgeHelper {\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function getERC20Getters(address _token, uint256 _originChainId) internal view returns (bytes memory) {\n        bytes memory name;\n        bytes memory symbol;\n        bytes memory decimals;\n        if (_token == ETH_TOKEN_ADDRESS) {\n            // when depositing eth to a non-eth based chain it is an ERC20\n            name = abi.encode(\"Ether\");\n            symbol = abi.encode(\"ETH\");\n            decimals = abi.encode(uint8(18));\n        } else {\n            bool success;\n            /// note this also works on the L2 for the base token.\n            (success, name) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n            if (!success) {\n                // We ignore the revert data\n                name = hex\"\";\n            }\n            (success, symbol) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n            if (!success) {\n                // We ignore the revert data\n                symbol = hex\"\";\n            }\n            (success, decimals) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n            if (!success) {\n                // We ignore the revert data\n                decimals = hex\"\";\n            }\n        }\n        return\n            DataEncoding.encodeTokenData({_chainId: _originChainId, _name: name, _symbol: symbol, _decimals: decimals});\n    }\n}\n"
      },
      "contracts/bridge/BridgedStandardERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable-v4/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts-v4/proxy/beacon/UpgradeableBeacon.sol\";\nimport {ERC1967Upgrade} from \"@openzeppelin/contracts-v4/proxy/ERC1967/ERC1967Upgrade.sol\";\n\nimport {IBridgedStandardToken} from \"./interfaces/IBridgedStandardToken.sol\";\nimport {Unauthorized, NonSequentialVersion, ZeroAddress} from \"../common/L1ContractErrors.sol\";\nimport {L2_NATIVE_TOKEN_VAULT_ADDR} from \"../common/L2ContractAddresses.sol\";\nimport {DataEncoding} from \"../common/libraries/DataEncoding.sol\";\nimport {INativeTokenVault} from \"../bridge/ntv/INativeTokenVault.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The ERC20 token implementation, that is used in the \"default\" ERC20 bridge. Note, that it does not\n/// support any custom token logic, i.e. rebase tokens' functionality is not supported.\ncontract BridgedStandardERC20 is ERC20PermitUpgradeable, IBridgedStandardToken, ERC1967Upgrade {\n    /// @dev Describes whether there is a specific getter in the token.\n    /// @notice Used to explicitly separate which getters the token has and which it does not.\n    /// @notice Different tokens in L1 can implement or not implement getter function as `name`/`symbol`/`decimals`,\n    /// @notice Our goal is to store all the getters that L1 token implements, and for others, we keep it as an unimplemented method.\n    struct ERC20Getters {\n        bool ignoreName;\n        bool ignoreSymbol;\n        bool ignoreDecimals;\n    }\n\n    ERC20Getters private availableGetters;\n\n    /// @dev The decimals of the token, that are used as a value for `decimals` getter function.\n    /// @notice A private variable is used only for decimals, but not for `name` and `symbol`, because standard\n    /// @notice OpenZeppelin token represents `name` and `symbol` as storage variables and `decimals` as constant.\n    uint8 private decimals_;\n\n    /// @notice The l2Bridge now is deprecated, use the L2AssetRouter and L2NativeTokenVault instead.\n    /// @dev Address of the L2 bridge that is used as trustee who can mint/burn tokens\n    address public override l2Bridge;\n\n    /// @dev Address of the token on its origin chain that can be deposited to mint this bridged token\n    address public override originToken;\n\n    /// @dev Address of the native token vault that is used as trustee who can mint/burn tokens\n    address public nativeTokenVault;\n\n    /// @dev The assetId of the token.\n    bytes32 public assetId;\n\n    /// @dev This also sets the native token vault to the default value if it is not set.\n    /// It is not set only on the L2s for legacy tokens.\n    modifier onlyNTV() {\n        address ntv = nativeTokenVault;\n        if (ntv == address(0)) {\n            ntv = L2_NATIVE_TOKEN_VAULT_ADDR;\n            nativeTokenVault = L2_NATIVE_TOKEN_VAULT_ADDR;\n            assetId = DataEncoding.encodeNTVAssetId(\n                INativeTokenVault(L2_NATIVE_TOKEN_VAULT_ADDR).L1_CHAIN_ID(),\n                originToken\n            );\n        }\n        if (msg.sender != ntv) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    modifier onlyNextVersion(uint8 _version) {\n        // The version should be incremented by 1. Otherwise, the governor risks disabling\n        // future reinitialization of the token by providing too large a version.\n        if (_version != _getInitializedVersion() + 1) {\n            revert NonSequentialVersion();\n        }\n        _;\n    }\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    constructor() {\n        // Disable initialization to prevent Parity hack.\n        _disableInitializers();\n    }\n\n    /// @notice Initializes a contract token for later use. Expected to be used in the proxy.\n    /// @dev Stores the L1 address of the bridge and set `name`/`symbol`/`decimals` getters that L1 token has.\n    /// @param _assetId The assetId of the token.\n    /// @param _originToken Address of the origin token that can be deposited to mint this bridged token\n    /// @param _data The additional data that the L1 bridge provide for initialization.\n    /// In this case, it is packed `name`/`symbol`/`decimals` of the L1 token.\n    function bridgeInitialize(bytes32 _assetId, address _originToken, bytes calldata _data) external initializer {\n        if (_originToken == address(0)) {\n            revert ZeroAddress();\n        }\n        originToken = _originToken;\n        assetId = _assetId;\n\n        nativeTokenVault = msg.sender;\n\n        bytes memory nameBytes;\n        bytes memory symbolBytes;\n        bytes memory decimalsBytes;\n        // We parse the data exactly as they were created on the L1 bridge\n        // slither-disable-next-line unused-return\n        (, nameBytes, symbolBytes, decimalsBytes) = DataEncoding.decodeTokenData(_data);\n\n        ERC20Getters memory getters;\n        string memory decodedName;\n        string memory decodedSymbol;\n\n        // L1 bridge didn't check if the L1 token return values with proper types for `name`/`symbol`/`decimals`\n        // That's why we need to try to decode them, and if it works out, set the values as getters.\n\n        // NOTE: Solidity doesn't have a convenient way to try to decode a value:\n        // - Decode them manually, i.e. write a function that will validate that data in the correct format\n        // and return decoded value and a boolean value - whether it was possible to decode.\n        // - Use the standard abi.decode method, but wrap it into an external call in which error can be handled.\n        // We use the second option here.\n\n        try this.decodeString(nameBytes) returns (string memory nameString) {\n            decodedName = nameString;\n        } catch {\n            getters.ignoreName = true;\n        }\n\n        try this.decodeString(symbolBytes) returns (string memory symbolString) {\n            decodedSymbol = symbolString;\n        } catch {\n            getters.ignoreSymbol = true;\n        }\n\n        // Set decoded values for name and symbol.\n        __ERC20_init_unchained(decodedName, decodedSymbol);\n\n        // Set the name for EIP-712 signature.\n        __ERC20Permit_init(decodedName);\n\n        try this.decodeUint8(decimalsBytes) returns (uint8 decimalsUint8) {\n            // Set decoded value for decimals.\n            decimals_ = decimalsUint8;\n        } catch {\n            getters.ignoreDecimals = true;\n        }\n\n        availableGetters = getters;\n        emit BridgeInitialize(_originToken, decodedName, decodedSymbol, decimals_);\n    }\n\n    /// @notice A method to be called by the governor to update the token's metadata.\n    /// @param _availableGetters The getters that the token has.\n    /// @param _newName The new name of the token.\n    /// @param _newSymbol The new symbol of the token.\n    /// @param _version The version of the token that will be initialized.\n    /// @dev The _version must be exactly the version higher by 1 than the current version. This is needed\n    /// to ensure that the governor can not accidentally disable future reinitialization of the token.\n    function reinitializeToken(\n        ERC20Getters calldata _availableGetters,\n        string calldata _newName,\n        string calldata _newSymbol,\n        uint8 _version\n    ) external onlyNextVersion(_version) reinitializer(_version) {\n        // It is expected that this token is deployed as a beacon proxy, so we'll\n        // allow the governor of the beacon to reinitialize the token.\n        address beaconAddress = _getBeacon();\n        if (msg.sender != UpgradeableBeacon(beaconAddress).owner()) {\n            revert Unauthorized(msg.sender);\n        }\n\n        __ERC20_init_unchained(_newName, _newSymbol);\n        __ERC20Permit_init(_newName);\n        availableGetters = _availableGetters;\n\n        emit BridgeInitialize(originToken, _newName, _newSymbol, decimals_);\n    }\n\n    /// @dev Mint tokens to a given account.\n    /// @param _to The account that will receive the created tokens.\n    /// @param _amount The amount that will be created.\n    /// @notice Should be called by bridge after depositing tokens from L1.\n    function bridgeMint(address _to, uint256 _amount) external override onlyNTV {\n        _mint(_to, _amount);\n        emit BridgeMint(_to, _amount);\n    }\n\n    /// @dev Burn tokens from a given account.\n    /// @param _from The account from which tokens will be burned.\n    /// @param _amount The amount that will be burned.\n    /// @notice Should be called by bridge before withdrawing tokens to L1.\n    function bridgeBurn(address _from, uint256 _amount) external override onlyNTV {\n        _burn(_from, _amount);\n        emit BridgeBurn(_from, _amount);\n    }\n\n    /// @dev External function to decode a string from bytes.\n    function decodeString(bytes calldata _input) external pure returns (string memory result) {\n        (result) = abi.decode(_input, (string));\n    }\n\n    /// @dev External function to decode a uint8 from bytes.\n    function decodeUint8(bytes calldata _input) external pure returns (uint8 result) {\n        (result) = abi.decode(_input, (uint8));\n    }\n\n    function name() public view override returns (string memory) {\n        // If method is not available, behave like a token that does not implement this method - revert on call.\n        // solhint-disable-next-line reason-string, gas-custom-errors\n        if (availableGetters.ignoreName) revert();\n        return super.name();\n    }\n\n    function symbol() public view override returns (string memory) {\n        // If method is not available, behave like a token that does not implement this method - revert on call.\n        // solhint-disable-next-line reason-string, gas-custom-errors\n        if (availableGetters.ignoreSymbol) revert();\n        return super.symbol();\n    }\n\n    function decimals() public view override returns (uint8) {\n        // If method is not available, behave like a token that does not implement this method - revert on call.\n        // solhint-disable-next-line reason-string, gas-custom-errors\n        if (availableGetters.ignoreDecimals) revert();\n        return decimals_;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            LEGACY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns the address of the token on its native chain.\n    /// Legacy for the l2 bridge.\n    function l1Address() public view override returns (address) {\n        return originToken;\n    }\n}\n"
      },
      "contracts/bridge/L1BridgeContractErrors.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.21;\n\n// 0x6d963f88\nerror EthTransferFailed();\n\n// 0x1c55230b\nerror NativeTokenVaultAlreadySet();\n\n// 0x61cdb17e\nerror WrongMsgLength(uint256 expected, uint256 length);\n\n// 0xe4742c42\nerror ZeroAmountToTransfer();\n\n// 0xfeda3bf8\nerror WrongAmountTransferred(uint256 balance, uint256 nullifierChainBalance);\n\n// 0x066f53b1\nerror EmptyToken();\n\n// 0x0fef9068\nerror ClaimFailedDepositFailed();\n\n// 0x636c90db\nerror WrongL2Sender(address providedL2Sender);\n\n// 0xb4aeddbc\nerror WrongCounterpart();\n"
      },
      "contracts/bridge/L1ERC20Bridge.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IERC20} from \"@openzeppelin/contracts-v4/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts-v4/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IL1ERC20Bridge} from \"./interfaces/IL1ERC20Bridge.sol\";\nimport {IL1Nullifier, FinalizeL1DepositParams} from \"./interfaces/IL1Nullifier.sol\";\nimport {IL1NativeTokenVault} from \"./ntv/IL1NativeTokenVault.sol\";\nimport {IL1AssetRouter} from \"./asset-router/IL1AssetRouter.sol\";\n\nimport {L2ContractHelper} from \"../common/libraries/L2ContractHelper.sol\";\nimport {ReentrancyGuard} from \"../common/ReentrancyGuard.sol\";\n\nimport {AssetRouterAllowanceNotZero, EmptyDeposit, WithdrawalAlreadyFinalized, TokensWithFeesNotSupported, ETHDepositNotSupported} from \"../common/L1ContractErrors.sol\";\nimport {ETH_TOKEN_ADDRESS} from \"../common/Config.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Smart contract that allows depositing ERC20 tokens from Ethereum to ZK chains\n/// @dev It is a legacy bridge from ZKsync Era, that was deprecated in favour of shared bridge.\n/// It is needed for backward compatibility with already integrated projects.\ncontract L1ERC20Bridge is IL1ERC20Bridge, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @dev The shared bridge that is now used for all bridging, replacing the legacy contract.\n    IL1Nullifier public immutable override L1_NULLIFIER;\n\n    /// @dev The asset router, which holds deposited tokens.\n    IL1AssetRouter public immutable override L1_ASSET_ROUTER;\n\n    /// @dev The native token vault, which holds deposited tokens.\n    IL1NativeTokenVault public immutable override L1_NATIVE_TOKEN_VAULT;\n\n    /// @dev The chainId of Era\n    uint256 public immutable ERA_CHAIN_ID;\n\n    /// @dev A mapping L2 batch number => message number => flag.\n    /// @dev Used to indicate that L2 -> L1 message was already processed for ZKsync Era withdrawals.\n    // slither-disable-next-line uninitialized-state\n    mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized))\n        public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount.\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail in ZKsync Era.\n    mapping(address account => mapping(address l1Token => mapping(bytes32 depositL2TxHash => uint256 amount)))\n        public depositAmount;\n\n    /// @dev The address that is used as a L2 bridge counterpart in ZKsync Era.\n    // slither-disable-next-line uninitialized-state\n    address public l2Bridge;\n\n    /// @dev The address that is used as a beacon for L2 tokens in ZKsync Era.\n    // slither-disable-next-line uninitialized-state\n    address public l2TokenBeacon;\n\n    /// @dev Stores the hash of the L2 token proxy contract's bytecode on ZKsync Era.\n    // slither-disable-next-line uninitialized-state\n    bytes32 public l2TokenProxyBytecodeHash;\n\n    /// @dev Deprecated storage variable related to withdrawal limitations.\n    mapping(address => uint256) private __DEPRECATED_lastWithdrawalLimitReset;\n\n    /// @dev Deprecated storage variable related to withdrawal limitations.\n    mapping(address => uint256) private __DEPRECATED_withdrawnAmountInWindow;\n\n    /// @dev Deprecated storage variable related to deposit limitations.\n    mapping(address => mapping(address => uint256)) private __DEPRECATED_totalDepositedAmountPerUser;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(\n        IL1Nullifier _nullifier,\n        IL1AssetRouter _assetRouter,\n        IL1NativeTokenVault _nativeTokenVault,\n        uint256 _eraChainId\n    ) reentrancyGuardInitializer {\n        L1_NULLIFIER = _nullifier;\n        L1_ASSET_ROUTER = _assetRouter;\n        L1_NATIVE_TOKEN_VAULT = _nativeTokenVault;\n        ERA_CHAIN_ID = _eraChainId;\n    }\n\n    /// @dev Initializes the reentrancy guard. Expected to be used in the proxy.\n    function initialize() external reentrancyGuardInitializer {}\n\n    /*//////////////////////////////////////////////////////////////\n                            ERA LEGACY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Legacy deposit method with refunding the fee to the caller, use another `deposit` method instead.\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted.\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    /// NOTE: the function doesn't use `nonreentrant` modifier, because the inner method does.\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 l2TxHash) {\n        l2TxHash = deposit({\n            _l2Receiver: _l2Receiver,\n            _l1Token: _l1Token,\n            _amount: _amount,\n            _l2TxGasLimit: _l2TxGasLimit,\n            _l2TxGasPerPubdataByte: _l2TxGasPerPubdataByte,\n            _refundRecipient: address(0)\n        });\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        if (isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex]) {\n            revert WithdrawalAlreadyFinalized();\n        }\n        // We don't need to set finalizeWithdrawal here, as we set it in the shared bridge\n\n        FinalizeL1DepositParams memory finalizeWithdrawalParams = FinalizeL1DepositParams({\n            chainId: ERA_CHAIN_ID,\n            l2BatchNumber: _l2BatchNumber,\n            l2MessageIndex: _l2MessageIndex,\n            l2Sender: L1_NULLIFIER.l2BridgeAddress(ERA_CHAIN_ID),\n            l2TxNumberInBatch: _l2TxNumberInBatch,\n            message: _message,\n            merkleProof: _merkleProof\n        });\n        L1_NULLIFIER.finalizeDeposit(finalizeWithdrawalParams);\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) public payable nonReentrant returns (bytes32 l2TxHash) {\n        if (_amount == 0) {\n            // empty deposit amount\n            revert EmptyDeposit();\n        }\n        if (_l1Token == ETH_TOKEN_ADDRESS) {\n            revert ETHDepositNotSupported();\n        }\n        uint256 amount = _approveFundsToAssetRouter(msg.sender, IERC20(_l1Token), _amount);\n        if (amount != _amount) {\n            // The token has non-standard transfer logic\n            revert TokensWithFeesNotSupported();\n        }\n\n        l2TxHash = L1_ASSET_ROUTER.depositLegacyErc20Bridge{value: msg.value}({\n            _originalCaller: msg.sender,\n            _l2Receiver: _l2Receiver,\n            _l1Token: _l1Token,\n            _amount: _amount,\n            _l2TxGasLimit: _l2TxGasLimit,\n            _l2TxGasPerPubdataByte: _l2TxGasPerPubdataByte,\n            _refundRecipient: _refundRecipient\n        });\n        // Ensuring that all the funds that were locked into this bridge were spent by the asset router / native token vault.\n        if (IERC20(_l1Token).allowance(address(this), address(L1_ASSET_ROUTER)) != 0) {\n            revert AssetRouterAllowanceNotZero();\n        }\n        depositAmount[msg.sender][_l1Token][l2TxHash] = _amount;\n        emit DepositInitiated({\n            l2DepositTxHash: l2TxHash,\n            from: msg.sender,\n            to: _l2Receiver,\n            l1Token: _l1Token,\n            amount: _amount\n        });\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERA LEGACY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Transfers tokens from the depositor address to the native token vault address.\n    /// @return The difference between the contract balance before and after the transferring of funds.\n    function _approveFundsToAssetRouter(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        _token.forceApprove(address(L1_ASSET_ROUTER), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2.\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // empty deposit\n        if (amount == 0) {\n            revert EmptyDeposit();\n        }\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n\n        L1_NULLIFIER.claimFailedDepositLegacyErc20Bridge({\n            _depositSender: _depositSender,\n            _l1Token: _l1Token,\n            _amount: amount,\n            _l2TxHash: _l2TxHash,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _merkleProof: _merkleProof\n        });\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERA LEGACY GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token on ZKsync Era.\n    function l2TokenAddress(address _l1Token) external view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(l2TokenBeacon, \"\"));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n}\n"
      },
      "contracts/bridge/L1Nullifier.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Ownable2StepUpgradeable} from \"@openzeppelin/contracts-upgradeable-v4/access/Ownable2StepUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable-v4/security/PausableUpgradeable.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts-v4/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts-v4/token/ERC20/utils/SafeERC20.sol\";\n\nimport {NEW_ENCODING_VERSION, LEGACY_ENCODING_VERSION} from \"./asset-router/IAssetRouterBase.sol\";\nimport {IL1NativeTokenVault} from \"./ntv/IL1NativeTokenVault.sol\";\n\nimport {IL1ERC20Bridge} from \"./interfaces/IL1ERC20Bridge.sol\";\nimport {IL1AssetRouter} from \"./asset-router/IL1AssetRouter.sol\";\nimport {IAssetRouterBase} from \"./asset-router/IAssetRouterBase.sol\";\n\nimport {IL1Nullifier, FinalizeL1DepositParams} from \"./interfaces/IL1Nullifier.sol\";\n\nimport {IGetters} from \"../state-transition/chain-interfaces/IGetters.sol\";\nimport {IMailbox} from \"../state-transition/chain-interfaces/IMailbox.sol\";\nimport {L2Message, TxStatus} from \"../common/Messaging.sol\";\nimport {UnsafeBytes} from \"../common/libraries/UnsafeBytes.sol\";\nimport {ReentrancyGuard} from \"../common/ReentrancyGuard.sol\";\nimport {ETH_TOKEN_ADDRESS} from \"../common/Config.sol\";\nimport {DataEncoding} from \"../common/libraries/DataEncoding.sol\";\n\nimport {IBridgehub} from \"../bridgehub/IBridgehub.sol\";\nimport {L2_BASE_TOKEN_SYSTEM_CONTRACT_ADDR, L2_ASSET_ROUTER_ADDR} from \"../common/L2ContractAddresses.sol\";\nimport {DataEncoding} from \"../common/libraries/DataEncoding.sol\";\nimport {LegacyMethodForNonL1Token, LegacyBridgeNotSet, Unauthorized, SharedBridgeKey, DepositExists, AddressAlreadySet, InvalidProof, DepositDoesNotExist, SharedBridgeValueNotSet, WithdrawalAlreadyFinalized, L2WithdrawalMessageWrongLength, InvalidSelector, SharedBridgeValueNotSet, ZeroAddress} from \"../common/L1ContractErrors.sol\";\nimport {WrongL2Sender, NativeTokenVaultAlreadySet, EthTransferFailed, WrongMsgLength} from \"./L1BridgeContractErrors.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev Bridges assets between L1 and ZK chain, supporting both ETH and ERC20 tokens.\n/// @dev Designed for use with a proxy for upgradability.\ncontract L1Nullifier is IL1Nullifier, ReentrancyGuard, Ownable2StepUpgradeable, PausableUpgradeable {\n    using SafeERC20 for IERC20;\n\n    /// @dev Bridgehub smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication.\n    IBridgehub public immutable override BRIDGE_HUB;\n\n    /// @dev Era's chainID\n    uint256 internal immutable ERA_CHAIN_ID;\n\n    /// @dev The address of ZKsync Era diamond proxy contract.\n    address internal immutable ERA_DIAMOND_PROXY;\n\n    /// @dev Stores the first batch number on the ZKsync Era Diamond Proxy that was settled after Diamond proxy upgrade.\n    /// This variable is used to differentiate between pre-upgrade and post-upgrade Eth withdrawals. Withdrawals from batches older\n    /// than this value are considered to have been finalized prior to the upgrade and handled separately.\n    uint256 internal eraPostDiamondUpgradeFirstBatch;\n\n    /// @dev Stores the first batch number on the ZKsync Era Diamond Proxy that was settled after L1ERC20 Bridge upgrade.\n    /// This variable is used to differentiate between pre-upgrade and post-upgrade ERC20 withdrawals. Withdrawals from batches older\n    /// than this value are considered to have been finalized prior to the upgrade and handled separately.\n    uint256 internal eraPostLegacyBridgeUpgradeFirstBatch;\n\n    /// @dev Stores the ZKsync Era batch number that processes the last deposit tx initiated by the legacy bridge\n    /// This variable (together with eraLegacyBridgeLastDepositTxNumber) is used to differentiate between pre-upgrade and post-upgrade deposits. Deposits processed in older batches\n    /// than this value are considered to have been processed prior to the upgrade and handled separately.\n    /// We use this both for Eth and erc20 token deposits, so we need to update the diamond and bridge simultaneously.\n    uint256 internal eraLegacyBridgeLastDepositBatch;\n\n    /// @dev The tx number in the _eraLegacyBridgeLastDepositBatch that comes *right after* the last deposit tx initiated by the legacy bridge.\n    /// This variable (together with eraLegacyBridgeLastDepositBatch) is used to differentiate between pre-upgrade and post-upgrade deposits. Deposits processed in older txs\n    /// than this value are considered to have been processed prior to the upgrade and handled separately.\n    /// We use this both for Eth and erc20 token deposits, so we need to update the diamond and bridge simultaneously.\n    uint256 internal eraLegacyBridgeLastDepositTxNumber;\n\n    /// @dev Legacy bridge smart contract that used to hold ERC20 tokens.\n    IL1ERC20Bridge public override legacyBridge;\n\n    /// @dev A mapping chainId => bridgeProxy. Used to store the bridge proxy's address, and to see if it has been deployed yet.\n    // slither-disable-next-line uninitialized-state\n    mapping(uint256 chainId => address l2Bridge) public __DEPRECATED_l2BridgeAddress;\n\n    /// @dev A mapping chainId => L2 deposit transaction hash => dataHash\n    // keccak256(abi.encode(account, tokenAddress, amount)) for legacy transfers\n    // keccak256(abi.encode(_originalCaller, assetId, transferData)) for new transfers\n    /// @dev Tracks deposit transactions to L2 to enable users to claim their funds if a deposit fails.\n    mapping(uint256 chainId => mapping(bytes32 l2DepositTxHash => bytes32 depositDataHash))\n        public\n        override depositHappened;\n\n    /// @dev Tracks the processing status of L2 to L1 messages, indicating whether a message has already been finalized.\n    mapping(uint256 chainId => mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized)))\n        public isWithdrawalFinalized;\n\n    /// @notice Deprecated. Kept for backwards compatibility.\n    /// @dev Indicates whether the hyperbridging is enabled for a given chain.\n    // slither-disable-next-line uninitialized-state\n    mapping(uint256 chainId => bool enabled) private __DEPRECATED_hyperbridgingEnabled;\n\n    /// @dev Maps token balances for each chain to prevent unauthorized spending across ZK chain.\n    /// This serves as a security measure until hyperbridging is implemented.\n    /// NOTE: this function may be removed in the future, don't rely on it!\n    mapping(uint256 chainId => mapping(address l1Token => uint256 balance)) public __DEPRECATED_chainBalance;\n\n    /// @dev Admin has the ability to register new chains within the shared bridge.\n    address public __DEPRECATED_admin;\n\n    /// @dev The pending admin, i.e. the candidate to the admin role.\n    address public __DEPRECATED_pendingAdmin;\n\n    /// @dev Address of L1 asset router.\n    IL1AssetRouter public l1AssetRouter;\n\n    /// @dev Address of native token vault.\n    IL1NativeTokenVault public l1NativeTokenVault;\n\n    /// @notice Checks that the message sender is the asset router..\n    modifier onlyAssetRouter() {\n        if (msg.sender != address(l1AssetRouter)) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Checks that the message sender is the native token vault.\n    modifier onlyL1NTV() {\n        if (msg.sender != address(l1NativeTokenVault)) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Checks that the message sender is the legacy bridge.\n    modifier onlyLegacyBridge() {\n        if (msg.sender != address(legacyBridge)) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IBridgehub _bridgehub, uint256 _eraChainId, address _eraDiamondProxy) reentrancyGuardInitializer {\n        _disableInitializers();\n        BRIDGE_HUB = _bridgehub;\n        ERA_CHAIN_ID = _eraChainId;\n        ERA_DIAMOND_PROXY = _eraDiamondProxy;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy.\n    /// @dev Used for testing purposes only, as the contract has been initialized on mainnet.\n    /// @param _owner The address which can change L2 token implementation and upgrade the bridge implementation.\n    /// The owner is the Governor and separate from the ProxyAdmin from now on, so that the Governor can call the bridge.\n    /// @param _eraPostDiamondUpgradeFirstBatch The first batch number on the ZKsync Era Diamond Proxy that was settled after diamond proxy upgrade.\n    /// @param _eraPostLegacyBridgeUpgradeFirstBatch The first batch number on the ZKsync Era Diamond Proxy that was settled after legacy bridge upgrade.\n    /// @param _eraLegacyBridgeLastDepositBatch The the ZKsync Era batch number that processes the last deposit tx initiated by the legacy bridge.\n    /// @param _eraLegacyBridgeLastDepositTxNumber The tx number in the _eraLegacyBridgeLastDepositBatch of the last deposit tx initiated by the legacy bridge.\n    function initialize(\n        address _owner,\n        uint256 _eraPostDiamondUpgradeFirstBatch,\n        uint256 _eraPostLegacyBridgeUpgradeFirstBatch,\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external reentrancyGuardInitializer initializer {\n        if (_owner == address(0)) {\n            revert ZeroAddress();\n        }\n        _transferOwnership(_owner);\n        if (eraPostDiamondUpgradeFirstBatch == 0) {\n            eraPostDiamondUpgradeFirstBatch = _eraPostDiamondUpgradeFirstBatch;\n            eraPostLegacyBridgeUpgradeFirstBatch = _eraPostLegacyBridgeUpgradeFirstBatch;\n            eraLegacyBridgeLastDepositBatch = _eraLegacyBridgeLastDepositBatch;\n            eraLegacyBridgeLastDepositTxNumber = _eraLegacyBridgeLastDepositTxNumber;\n        }\n    }\n\n    /// @notice Transfers tokens from shared bridge to native token vault.\n    /// @dev This function is part of the upgrade process used to transfer liquidity.\n    /// @param _token The address of the token to be transferred to NTV.\n    function transferTokenToNTV(address _token) external onlyL1NTV {\n        address ntvAddress = address(l1NativeTokenVault);\n        if (ETH_TOKEN_ADDRESS == _token) {\n            uint256 amount = address(this).balance;\n            bool callSuccess;\n            // Low-level assembly call, to avoid any memory copying (save gas)\n            assembly {\n                callSuccess := call(gas(), ntvAddress, amount, 0, 0, 0, 0)\n            }\n            if (!callSuccess) {\n                revert EthTransferFailed();\n            }\n        } else {\n            IERC20(_token).safeTransfer(ntvAddress, IERC20(_token).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Clears chain balance for specific token.\n    /// @dev This function is part of the upgrade process used to nullify chain balances once they are credited to NTV.\n    /// @param _chainId The ID of the ZK chain.\n    /// @param _token The address of the token which was previously deposit to shared bridge.\n    function nullifyChainBalanceByNTV(uint256 _chainId, address _token) external onlyL1NTV {\n        __DEPRECATED_chainBalance[_chainId][_token] = 0;\n    }\n\n    /// @notice Legacy function used for migration, do not use!\n    /// @param _chainId The chain id on which the bridge is deployed.\n    // slither-disable-next-line uninitialized-state-variables\n    function l2BridgeAddress(uint256 _chainId) external view returns (address) {\n        // slither-disable-next-line uninitialized-state-variables\n        return __DEPRECATED_l2BridgeAddress[_chainId];\n    }\n\n    /// @notice Legacy function used for migration, do not use!\n    /// @param _chainId The chain id we want to get the balance for.\n    /// @param _token The address of the token.\n    // slither-disable-next-line uninitialized-state-variables\n    function chainBalance(uint256 _chainId, address _token) external view returns (uint256) {\n        // slither-disable-next-line uninitialized-state-variables\n        return __DEPRECATED_chainBalance[_chainId][_token];\n    }\n\n    /// @notice Sets the L1ERC20Bridge contract address.\n    /// @dev Should be called only once by the owner.\n    /// @param _legacyBridge The address of the legacy bridge.\n    function setL1Erc20Bridge(IL1ERC20Bridge _legacyBridge) external onlyOwner {\n        if (address(legacyBridge) != address(0)) {\n            revert AddressAlreadySet(address(legacyBridge));\n        }\n        if (address(_legacyBridge) == address(0)) {\n            revert ZeroAddress();\n        }\n        legacyBridge = _legacyBridge;\n    }\n\n    /// @notice Sets the nativeTokenVault contract address.\n    /// @dev Should be called only once by the owner.\n    /// @param _l1NativeTokenVault The address of the native token vault.\n    function setL1NativeTokenVault(IL1NativeTokenVault _l1NativeTokenVault) external onlyOwner {\n        if (address(l1NativeTokenVault) != address(0)) {\n            revert NativeTokenVaultAlreadySet();\n        }\n        if (address(_l1NativeTokenVault) == address(0)) {\n            revert ZeroAddress();\n        }\n        l1NativeTokenVault = _l1NativeTokenVault;\n    }\n\n    /// @notice Sets the L1 asset router contract address.\n    /// @dev Should be called only once by the owner.\n    /// @param _l1AssetRouter The address of the asset router.\n    function setL1AssetRouter(address _l1AssetRouter) external onlyOwner {\n        if (address(l1AssetRouter) != address(0)) {\n            revert AddressAlreadySet(address(l1AssetRouter));\n        }\n        if (_l1AssetRouter == address(0)) {\n            revert ZeroAddress();\n        }\n        l1AssetRouter = IL1AssetRouter(_l1AssetRouter);\n    }\n\n    /// @notice Confirms the acceptance of a transaction by the Mailbox, as part of the L2 transaction process within Bridgehub.\n    /// This function is utilized by `requestL2TransactionTwoBridges` to validate the execution of a transaction.\n    /// @param _chainId The chain ID of the ZK chain to which confirm the deposit.\n    /// @param _txDataHash The keccak256 hash of 0x01 || abi.encode(bytes32, bytes) to identify deposits.\n    /// @param _txHash The hash of the L1->L2 transaction to confirm the deposit.\n    function bridgehubConfirmL2TransactionForwarded(\n        uint256 _chainId,\n        bytes32 _txDataHash,\n        bytes32 _txHash\n    ) external override onlyAssetRouter whenNotPaused {\n        if (depositHappened[_chainId][_txHash] != 0x00) {\n            revert DepositExists();\n        }\n        depositHappened[_chainId][_txHash] = _txDataHash;\n        emit BridgehubDepositFinalized(_chainId, _txDataHash, _txHash);\n    }\n\n    /// @dev Calls the library `encodeTxDataHash`. Used as a wrapped for try / catch case.\n    /// @dev Encodes the transaction data hash using either the latest encoding standard or the legacy standard.\n    /// @param _encodingVersion EncodingVersion.\n    /// @param _originalCaller The address of the entity that initiated the deposit.\n    /// @param _assetId The unique identifier of the deposited L1 token.\n    /// @param _transferData The encoded transfer data, which includes both the deposit amount and the address of the L2 receiver.\n    /// @return txDataHash The resulting encoded transaction data hash.\n    function encodeTxDataHash(\n        bytes1 _encodingVersion,\n        address _originalCaller,\n        bytes32 _assetId,\n        bytes calldata _transferData\n    ) external view returns (bytes32 txDataHash) {\n        txDataHash = DataEncoding.encodeTxDataHash({\n            _encodingVersion: _encodingVersion,\n            _originalCaller: _originalCaller,\n            _assetId: _assetId,\n            _nativeTokenVault: address(l1NativeTokenVault),\n            _transferData: _transferData\n        });\n    }\n\n    /// @inheritdoc IL1Nullifier\n    function bridgeRecoverFailedTransfer(\n        uint256 _chainId,\n        address _depositSender,\n        bytes32 _assetId,\n        bytes memory _assetData,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) public nonReentrant {\n        _verifyAndClearFailedTransfer({\n            _checkedInLegacyBridge: false,\n            _chainId: _chainId,\n            _depositSender: _depositSender,\n            _assetId: _assetId,\n            _assetData: _assetData,\n            _l2TxHash: _l2TxHash,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _merkleProof: _merkleProof\n        });\n\n        l1AssetRouter.bridgeRecoverFailedTransfer(_chainId, _depositSender, _assetId, _assetData);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2.\n    /// @param _chainId The ZK chain id to which deposit was initiated.\n    /// @param _depositSender The address of the entity that initiated the deposit.\n    /// @param _assetId The unique identifier of the deposited L1 token.\n    /// @param _assetData The encoded data, which is used by the asset handler to determine L2 recipient and amount. Might include extra information.\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization.\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed.\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message.\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent.\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization.\n    /// @dev Processes claims of failed deposit, whether they originated from the legacy bridge or the current system.\n    function _verifyAndClearFailedTransfer(\n        bool _checkedInLegacyBridge,\n        uint256 _chainId,\n        address _depositSender,\n        bytes32 _assetId,\n        bytes memory _assetData,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) internal whenNotPaused {\n        {\n            bool proofValid = BRIDGE_HUB.proveL1ToL2TransactionStatus({\n                _chainId: _chainId,\n                _l2TxHash: _l2TxHash,\n                _l2BatchNumber: _l2BatchNumber,\n                _l2MessageIndex: _l2MessageIndex,\n                _l2TxNumberInBatch: _l2TxNumberInBatch,\n                _merkleProof: _merkleProof,\n                _status: TxStatus.Failure\n            });\n            if (!proofValid) {\n                revert InvalidProof();\n            }\n        }\n\n        bool notCheckedInLegacyBridgeOrWeCanCheckDeposit;\n        {\n            // Deposits that happened before the upgrade cannot be checked here, they have to be claimed and checked in the legacyBridge\n            bool weCanCheckDepositHere = !_isPreSharedBridgeDepositOnEra(_chainId, _l2BatchNumber, _l2TxNumberInBatch);\n            // Double claims are not possible, as depositHappened is checked here for all except legacy deposits (which have to happen through the legacy bridge)\n            // Funds claimed before the update will still be recorded in the legacy bridge\n            // Note we double check NEW deposits if they are called from the legacy bridge\n            notCheckedInLegacyBridgeOrWeCanCheckDeposit = (!_checkedInLegacyBridge) || weCanCheckDepositHere;\n        }\n\n        if (notCheckedInLegacyBridgeOrWeCanCheckDeposit) {\n            bytes32 dataHash = depositHappened[_chainId][_l2TxHash];\n            // Determine if the given dataHash matches the calculated legacy transaction hash.\n            bool isLegacyTxDataHash = _isLegacyTxDataHash(_depositSender, _assetId, _assetData, dataHash);\n            // If the dataHash matches the legacy transaction hash, skip the next step.\n            // Otherwise, perform the check using the new transaction data hash encoding.\n            if (!isLegacyTxDataHash) {\n                bytes32 txDataHash = DataEncoding.encodeTxDataHash({\n                    _encodingVersion: NEW_ENCODING_VERSION,\n                    _originalCaller: _depositSender,\n                    _assetId: _assetId,\n                    _nativeTokenVault: address(l1NativeTokenVault),\n                    _transferData: _assetData\n                });\n                if (dataHash != txDataHash) {\n                    revert DepositDoesNotExist();\n                }\n            }\n        }\n        delete depositHappened[_chainId][_l2TxHash];\n    }\n\n    /// @notice Finalize the withdrawal and release funds.\n    /// @param _finalizeWithdrawalParams The structure that holds all necessary data to finalize withdrawal\n    /// @dev We have both the legacy finalizeWithdrawal and the new finalizeDeposit functions,\n    /// finalizeDeposit uses the new format. On the L2 we have finalizeDeposit with new and old formats both.\n    function finalizeDeposit(FinalizeL1DepositParams memory _finalizeWithdrawalParams) public {\n        _finalizeDeposit(_finalizeWithdrawalParams);\n    }\n\n    /// @notice Internal function that handles the logic for finalizing withdrawals, supporting both the current bridge system and the legacy ERC20 bridge.\n    /// @param _finalizeWithdrawalParams The structure that holds all necessary data to finalize withdrawal\n    function _finalizeDeposit(\n        FinalizeL1DepositParams memory _finalizeWithdrawalParams\n    ) internal nonReentrant whenNotPaused {\n        uint256 chainId = _finalizeWithdrawalParams.chainId;\n        uint256 l2BatchNumber = _finalizeWithdrawalParams.l2BatchNumber;\n        uint256 l2MessageIndex = _finalizeWithdrawalParams.l2MessageIndex;\n        if (isWithdrawalFinalized[chainId][l2BatchNumber][l2MessageIndex]) {\n            revert WithdrawalAlreadyFinalized();\n        }\n        isWithdrawalFinalized[chainId][l2BatchNumber][l2MessageIndex] = true;\n\n        (bytes32 assetId, bytes memory transferData) = _verifyWithdrawal(_finalizeWithdrawalParams);\n\n        // Handling special case for withdrawal from ZKsync Era initiated before Shared Bridge.\n        if (_isPreSharedBridgeEraEthWithdrawal(chainId, l2BatchNumber)) {\n            // Checks that the withdrawal wasn't finalized already.\n            bool alreadyFinalized = IGetters(ERA_DIAMOND_PROXY).isEthWithdrawalFinalized(l2BatchNumber, l2MessageIndex);\n            if (alreadyFinalized) {\n                revert WithdrawalAlreadyFinalized();\n            }\n        }\n        if (_isPreSharedBridgeEraTokenWithdrawal(chainId, l2BatchNumber)) {\n            if (legacyBridge.isWithdrawalFinalized(l2BatchNumber, l2MessageIndex)) {\n                revert WithdrawalAlreadyFinalized();\n            }\n        }\n\n        l1AssetRouter.finalizeDeposit(chainId, assetId, transferData);\n    }\n\n    /// @dev Determines if an eth withdrawal was initiated on ZKsync Era before the upgrade to the Shared Bridge.\n    /// @param _chainId The chain ID of the transaction to check.\n    /// @param _l2BatchNumber The L2 batch number for the withdrawal.\n    /// @return Whether withdrawal was initiated on ZKsync Era before diamond proxy upgrade.\n    function _isPreSharedBridgeEraEthWithdrawal(uint256 _chainId, uint256 _l2BatchNumber) internal view returns (bool) {\n        if ((_chainId == ERA_CHAIN_ID) && eraPostDiamondUpgradeFirstBatch == 0) {\n            revert SharedBridgeValueNotSet(SharedBridgeKey.PostUpgradeFirstBatch);\n        }\n        return (_chainId == ERA_CHAIN_ID) && (_l2BatchNumber < eraPostDiamondUpgradeFirstBatch);\n    }\n\n    /// @dev Determines if a token withdrawal was initiated on ZKsync Era before the upgrade to the Shared Bridge.\n    /// @param _chainId The chain ID of the transaction to check.\n    /// @param _l2BatchNumber The L2 batch number for the withdrawal.\n    /// @return Whether withdrawal was initiated on ZKsync Era before Legacy Bridge upgrade.\n    function _isPreSharedBridgeEraTokenWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber\n    ) internal view returns (bool) {\n        if ((_chainId == ERA_CHAIN_ID) && eraPostLegacyBridgeUpgradeFirstBatch == 0) {\n            revert SharedBridgeValueNotSet(SharedBridgeKey.LegacyBridgeFirstBatch);\n        }\n        return (_chainId == ERA_CHAIN_ID) && (_l2BatchNumber < eraPostLegacyBridgeUpgradeFirstBatch);\n    }\n\n    /// @dev Determines if the provided data for a failed deposit corresponds to a legacy failed deposit.\n    /// @param _depositSender The address of the entity that initiated the deposit.\n    /// @param _assetId The unique identifier of the deposited L1 token.\n    /// @param _transferData The encoded transfer data, which includes both the deposit amount and the address of the L2 receiver.\n    /// @param _expectedTxDataHash The nullifier data hash stored for the failed deposit.\n    /// @return isLegacyTxDataHash True if the transaction is legacy, false otherwise.\n    function _isLegacyTxDataHash(\n        address _depositSender,\n        bytes32 _assetId,\n        bytes memory _transferData,\n        bytes32 _expectedTxDataHash\n    ) internal view returns (bool isLegacyTxDataHash) {\n        try this.encodeTxDataHash(LEGACY_ENCODING_VERSION, _depositSender, _assetId, _transferData) returns (\n            bytes32 txDataHash\n        ) {\n            return txDataHash == _expectedTxDataHash;\n        } catch {\n            return false;\n        }\n    }\n\n    /// @dev Determines if a deposit was initiated on ZKsync Era before the upgrade to the Shared Bridge.\n    /// @param _chainId The chain ID of the transaction to check.\n    /// @param _l2BatchNumber The L2 batch number for the deposit where it was processed.\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the deposit was processed.\n    /// @return Whether deposit was initiated on ZKsync Era before Shared Bridge upgrade.\n    function _isPreSharedBridgeDepositOnEra(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2TxNumberInBatch\n    ) internal view returns (bool) {\n        if ((_chainId == ERA_CHAIN_ID) && (eraLegacyBridgeLastDepositBatch == 0)) {\n            revert SharedBridgeValueNotSet(SharedBridgeKey.LegacyBridgeLastDepositBatch);\n        }\n        return\n            (_chainId == ERA_CHAIN_ID) &&\n            (_l2BatchNumber < eraLegacyBridgeLastDepositBatch ||\n                (_l2TxNumberInBatch < eraLegacyBridgeLastDepositTxNumber &&\n                    _l2BatchNumber == eraLegacyBridgeLastDepositBatch));\n    }\n\n    /// @notice Verifies the validity of a withdrawal message from L2 and returns withdrawal details.\n    /// @param _finalizeWithdrawalParams The structure that holds all necessary data to finalize withdrawal\n    /// @return assetId The ID of the bridged asset.\n    /// @return transferData The transfer data used to finalize withdawal.\n    function _verifyWithdrawal(\n        FinalizeL1DepositParams memory _finalizeWithdrawalParams\n    ) internal returns (bytes32 assetId, bytes memory transferData) {\n        (assetId, transferData) = _parseL2WithdrawalMessage(\n            _finalizeWithdrawalParams.chainId,\n            _finalizeWithdrawalParams.message\n        );\n        L2Message memory l2ToL1Message;\n        {\n            address l2Sender = _finalizeWithdrawalParams.l2Sender;\n            bool baseTokenWithdrawal = (assetId == BRIDGE_HUB.baseTokenAssetId(_finalizeWithdrawalParams.chainId));\n\n            bool isL2SenderCorrect = l2Sender == L2_ASSET_ROUTER_ADDR ||\n                l2Sender == L2_BASE_TOKEN_SYSTEM_CONTRACT_ADDR ||\n                l2Sender == __DEPRECATED_l2BridgeAddress[_finalizeWithdrawalParams.chainId];\n            if (!isL2SenderCorrect) {\n                revert WrongL2Sender(l2Sender);\n            }\n\n            l2ToL1Message = L2Message({\n                txNumberInBatch: _finalizeWithdrawalParams.l2TxNumberInBatch,\n                sender: baseTokenWithdrawal ? L2_BASE_TOKEN_SYSTEM_CONTRACT_ADDR : l2Sender,\n                data: _finalizeWithdrawalParams.message\n            });\n        }\n\n        bool success = BRIDGE_HUB.proveL2MessageInclusion({\n            _chainId: _finalizeWithdrawalParams.chainId,\n            _batchNumber: _finalizeWithdrawalParams.l2BatchNumber,\n            _index: _finalizeWithdrawalParams.l2MessageIndex,\n            _message: l2ToL1Message,\n            _proof: _finalizeWithdrawalParams.merkleProof\n        });\n        // withdrawal wrong proof\n        if (!success) {\n            revert InvalidProof();\n        }\n    }\n\n    /// @notice Parses the withdrawal message and returns withdrawal details.\n    /// @dev Currently, 3 different encoding versions are supported: legacy mailbox withdrawal, ERC20 bridge withdrawal,\n    /// @dev and the latest version supported by shared bridge. Selectors are used for versioning.\n    /// @param _chainId The ZK chain ID.\n    /// @param _l2ToL1message The encoded L2 -> L1 message.\n    /// @return assetId The ID of the bridged asset.\n    /// @return transferData The transfer data used to finalize withdawal.\n    function _parseL2WithdrawalMessage(\n        uint256 _chainId,\n        bytes memory _l2ToL1message\n    ) internal returns (bytes32 assetId, bytes memory transferData) {\n        // Please note that there are three versions of the message:\n        // 1. The message that is sent from `L2BaseToken` to withdraw base token.\n        // 2. The message that is sent from L2 Legacy Shared Bridge to withdraw ERC20 tokens or base token.\n        // 3. The message that is sent from L2 Asset Router to withdraw ERC20 tokens or base token.\n\n        uint256 amount;\n        address l1Receiver;\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        if (bytes4(functionSignature) == IMailbox.finalizeEthWithdrawal.selector) {\n            // The data is expected to be at least 56 bytes long.\n            if (_l2ToL1message.length < 56) {\n                revert L2WithdrawalMessageWrongLength(_l2ToL1message.length);\n            }\n            // this message is a base token withdrawal\n            (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n            // slither-disable-next-line unused-return\n            (amount, ) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n            assetId = BRIDGE_HUB.baseTokenAssetId(_chainId);\n            transferData = DataEncoding.encodeBridgeMintData({\n                _originalCaller: address(0),\n                _remoteReceiver: l1Receiver,\n                // Note, that `assetId` could belong to a token native to an L2, and so\n                // the logic for determining the correct origin token address will be complex.\n                // It is expected that this value won't be used in the NativeTokenVault and so providing\n                // any value is acceptable here.\n                _originToken: address(0),\n                _amount: amount,\n                _erc20Metadata: new bytes(0)\n            });\n        } else if (bytes4(functionSignature) == IL1ERC20Bridge.finalizeWithdrawal.selector) {\n            // this message is a token withdrawal\n\n            // Check that the message length is correct.\n            // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 =\n            // 76 (bytes).\n            if (_l2ToL1message.length != 76) {\n                revert L2WithdrawalMessageWrongLength(_l2ToL1message.length);\n            }\n            (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n            // We use the IL1ERC20Bridge for backward compatibility with old withdrawals.\n            address l1Token;\n            (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n            // slither-disable-next-line unused-return\n            (amount, ) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n\n            l1NativeTokenVault.ensureTokenIsRegistered(l1Token);\n            assetId = DataEncoding.encodeNTVAssetId(block.chainid, l1Token);\n            transferData = DataEncoding.encodeBridgeMintData({\n                _originalCaller: address(0),\n                _remoteReceiver: l1Receiver,\n                _originToken: l1Token,\n                _amount: amount,\n                _erc20Metadata: new bytes(0)\n            });\n        } else if (bytes4(functionSignature) == IAssetRouterBase.finalizeDeposit.selector) {\n            // The data is expected to be at least 68 bytes long to contain assetId.\n            if (_l2ToL1message.length < 68) {\n                revert WrongMsgLength(68, _l2ToL1message.length);\n            }\n            // slither-disable-next-line unused-return\n            (, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset); // originChainId, not used for L2->L1 txs\n            (assetId, offset) = UnsafeBytes.readBytes32(_l2ToL1message, offset);\n            transferData = UnsafeBytes.readRemainingBytes(_l2ToL1message, offset);\n        } else {\n            revert InvalidSelector(bytes4(functionSignature));\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n            SHARED BRIDGE TOKEN BRIDGING LEGACY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2.\n    /// @param _depositSender The address of the deposit initiator.\n    /// @param _l1Token The address of the deposited L1 ERC20 token.\n    /// @param _amount The amount of the deposit that failed.\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization.\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed.\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message.\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent.\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization.\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external {\n        bytes32 assetId = l1NativeTokenVault.assetId(_l1Token);\n        bytes32 ntvAssetId = DataEncoding.encodeNTVAssetId(block.chainid, _l1Token);\n        if (assetId == bytes32(0)) {\n            assetId = ntvAssetId;\n        } else if (assetId != ntvAssetId) {\n            revert LegacyMethodForNonL1Token();\n        }\n\n        // For legacy deposits, the l2 receiver is not required to check tx data hash\n        // The token address does not have to be provided for this functionality either.\n        bytes memory assetData = DataEncoding.encodeBridgeBurnData(_amount, address(0), address(0));\n\n        _verifyAndClearFailedTransfer({\n            _checkedInLegacyBridge: false,\n            _depositSender: _depositSender,\n            _chainId: _chainId,\n            _assetId: assetId,\n            _assetData: assetData,\n            _l2TxHash: _l2TxHash,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _merkleProof: _merkleProof\n        });\n\n        l1AssetRouter.bridgeRecoverFailedTransfer({\n            _chainId: _chainId,\n            _depositSender: _depositSender,\n            _assetId: assetId,\n            _assetData: assetData\n        });\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    ERA ERC20 LEGACY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Withdraw funds from the initiated deposit, that failed when finalizing on ZKsync Era chain.\n    /// This function is specifically designed for maintaining backward-compatibility with legacy `claimFailedDeposit`\n    /// method in `L1ERC20Bridge`.\n    ///\n    /// @param _depositSender The address of the deposit initiator.\n    /// @param _l1Token The address of the deposited L1 ERC20 token.\n    /// @param _amount The amount of the deposit that failed.\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization.\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed.\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message.\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent.\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization.\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external override onlyLegacyBridge {\n        // For legacy deposits, the l2 receiver is not required to check tx data hash\n        // The token address does not have to be provided for this functionality either.\n        bytes memory assetData = DataEncoding.encodeBridgeBurnData(_amount, address(0), address(0));\n\n        /// the legacy bridge can only be used with L1 native tokens.\n        bytes32 assetId = DataEncoding.encodeNTVAssetId(block.chainid, _l1Token);\n\n        _verifyAndClearFailedTransfer({\n            _checkedInLegacyBridge: true,\n            _depositSender: _depositSender,\n            _chainId: ERA_CHAIN_ID,\n            _assetId: assetId,\n            _assetData: assetData,\n            _l2TxHash: _l2TxHash,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _merkleProof: _merkleProof\n        });\n\n        l1AssetRouter.bridgeRecoverFailedTransfer({\n            _chainId: ERA_CHAIN_ID,\n            _depositSender: _depositSender,\n            _assetId: assetId,\n            _assetData: assetData\n        });\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PAUSE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Pauses all functions marked with the `whenNotPaused` modifier.\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Unpauses the contract, allowing all functions marked with the `whenNotPaused` modifier to be called again.\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            LEGACY INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IL1Nullifier\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external override {\n        /// @dev We use a deprecated field to support L2->L1 legacy withdrawals, which were started\n        /// by the legacy bridge.\n        address legacyL2Bridge = __DEPRECATED_l2BridgeAddress[_chainId];\n        if (legacyL2Bridge == address(0)) {\n            revert LegacyBridgeNotSet();\n        }\n\n        FinalizeL1DepositParams memory finalizeWithdrawalParams = FinalizeL1DepositParams({\n            chainId: _chainId,\n            l2BatchNumber: _l2BatchNumber,\n            l2MessageIndex: _l2MessageIndex,\n            l2Sender: legacyL2Bridge,\n            l2TxNumberInBatch: _l2TxNumberInBatch,\n            message: _message,\n            merkleProof: _merkleProof\n        });\n        finalizeDeposit(finalizeWithdrawalParams);\n    }\n}\n"
      },
      "contracts/bridge/L2SharedBridgeLegacy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Initializable} from \"@openzeppelin/contracts-v4/proxy/utils/Initializable.sol\";\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts-v4/proxy/beacon/UpgradeableBeacon.sol\";\n\nimport {BridgedStandardERC20} from \"./BridgedStandardERC20.sol\";\n\nimport {L2_DEPLOYER_SYSTEM_CONTRACT_ADDR, L2_ASSET_ROUTER_ADDR, L2_NATIVE_TOKEN_VAULT_ADDR} from \"../common/L2ContractAddresses.sol\";\nimport {SystemContractsCaller} from \"../common/libraries/SystemContractsCaller.sol\";\nimport {L2ContractHelper, IContractDeployer} from \"../common/libraries/L2ContractHelper.sol\";\nimport {AddressAliasHelper} from \"../vendor/AddressAliasHelper.sol\";\n\nimport {IL2AssetRouter} from \"./asset-router/IL2AssetRouter.sol\";\nimport {IL2NativeTokenVault} from \"./ntv/IL2NativeTokenVault.sol\";\n\nimport {IL2SharedBridgeLegacy} from \"./interfaces/IL2SharedBridgeLegacy.sol\";\nimport {InvalidCaller, ZeroAddress, EmptyBytes32, Unauthorized, AmountMustBeGreaterThanZero, DeployFailed} from \"../common/L1ContractErrors.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The \"default\" bridge implementation for the ERC20 tokens. Note, that it does not\n/// support any custom token logic, i.e. rebase tokens' functionality is not supported.\n/// @dev Note, that this contract should be compatible with its previous version as it will be\n/// the primary bridge to be used during migration.\ncontract L2SharedBridgeLegacy is IL2SharedBridgeLegacy, Initializable {\n    /// @dev The address of the L1 shared bridge counterpart.\n    address public override l1SharedBridge;\n\n    /// @dev Contract that stores the implementation address for token.\n    /// @dev For more details see https://docs.openzeppelin.com/contracts/3.x/api/proxy#UpgradeableBeacon.\n    UpgradeableBeacon public l2TokenBeacon;\n\n    /// @dev Bytecode hash of the proxy for tokens deployed by the bridge.\n    bytes32 internal l2TokenProxyBytecodeHash;\n\n    /// @dev A mapping l2 token address => l1 token address\n    mapping(address l2TokenAddress => address l1TokenAddress) public override l1TokenAddress;\n\n    /// @dev The address of the legacy L1 erc20 bridge counterpart.\n    /// This is non-zero only on Era, and should not be renamed for backward compatibility with the SDKs.\n    // slither-disable-next-line uninitialized-state\n    address public override l1Bridge;\n\n    modifier onlyNTV() {\n        if (msg.sender != L2_NATIVE_TOKEN_VAULT_ADDR) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    modifier onlyAssetRouter() {\n        if (msg.sender != L2_ASSET_ROUTER_ADDR) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the bridge contract for later use. Expected to be used in the proxy.\n    /// @param _l1SharedBridge The address of the L1 Bridge contract.\n    /// @param _l2TokenProxyBytecodeHash The bytecode hash of the proxy for tokens deployed by the bridge.\n    /// @param _aliasedOwner The address of the governor contract.\n    function initialize(\n        address _l1SharedBridge,\n        bytes32 _l2TokenProxyBytecodeHash,\n        address _aliasedOwner\n    ) external reinitializer(2) {\n        if (_l1SharedBridge == address(0)) {\n            revert ZeroAddress();\n        }\n\n        if (_l2TokenProxyBytecodeHash == bytes32(0)) {\n            revert EmptyBytes32();\n        }\n\n        if (_aliasedOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        l1SharedBridge = _l1SharedBridge;\n\n        // The following statement is true only in freshly deployed environments. However,\n        // for those environments we do not need to deploy this contract at all.\n        // This check is primarily for local testing purposes.\n        if (l2TokenProxyBytecodeHash == bytes32(0) && address(l2TokenBeacon) == address(0)) {\n            address l2StandardToken = address(new BridgedStandardERC20{salt: bytes32(0)}());\n            l2TokenBeacon = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n            l2TokenProxyBytecodeHash = _l2TokenProxyBytecodeHash;\n            l2TokenBeacon.transferOwnership(_aliasedOwner);\n        }\n    }\n\n    /// @notice Initiates a withdrawal by burning funds on the contract and sending the message to L1\n    /// where tokens would be unlocked\n    /// @param _l1Receiver The account address that should receive funds on L1\n    /// @param _l2Token The L2 token address which is withdrawn\n    /// @param _amount The total amount of tokens to be withdrawn\n    function withdraw(address _l1Receiver, address _l2Token, uint256 _amount) external override {\n        if (_amount == 0) {\n            revert AmountMustBeGreaterThanZero();\n        }\n        IL2AssetRouter(L2_ASSET_ROUTER_ADDR).withdrawLegacyBridge(_l1Receiver, _l2Token, _amount, msg.sender);\n    }\n\n    /// @notice Finalize the deposit and mint funds\n    /// @param _l1Sender The account address that initiated the deposit on L1\n    /// @param _l2Receiver The account address that would receive minted ether\n    /// @param _l1Token The address of the token that was locked on the L1\n    /// @param _amount Total amount of tokens deposited from L1\n    /// @param _data The additional data that user can pass with the deposit\n    function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external {\n        // Only the L1 bridge counterpart can initiate and finalize the deposit.\n        if (\n            AddressAliasHelper.undoL1ToL2Alias(msg.sender) != l1Bridge &&\n            AddressAliasHelper.undoL1ToL2Alias(msg.sender) != l1SharedBridge\n        ) {\n            revert InvalidCaller(msg.sender);\n        }\n\n        IL2AssetRouter(L2_ASSET_ROUTER_ADDR).finalizeDepositLegacyBridge({\n            _l1Sender: _l1Sender,\n            _l2Receiver: _l2Receiver,\n            _l1Token: _l1Token,\n            _amount: _amount,\n            _data: _data\n        });\n\n        address l2Token = IL2NativeTokenVault(L2_NATIVE_TOKEN_VAULT_ADDR).l2TokenAddress(_l1Token);\n\n        if (l1TokenAddress[l2Token] == address(0)) {\n            l1TokenAddress[l2Token] = _l1Token;\n        }\n\n        emit FinalizeDeposit(_l1Sender, _l2Receiver, l2Token, _amount);\n    }\n\n    /// @return Address of an L2 token counterpart\n    function l2TokenAddress(address _l1Token) public view override returns (address) {\n        address token = IL2NativeTokenVault(L2_NATIVE_TOKEN_VAULT_ADDR).l2TokenAddress(_l1Token);\n        if (token != address(0)) {\n            return token;\n        }\n        return _calculateCreate2TokenAddress(_l1Token);\n    }\n\n    /// @notice Calculates L2 wrapped token address given the currently stored beacon proxy bytecode hash and beacon address.\n    /// @param _l1Token The address of token on L1.\n    /// @return Address of an L2 token counterpart.\n    function _calculateCreate2TokenAddress(address _l1Token) internal view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenBeacon), \"\"));\n        bytes32 salt = _getCreate2Salt(_l1Token);\n        return\n            L2ContractHelper.computeCreate2Address(address(this), salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n\n    /// @dev Convert the L1 token address to the create2 salt of deployed L2 token\n    function _getCreate2Salt(address _l1Token) internal pure returns (bytes32 salt) {\n        salt = bytes32(uint256(uint160(_l1Token)));\n    }\n\n    /// @dev Deploy the beacon proxy for the L2 token, while using ContractDeployer system contract.\n    /// @dev This function uses raw call to ContractDeployer to make sure that exactly `l2TokenProxyBytecodeHash` is used\n    /// for the code of the proxy.\n    function deployBeaconProxy(bytes32 salt) external onlyNTV returns (address proxy) {\n        (bool success, bytes memory returndata) = SystemContractsCaller.systemCallWithReturndata(\n            uint32(gasleft()),\n            L2_DEPLOYER_SYSTEM_CONTRACT_ADDR,\n            0,\n            abi.encodeCall(\n                IContractDeployer.create2,\n                (salt, l2TokenProxyBytecodeHash, abi.encode(address(l2TokenBeacon), \"\"))\n            )\n        );\n\n        // The deployment should be successful and return the address of the proxy\n        if (!success) {\n            revert DeployFailed();\n        }\n        proxy = abi.decode(returndata, (address));\n    }\n\n    function sendMessageToL1(bytes calldata _message) external override onlyAssetRouter returns (bytes32) {\n        // slither-disable-next-line unused-return\n        return L2ContractHelper.sendMessageToL1(_message);\n    }\n}\n"
      },
      "contracts/bridge/L2WrappedBaseToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable-v4/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\n\nimport {IL2WrappedBaseToken} from \"./interfaces/IL2WrappedBaseToken.sol\";\nimport {IBridgedStandardToken} from \"./interfaces/IBridgedStandardToken.sol\";\nimport {L2_NATIVE_TOKEN_VAULT_ADDR} from \"../common/L2ContractAddresses.sol\";\n\nimport {ZeroAddress, Unauthorized, BridgeMintNotImplemented, WithdrawFailed} from \"../common/L1ContractErrors.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The canonical implementation of the WETH token.\n/// @dev The idea is to replace the legacy WETH9 (which has well-known issues) with something better.\n/// This implementation has the following differences from the WETH9:\n/// - It does not have a silent fallback method and will revert if it's called for a method it hasn't implemented.\n/// - It implements `receive` method to allow users to deposit ether directly.\n/// - It implements `permit` method to allow users to sign a message instead of calling `approve`.\n/// - It implements `depositTo` method to allow users to deposit to another address.\n/// - It implements `withdrawTo` method to allow users to withdraw to another address.\n///\n/// Note: This is an upgradeable contract. In the future, we will remove upgradeability to make it trustless.\n/// But for now, when the Rollup has instant upgradability, we leave the possibility of upgrading to improve the contract if needed.\ncontract L2WrappedBaseToken is ERC20PermitUpgradeable, IL2WrappedBaseToken, IBridgedStandardToken {\n    /// @dev Address of the L2 WETH Bridge.\n    address public override l2Bridge;\n\n    /// @dev Address of the L1 base token. It can be deposited to mint this L2 token.\n    address public override l1Address;\n\n    /// @dev Address of the native token vault.\n    address public override nativeTokenVault;\n\n    /// @dev The assetId of the base token. The wrapped token does not have its own assetId.\n    bytes32 public baseTokenAssetId;\n\n    modifier onlyBridge() {\n        if (msg.sender != l2Bridge) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    constructor() {\n        // Disable initialization to prevent Parity hack.\n        _disableInitializers();\n    }\n\n    /// @dev Fallback function to allow receiving Ether.\n    receive() external payable {\n        depositTo(msg.sender);\n    }\n\n    /// @notice Initializes a contract token for later use. Expected to be used in the proxy.\n    /// @notice This function is used to integrate the previously deployed WETH token with the bridge.\n    /// @dev Sets up `name`/`symbol`/`decimals` getters.\n    /// @param name_ The name of the token.\n    /// @param symbol_ The symbol of the token.\n    /// @param _l2Bridge Address of the L2 bridge\n    /// @param _l1Address Address of the L1 token that can be deposited to mint this L2 WETH.\n    /// Note: The decimals are hardcoded to 18, the same as on Ether.\n    function initializeV3(\n        string calldata name_,\n        string calldata symbol_,\n        address _l2Bridge,\n        address _l1Address,\n        bytes32 _baseTokenAssetId\n    ) external reinitializer(3) {\n        if (_l2Bridge == address(0)) {\n            revert ZeroAddress();\n        }\n\n        if (_l1Address == address(0)) {\n            revert ZeroAddress();\n        }\n        if (_baseTokenAssetId == bytes32(0)) {\n            revert ZeroAddress();\n        }\n        l2Bridge = _l2Bridge;\n        l1Address = _l1Address;\n        nativeTokenVault = L2_NATIVE_TOKEN_VAULT_ADDR;\n        baseTokenAssetId = _baseTokenAssetId;\n\n        // Set decoded values for name and symbol.\n        __ERC20_init_unchained(name_, symbol_);\n\n        // Set the name for EIP-712 signature.\n        __ERC20Permit_init(name_);\n\n        emit Initialize(name_, symbol_, 18);\n    }\n\n    /// @notice Function for minting tokens on L2, implemented only to be compatible with IL2StandardToken interface.\n    /// Always reverts instead of minting anything!\n    /// Note: Use `deposit`/`depositTo` methods instead.\n    // solhint-disable-next-line no-unused-vars\n    function bridgeMint(address _to, uint256 _amount) external override onlyBridge {\n        revert BridgeMintNotImplemented();\n    }\n\n    /// @dev Burn tokens from a given account and send the same amount of Ether to the bridge.\n    /// @param _from The account from which tokens will be burned.\n    /// @param _amount The amount that will be burned.\n    /// @notice Should be called by the bridge before withdrawing tokens to L1.\n    function bridgeBurn(address _from, uint256 _amount) external override onlyBridge {\n        _burn(_from, _amount);\n        // sends Ether to the bridge\n        (bool success, ) = msg.sender.call{value: _amount}(\"\");\n        if (!success) {\n            revert WithdrawFailed();\n        }\n\n        emit BridgeBurn(_from, _amount);\n    }\n\n    /// @notice Deposit Ether to mint WETH.\n    function deposit() external payable override {\n        depositTo(msg.sender);\n    }\n\n    /// @notice Withdraw WETH to get Ether.\n    function withdraw(uint256 _amount) external override {\n        withdrawTo(msg.sender, _amount);\n    }\n\n    /// @notice Deposit Ether to mint WETH to a given account.\n    function depositTo(address _to) public payable override {\n        _mint(_to, msg.value);\n    }\n\n    /// @notice Withdraw WETH to get Ether to a given account.\n    /// burns sender's tokens and sends Ether to the given account\n    function withdrawTo(address _to, uint256 _amount) public override {\n        _burn(msg.sender, _amount);\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        if (!success) {\n            revert WithdrawFailed();\n        }\n    }\n\n    function originToken() external view override returns (address) {\n        return l1Address;\n    }\n\n    function assetId() external view override returns (bytes32) {\n        return baseTokenAssetId;\n    }\n}\n"
      },
      "contracts/bridge/L2WrappedBaseTokenStore.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable2Step} from \"@openzeppelin/contracts-v4/access/Ownable2Step.sol\";\n\nimport {ZeroAddress, Unauthorized, WrappedBaseTokenAlreadyRegistered} from \"../common/L1ContractErrors.sol\";\n\n/// @title L2WrappedBaseTokenStore\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice This contract is used as a store for L2 deployments of L2WrappedBaseToken for chains that have it.\n/// These values will be stored in the corresponding chain's L2NativeTokenVault upon migration to the new version,\n/// so these values being correct is crucial. The following upgrade process is expected for this contract:\n/// - It will be populated for the existing chains before the governance reviews the values.\n/// - Each new chain (before the new protocol version is available) will have to double check that the admin\n/// has set the correct value in this contract. If the admin did not set a correct value, the chain should be discarded.\n/// - Once the upgrade is done, this contract will no longer be needed. Even though it is unlikely for a chain to be corrupted,\n/// the governance can fix any corrupted chains in the next upgrade.\n/// @dev This contract is not expected to be deployed as a proxy, but rather a standalone contract.\n/// @dev The `admin` of this contract is expected to be some cold wallet, trusted to provide correct values. However,\n/// due to process above, even its malicious behavior should not impact security of the ecosystem.\n/// @dev The `owner` of this contract is trusted decentralized governance.\ncontract L2WrappedBaseTokenStore is Ownable2Step {\n    /// @notice Mapping from chain ID to L2 wrapped base token address.\n    mapping(uint256 chainId => address l2WBaseTokenAddress) public l2WBaseTokenAddress;\n\n    /// @notice Admin address who has the right to register weth token deployment for a chain.\n    address public admin;\n\n    /// @notice used to accept the admin role\n    address public pendingAdmin;\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Emitted when the L2 wrapped base token address is set for a chain\n    /// @param chainId The id of the chain.\n    /// @param l2WBaseTokenAddress The L2 wrapped base token address.\n    event NewWBaseTokenAddress(uint256 indexed chainId, address indexed l2WBaseTokenAddress);\n\n    /// @notice Sets the initial owner and admin.\n    /// @param _initialOwner The initial owner.\n    /// @param _admin The address of the admin.\n    constructor(address _initialOwner, address _admin) {\n        if (_admin == address(0) || _initialOwner == address(0)) {\n            revert ZeroAddress();\n        }\n        admin = _admin;\n        _transferOwnership(_initialOwner);\n    }\n\n    /// @notice Throws if called by any account other than the owner or admin.\n    modifier onlyOwnerOrAdmin() {\n        if (msg.sender != owner() && msg.sender != admin) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Initializes the L2 WBaseToken address for a specific chain ID.\n    /// @dev Can be called by the owner or the admin.\n    /// @param _chainId The ID of the blockchain network.\n    /// @param _l2WBaseToken The address of the L2 WBaseToken token.\n    function initializeChain(uint256 _chainId, address _l2WBaseToken) external onlyOwnerOrAdmin {\n        if (_l2WBaseToken == address(0)) {\n            revert ZeroAddress();\n        }\n        if (l2WBaseTokenAddress[_chainId] != address(0)) {\n            revert WrappedBaseTokenAlreadyRegistered();\n        }\n        _setWBaseTokenAddress(_chainId, _l2WBaseToken);\n    }\n\n    /// @notice Reinitializes the L2 WBaseToken address for a specific chain ID.\n    /// @dev Can only be called by the owner. It can not be called by the admin second time\n    /// to prevent retroactively damaging existing chains.\n    /// @param _chainId The ID of the blockchain network.\n    /// @param _l2WBaseToken The new address of the L2 WBaseToken token.\n    function reinitializeChain(uint256 _chainId, address _l2WBaseToken) external onlyOwner {\n        if (_l2WBaseToken == address(0)) {\n            revert ZeroAddress();\n        }\n        _setWBaseTokenAddress(_chainId, _l2WBaseToken);\n    }\n\n    /// @notice Sets the address of the L2 wrapped base token deployment for a chain.\n    /// @param _chainId The ID of the blockchain network.\n    /// @param _l2WBaseToken The new address of the L2 WBaseToken token.\n    function _setWBaseTokenAddress(uint256 _chainId, address _l2WBaseToken) internal {\n        l2WBaseTokenAddress[_chainId] = _l2WBaseToken;\n        emit NewWBaseTokenAddress(_chainId, _l2WBaseToken);\n    }\n\n    /// @notice Starts the transfer of admin rights. Only the current admin or owner can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    /// @dev Please note, if the owner wants to enforce the admin change it must execute both `setPendingAdmin` and\n    /// `acceptAdmin` atomically. Otherwise `admin` can set different pending admin and so fail to accept the admin rights.\n    function setPendingAdmin(address _newPendingAdmin) external onlyOwnerOrAdmin {\n        if (_newPendingAdmin == address(0)) {\n            revert ZeroAddress();\n        }\n        // Save previous value into the stack to put it into the event later\n        address oldPendingAdmin = pendingAdmin;\n        // Change pending admin\n        pendingAdmin = _newPendingAdmin;\n        emit NewPendingAdmin(oldPendingAdmin, _newPendingAdmin);\n    }\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external {\n        address currentPendingAdmin = pendingAdmin;\n        // Only proposed by current admin address can claim the admin rights\n        if (msg.sender != currentPendingAdmin) {\n            revert Unauthorized(msg.sender);\n        }\n\n        address previousAdmin = admin;\n        admin = currentPendingAdmin;\n        delete pendingAdmin;\n\n        emit NewPendingAdmin(currentPendingAdmin, address(0));\n        emit NewAdmin(previousAdmin, currentPendingAdmin);\n    }\n}\n"
      },
      "contracts/bridge/asset-router/AssetRouterBase.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Ownable2StepUpgradeable} from \"@openzeppelin/contracts-upgradeable-v4/access/Ownable2StepUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable-v4/security/PausableUpgradeable.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts-v4/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts-v4/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IAssetRouterBase} from \"./IAssetRouterBase.sol\";\nimport {IAssetHandler} from \"../interfaces/IAssetHandler.sol\";\nimport {DataEncoding} from \"../../common/libraries/DataEncoding.sol\";\n\nimport {L2_NATIVE_TOKEN_VAULT_ADDR} from \"../../common/L2ContractAddresses.sol\";\n\nimport {IBridgehub} from \"../../bridgehub/IBridgehub.sol\";\nimport {Unauthorized} from \"../../common/L1ContractErrors.sol\";\nimport {INativeTokenVault} from \"../ntv/INativeTokenVault.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev Bridges assets between L1 and ZK chain, supporting both ETH and ERC20 tokens.\n/// @dev Designed for use with a proxy for upgradability.\nabstract contract AssetRouterBase is IAssetRouterBase, Ownable2StepUpgradeable, PausableUpgradeable {\n    using SafeERC20 for IERC20;\n\n    /// @dev Bridgehub smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication.\n    IBridgehub public immutable override BRIDGE_HUB;\n\n    /// @dev Chain ID of L1 for bridging reasons\n    uint256 public immutable L1_CHAIN_ID;\n\n    /// @dev Chain ID of Era for legacy reasons\n    uint256 public immutable ERA_CHAIN_ID;\n\n    /// @dev Maps asset ID to address of corresponding asset handler.\n    /// @dev Tracks the address of Asset Handler contracts, where bridged funds are locked for each asset.\n    /// @dev P.S. this liquidity was locked directly in SharedBridge before.\n    /// @dev Current AssetHandlers: NTV for tokens, Bridgehub for chains.\n    mapping(bytes32 assetId => address assetHandlerAddress) public assetHandlerAddress;\n\n    /// @dev Maps asset ID to the asset deployment tracker address.\n    /// @dev Tracks the address of Deployment Tracker contract on L1, which sets Asset Handlers on L2s (ZK chain).\n    /// @dev For the asset and stores respective addresses.\n    /// @dev Current AssetDeploymentTrackers: NTV for tokens, CTMDeploymentTracker for chains.\n    mapping(bytes32 assetId => address assetDeploymentTracker) public assetDeploymentTracker;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n\n    /// @notice Checks that the message sender is the bridgehub.\n    modifier onlyBridgehub() {\n        if (msg.sender != address(BRIDGE_HUB)) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(uint256 _l1ChainId, uint256 _eraChainId, IBridgehub _bridgehub) {\n        L1_CHAIN_ID = _l1ChainId;\n        ERA_CHAIN_ID = _eraChainId;\n        BRIDGE_HUB = _bridgehub;\n    }\n\n    /// @inheritdoc IAssetRouterBase\n    function setAssetHandlerAddressThisChain(\n        bytes32 _assetRegistrationData,\n        address _assetHandlerAddress\n    ) external virtual override;\n\n    function _setAssetHandlerAddressThisChain(\n        address _nativeTokenVault,\n        bytes32 _assetRegistrationData,\n        address _assetHandlerAddress\n    ) internal {\n        bool senderIsNTV = msg.sender == address(_nativeTokenVault);\n        address sender = senderIsNTV ? L2_NATIVE_TOKEN_VAULT_ADDR : msg.sender;\n        bytes32 assetId = DataEncoding.encodeAssetId(block.chainid, _assetRegistrationData, sender);\n        if (!senderIsNTV && msg.sender != assetDeploymentTracker[assetId]) {\n            revert Unauthorized(msg.sender);\n        }\n        _setAssetHandler(assetId, _assetHandlerAddress);\n        assetDeploymentTracker[assetId] = msg.sender;\n        emit AssetDeploymentTrackerRegistered(assetId, _assetRegistrationData, msg.sender);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Receive transaction Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IAssetRouterBase\n    function finalizeDeposit(uint256 _chainId, bytes32 _assetId, bytes calldata _transferData) public payable virtual;\n\n    function _finalizeDeposit(\n        uint256 _chainId,\n        bytes32 _assetId,\n        bytes calldata _transferData,\n        address _nativeTokenVault\n    ) internal {\n        address assetHandler = assetHandlerAddress[_assetId];\n\n        if (assetHandler != address(0)) {\n            IAssetHandler(assetHandler).bridgeMint{value: msg.value}(_chainId, _assetId, _transferData);\n        } else {\n            _setAssetHandler(_assetId, _nativeTokenVault);\n            // Native token vault may not support non-zero `msg.value`, but we still provide it here to\n            // prevent the passed ETH from being stuck in the asset router and also for consistency.\n            // So the decision on whether to support non-zero `msg.value` is done at the asset handler layer.\n            IAssetHandler(_nativeTokenVault).bridgeMint{value: msg.value}(_chainId, _assetId, _transferData); // ToDo: Maybe it's better to receive amount and receiver here? transferData may have different encoding\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Internal Functions\n    //////////////////////////////////////////////////////////////*/\n\n    function _setAssetHandler(bytes32 _assetId, address _assetHandlerAddress) internal {\n        assetHandlerAddress[_assetId] = _assetHandlerAddress;\n        emit AssetHandlerRegistered(_assetId, _assetHandlerAddress);\n    }\n\n    /// @dev send the burn message to the asset\n    /// @notice Forwards the burn request for specific asset to respective asset handler.\n    /// @param _chainId The chain ID of the ZK chain to which to deposit.\n    /// @param _nextMsgValue The L2 `msg.value` from the L1 -> L2 deposit transaction.\n    /// @param _assetId The deposited asset ID.\n    /// @param _originalCaller The `msg.sender` address from the external call that initiated current one.\n    /// @param _transferData The encoded data, which is used by the asset handler to determine L2 recipient and amount. Might include extra information.\n    /// @param _passValue Boolean indicating whether to pass msg.value in the call.\n    /// @param _nativeTokenVault The address of the native token vault.\n    /// @return bridgeMintCalldata The calldata used by remote asset handler to mint tokens for recipient.\n    function _burn(\n        uint256 _chainId,\n        uint256 _nextMsgValue,\n        bytes32 _assetId,\n        address _originalCaller,\n        bytes memory _transferData,\n        bool _passValue,\n        address _nativeTokenVault\n    ) internal returns (bytes memory bridgeMintCalldata) {\n        address l1AssetHandler = assetHandlerAddress[_assetId];\n        if (l1AssetHandler == address(0)) {\n            // As a UX feature, whenever an asset handler is not present, we always try to register asset within native token vault.\n            // The Native Token Vault is trusted to revert in an asset does not belong to it.\n            //\n            // Note, that it may \"pollute\" error handling a bit: instead of getting error for asset handler not being\n            // present, the user will get whatever error the native token vault will return, however, providing\n            // more advanced error handling requires more extensive code and will be added in the future releases.\n            INativeTokenVault(_nativeTokenVault).tryRegisterTokenFromBurnData(_transferData, _assetId);\n\n            // We do not do any additional transformations here (like setting `assetHandler` in the mapping),\n            // because we expect that all those happened inside `tryRegisterTokenFromBurnData`\n\n            l1AssetHandler = _nativeTokenVault;\n        }\n\n        uint256 msgValue = _passValue ? msg.value : 0;\n        bridgeMintCalldata = IAssetHandler(l1AssetHandler).bridgeBurn{value: msgValue}({\n            _chainId: _chainId,\n            _msgValue: _nextMsgValue,\n            _assetId: _assetId,\n            _originalCaller: _originalCaller,\n            _data: _transferData\n        });\n    }\n\n    /// @notice Ensures that token is registered with native token vault.\n    /// @dev Only used when deposit is made with legacy data encoding format.\n    /// @param _token The native token address which should be registered with native token vault.\n    /// @return assetId The asset ID of the token provided.\n    function _ensureTokenRegisteredWithNTV(address _token) internal virtual returns (bytes32 assetId);\n\n    /*//////////////////////////////////////////////////////////////\n                            PAUSE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Pauses all functions marked with the `whenNotPaused` modifier.\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Unpauses the contract, allowing all functions marked with the `whenNotPaused` modifier to be called again.\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n"
      },
      "contracts/bridge/asset-router/IAssetRouterBase.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IBridgehub} from \"../../bridgehub/IBridgehub.sol\";\n\n/// @dev The encoding version used for legacy txs.\nbytes1 constant LEGACY_ENCODING_VERSION = 0x00;\n\n/// @dev The encoding version used for new txs.\nbytes1 constant NEW_ENCODING_VERSION = 0x01;\n\n/// @dev The encoding version used for txs that set the asset handler on the counterpart contract.\nbytes1 constant SET_ASSET_HANDLER_COUNTERPART_ENCODING_VERSION = 0x02;\n\n/// @title L1 Bridge contract interface\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IAssetRouterBase {\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        bytes32 assetId,\n        uint256 amount\n    );\n\n    event BridgehubDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        address indexed from,\n        bytes32 assetId,\n        bytes bridgeMintCalldata\n    );\n\n    event BridgehubWithdrawalInitiated(\n        uint256 chainId,\n        address indexed sender,\n        bytes32 indexed assetId,\n        bytes32 assetDataHash // Todo: What's the point of emitting hash?\n    );\n\n    event AssetDeploymentTrackerRegistered(\n        bytes32 indexed assetId,\n        bytes32 indexed additionalData,\n        address assetDeploymentTracker\n    );\n\n    event AssetHandlerRegistered(bytes32 indexed assetId, address indexed _assetHandlerAddress);\n\n    event DepositFinalizedAssetRouter(uint256 indexed chainId, bytes32 indexed assetId, bytes assetData);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    /// @notice Sets the asset handler address for a specified asset ID on the chain of the asset deployment tracker.\n    /// @dev The caller of this function is encoded within the `assetId`, therefore, it should be invoked by the asset deployment tracker contract.\n    /// @dev No access control on the caller, as msg.sender is encoded in the assetId.\n    /// @dev Typically, for most tokens, ADT is the native token vault. However, custom tokens may have their own specific asset deployment trackers.\n    /// @dev `setAssetHandlerAddressOnCounterpart` should be called on L1 to set asset handlers on L2 chains for a specific asset ID.\n    /// @param _assetRegistrationData The asset data which may include the asset address and any additional required data or encodings.\n    /// @param _assetHandlerAddress The address of the asset handler to be set for the provided asset.\n    function setAssetHandlerAddressThisChain(bytes32 _assetRegistrationData, address _assetHandlerAddress) external;\n\n    function assetHandlerAddress(bytes32 _assetId) external view returns (address);\n\n    /// @notice Finalize the withdrawal and release funds.\n    /// @param _chainId The chain ID of the transaction to check.\n    /// @param _assetId The bridged asset ID.\n    /// @param _transferData The position in the L2 logs Merkle tree of the l2Log that was sent with the message.\n    /// @dev We have both the legacy finalizeWithdrawal and the new finalizeDeposit functions,\n    /// finalizeDeposit uses the new format. On the L2 we have finalizeDeposit with new and old formats both.\n    function finalizeDeposit(uint256 _chainId, bytes32 _assetId, bytes memory _transferData) external payable;\n}\n"
      },
      "contracts/bridge/asset-router/IL1AssetRouter.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {IL1Nullifier} from \"../interfaces/IL1Nullifier.sol\";\nimport {INativeTokenVault} from \"../ntv/INativeTokenVault.sol\";\nimport {IAssetRouterBase} from \"./IAssetRouterBase.sol\";\nimport {L2TransactionRequestTwoBridgesInner} from \"../../bridgehub/IBridgehub.sol\";\nimport {IL1SharedBridgeLegacy} from \"../interfaces/IL1SharedBridgeLegacy.sol\";\n\n/// @title L1 Bridge contract interface\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IL1AssetRouter is IAssetRouterBase, IL1SharedBridgeLegacy {\n    event BridgehubMintData(bytes bridgeMintData);\n\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    event ClaimedFailedDepositAssetRouter(uint256 indexed chainId, bytes32 indexed assetId, bytes assetData);\n\n    event AssetDeploymentTrackerSet(\n        bytes32 indexed assetId,\n        address indexed assetDeploymentTracker,\n        bytes32 indexed additionalData\n    );\n\n    event LegacyDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted.\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens' functionality is not supported.\n    /// @param _originalCaller The `msg.sender` address from the external call that initiated current one.\n    /// @param _l2Receiver The account address that should receive funds on L2.\n    /// @param _l1Token The L1 token address which is deposited.\n    /// @param _amount The total amount of tokens to be bridged.\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction.\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction.\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return txHash The L2 transaction hash of deposit finalization.\n    function depositLegacyErc20Bridge(\n        address _originalCaller,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function L1_NULLIFIER() external view returns (IL1Nullifier);\n\n    function L1_WETH_TOKEN() external view returns (address);\n\n    function nativeTokenVault() external view returns (INativeTokenVault);\n\n    function setAssetDeploymentTracker(bytes32 _assetRegistrationData, address _assetDeploymentTracker) external;\n\n    function setNativeTokenVault(INativeTokenVault _nativeTokenVault) external;\n\n    /// @notice Withdraw funds from the initiated deposit, that failed when finalizing on L2.\n    /// @param _chainId The ZK chain id to which the deposit was initiated.\n    /// @param _depositSender The address of the entity that initiated the deposit.\n    /// @param _assetId The unique identifier of the deposited L1 token.\n    /// @param _assetData The encoded transfer data, which includes both the deposit amount and the address of the L2 receiver. Might include extra information.\n    /// @dev Processes claims of failed deposit, whether they originated from the legacy bridge or the current system.\n    function bridgeRecoverFailedTransfer(\n        uint256 _chainId,\n        address _depositSender,\n        bytes32 _assetId,\n        bytes calldata _assetData\n    ) external;\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2.\n    /// @param _chainId The ZK chain id to which deposit was initiated.\n    /// @param _depositSender The address of the entity that initiated the deposit.\n    /// @param _assetId The unique identifier of the deposited L1 token.\n    /// @param _assetData The encoded transfer data, which includes both the deposit amount and the address of the L2 receiver. Might include extra information.\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization.\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed.\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message.\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent.\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization.\n    /// @dev Processes claims of failed deposit, whether they originated from the legacy bridge or the current system.\n    function bridgeRecoverFailedTransfer(\n        uint256 _chainId,\n        address _depositSender,\n        bytes32 _assetId,\n        bytes memory _assetData,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    /// @notice Transfers funds to Native Token Vault, if the asset is registered with it. Does nothing for ETH or non-registered tokens.\n    /// @dev assetId is not the padded address, but the correct encoded id (NTV stores respective format for IDs)\n    /// @param _amount The asset amount to be transferred to native token vault.\n    /// @param _originalCaller The `msg.sender` address from the external call that initiated current one.\n    function transferFundsToNTV(bytes32 _assetId, uint256 _amount, address _originalCaller) external returns (bool);\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _chainId The chain ID of the transaction to check\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    /// @notice Initiates a transfer transaction within Bridgehub, used by `requestL2TransactionTwoBridges`.\n    /// @param _chainId The chain ID of the ZK chain to which deposit.\n    /// @param _originalCaller The `msg.sender` address from the external call that initiated current one.\n    /// @param _value The `msg.value` on the target chain tx.\n    /// @param _data The calldata for the second bridge deposit.\n    /// @return request The data used by the bridgehub to create L2 transaction request to specific ZK chain.\n    /// @dev Data has the following abi encoding for legacy deposits:\n    /// address _l1Token,\n    /// uint256 _amount,\n    /// address _l2Receiver\n    /// for new deposits:\n    /// bytes32 _assetId,\n    /// bytes _transferData\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _originalCaller,\n        uint256 _value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    /// @notice Generates a calldata for calling the deposit finalization on the L2 native token contract.\n    // / @param _chainId The chain ID of the ZK chain to which deposit.\n    /// @param _sender The address of the deposit initiator.\n    /// @param _assetId The deposited asset ID.\n    /// @param _assetData The encoded data, which is used by the asset handler to determine L2 recipient and amount. Might include extra information.\n    /// @return Returns calldata used on ZK chain.\n    function getDepositCalldata(\n        address _sender,\n        bytes32 _assetId,\n        bytes memory _assetData\n    ) external view returns (bytes memory);\n\n    /// @notice Allows bridgehub to acquire mintValue for L1->L2 transactions.\n    /// @dev If the corresponding L2 transaction fails, refunds are issued to a refund recipient on L2.\n    /// @param _chainId The chain ID of the ZK chain to which deposit.\n    /// @param _assetId The deposited asset ID.\n    /// @param _originalCaller The `msg.sender` address from the external call that initiated current one.\n    /// @param _amount The total amount of tokens to be bridged.\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        bytes32 _assetId,\n        address _originalCaller,\n        uint256 _amount\n    ) external payable;\n\n    /// @notice Routes the confirmation to nullifier for backward compatibility.\n    /// @notice Confirms the acceptance of a transaction by the Mailbox, as part of the L2 transaction process within Bridgehub.\n    /// This function is utilized by `requestL2TransactionTwoBridges` to validate the execution of a transaction.\n    /// @param _chainId The chain ID of the ZK chain to which confirm the deposit.\n    /// @param _txDataHash The keccak256 hash of 0x01 || abi.encode(bytes32, bytes) to identify deposits.\n    /// @param _txHash The hash of the L1->L2 transaction to confirm the deposit.\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n}\n"
      },
      "contracts/bridge/asset-router/IL2AssetRouter.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {IAssetRouterBase} from \"./IAssetRouterBase.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IL2AssetRouter is IAssetRouterBase {\n    event WithdrawalInitiatedAssetRouter(\n        uint256 chainId,\n        address indexed l2Sender,\n        bytes32 indexed assetId,\n        bytes assetData\n    );\n\n    function withdraw(bytes32 _assetId, bytes calldata _transferData) external returns (bytes32);\n\n    function L1_ASSET_ROUTER() external view returns (address);\n\n    function withdrawLegacyBridge(address _l1Receiver, address _l2Token, uint256 _amount, address _sender) external;\n\n    function finalizeDepositLegacyBridge(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n\n    /// @dev Used to set the assetHandlerAddress for a given assetId.\n    /// @dev Will be used by ZK Gateway\n    function setAssetHandlerAddress(uint256 _originChainId, bytes32 _assetId, address _assetHandlerAddress) external;\n\n    /// @notice Function that allows native token vault to register itself as the asset handler for\n    /// a legacy asset.\n    /// @param _assetId The assetId of the legacy token.\n    function setLegacyTokenAssetHandler(bytes32 _assetId) external;\n}\n"
      },
      "contracts/bridge/asset-router/L1AssetRouter.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IERC20} from \"@openzeppelin/contracts-v4/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts-v4/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IL1AssetRouter} from \"./IL1AssetRouter.sol\";\nimport {IL2AssetRouter} from \"./IL2AssetRouter.sol\";\nimport {IAssetRouterBase, LEGACY_ENCODING_VERSION, NEW_ENCODING_VERSION, SET_ASSET_HANDLER_COUNTERPART_ENCODING_VERSION} from \"./IAssetRouterBase.sol\";\nimport {AssetRouterBase} from \"./AssetRouterBase.sol\";\n\nimport {IL1AssetHandler} from \"../interfaces/IL1AssetHandler.sol\";\nimport {IL1ERC20Bridge} from \"../interfaces/IL1ERC20Bridge.sol\";\nimport {IAssetHandler} from \"../interfaces/IAssetHandler.sol\";\nimport {IL1Nullifier} from \"../interfaces/IL1Nullifier.sol\";\nimport {INativeTokenVault} from \"../ntv/INativeTokenVault.sol\";\nimport {IL2SharedBridgeLegacyFunctions} from \"../interfaces/IL2SharedBridgeLegacyFunctions.sol\";\n\nimport {ReentrancyGuard} from \"../../common/ReentrancyGuard.sol\";\nimport {DataEncoding} from \"../../common/libraries/DataEncoding.sol\";\nimport {AddressAliasHelper} from \"../../vendor/AddressAliasHelper.sol\";\nimport {TWO_BRIDGES_MAGIC_VALUE, ETH_TOKEN_ADDRESS} from \"../../common/Config.sol\";\nimport {NativeTokenVaultAlreadySet} from \"../L1BridgeContractErrors.sol\";\nimport {LegacyEncodingUsedForNonL1Token, LegacyBridgeUsesNonNativeToken, NonEmptyMsgValue, UnsupportedEncodingVersion, AssetIdNotSupported, AssetHandlerDoesNotExist, Unauthorized, ZeroAddress, TokenNotSupported, AddressAlreadyUsed, TokensWithFeesNotSupported} from \"../../common/L1ContractErrors.sol\";\nimport {L2_ASSET_ROUTER_ADDR} from \"../../common/L2ContractAddresses.sol\";\n\nimport {IBridgehub, L2TransactionRequestTwoBridgesInner, L2TransactionRequestDirect} from \"../../bridgehub/IBridgehub.sol\";\n\nimport {IL1AssetDeploymentTracker} from \"../interfaces/IL1AssetDeploymentTracker.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev Bridges assets between L1 and ZK chain, supporting both ETH and ERC20 tokens.\n/// @dev Designed for use with a proxy for upgradability.\ncontract L1AssetRouter is AssetRouterBase, IL1AssetRouter, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @dev The address of the WETH token on L1.\n    address public immutable override L1_WETH_TOKEN;\n\n    /// @dev The assetId of the base token.\n    bytes32 public immutable ETH_TOKEN_ASSET_ID;\n\n    /// @dev The address of ZKsync Era diamond proxy contract.\n    address internal immutable ERA_DIAMOND_PROXY;\n\n    /// @dev Address of nullifier.\n    IL1Nullifier public immutable L1_NULLIFIER;\n\n    /// @dev Address of native token vault.\n    INativeTokenVault public nativeTokenVault;\n\n    /// @dev Address of legacy bridge.\n    IL1ERC20Bridge public legacyBridge;\n\n    /// @notice Checks that the message sender is the nullifier.\n    modifier onlyNullifier() {\n        if (msg.sender != address(L1_NULLIFIER)) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Checks that the message sender is the bridgehub or ZKsync Era Diamond Proxy.\n    modifier onlyBridgehubOrEra(uint256 _chainId) {\n        if (msg.sender != address(BRIDGE_HUB) && (_chainId != ERA_CHAIN_ID || msg.sender != ERA_DIAMOND_PROXY)) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Checks that the message sender is the legacy bridge.\n    modifier onlyLegacyBridge() {\n        if (msg.sender != address(legacyBridge)) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Checks that the message sender is the native token vault.\n    modifier onlyNativeTokenVault() {\n        if (msg.sender != address(nativeTokenVault)) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(\n        address _l1WethAddress,\n        address _bridgehub,\n        address _l1Nullifier,\n        uint256 _eraChainId,\n        address _eraDiamondProxy\n    ) reentrancyGuardInitializer AssetRouterBase(block.chainid, _eraChainId, IBridgehub(_bridgehub)) {\n        _disableInitializers();\n        L1_WETH_TOKEN = _l1WethAddress;\n        ERA_DIAMOND_PROXY = _eraDiamondProxy;\n        L1_NULLIFIER = IL1Nullifier(_l1Nullifier);\n        ETH_TOKEN_ASSET_ID = DataEncoding.encodeNTVAssetId(block.chainid, ETH_TOKEN_ADDRESS);\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy.\n    /// @dev Used for testing purposes only, as the contract has been initialized on mainnet.\n    /// @param _owner The address which can change L2 token implementation and upgrade the bridge implementation.\n    /// The owner is the Governor and separate from the ProxyAdmin from now on, so that the Governor can call the bridge.\n    function initialize(address _owner) external reentrancyGuardInitializer initializer {\n        if (_owner == address(0)) {\n            revert ZeroAddress();\n        }\n        _transferOwnership(_owner);\n    }\n\n    /// @notice Sets the NativeTokenVault contract address.\n    /// @dev Should be called only once by the owner.\n    /// @param _nativeTokenVault The address of the native token vault.\n    function setNativeTokenVault(INativeTokenVault _nativeTokenVault) external onlyOwner {\n        if (address(nativeTokenVault) != address(0)) {\n            revert NativeTokenVaultAlreadySet();\n        }\n        if (address(_nativeTokenVault) == address(0)) {\n            revert ZeroAddress();\n        }\n        nativeTokenVault = _nativeTokenVault;\n        bytes32 ethAssetId = DataEncoding.encodeNTVAssetId(block.chainid, ETH_TOKEN_ADDRESS);\n        _setAssetHandler(ethAssetId, address(_nativeTokenVault));\n    }\n\n    /// @notice Sets the L1ERC20Bridge contract address.\n    /// @dev Should be called only once by the owner.\n    /// @param _legacyBridge The address of the legacy bridge.\n    function setL1Erc20Bridge(IL1ERC20Bridge _legacyBridge) external onlyOwner {\n        if (address(legacyBridge) != address(0)) {\n            revert AddressAlreadyUsed(address(legacyBridge));\n        }\n        if (address(_legacyBridge) == address(0)) {\n            revert ZeroAddress();\n        }\n        legacyBridge = _legacyBridge;\n    }\n\n    /// @notice Used to set the assed deployment tracker address for given asset data.\n    /// @param _assetRegistrationData The asset data which may include the asset address and any additional required data or encodings.\n    /// @param _assetDeploymentTracker The whitelisted address of asset deployment tracker for provided asset.\n    function setAssetDeploymentTracker(\n        bytes32 _assetRegistrationData,\n        address _assetDeploymentTracker\n    ) external onlyOwner {\n        bytes32 assetId = DataEncoding.encodeAssetId(block.chainid, _assetRegistrationData, _assetDeploymentTracker);\n        assetDeploymentTracker[assetId] = _assetDeploymentTracker;\n        emit AssetDeploymentTrackerSet(assetId, _assetDeploymentTracker, _assetRegistrationData);\n    }\n\n    /// @inheritdoc IAssetRouterBase\n    function setAssetHandlerAddressThisChain(\n        bytes32 _assetRegistrationData,\n        address _assetHandlerAddress\n    ) external override(AssetRouterBase, IAssetRouterBase) {\n        _setAssetHandlerAddressThisChain(address(nativeTokenVault), _assetRegistrationData, _assetHandlerAddress);\n    }\n\n    /// @notice Used to set the asset handler address for a given asset ID on a remote ZK chain\n    /// @param _chainId The ZK chain ID.\n    /// @param _originalCaller The `msg.sender` address from the external call that initiated current one.\n    /// @param _assetId The encoding of asset ID.\n    /// @param _assetHandlerAddressOnCounterpart The address of the asset handler, which will hold the token of interest.\n    /// @return request The tx request sent to the Bridgehub\n    function _setAssetHandlerAddressOnCounterpart(\n        uint256 _chainId,\n        address _originalCaller,\n        bytes32 _assetId,\n        address _assetHandlerAddressOnCounterpart\n    ) internal view returns (L2TransactionRequestTwoBridgesInner memory request) {\n        IL1AssetDeploymentTracker(assetDeploymentTracker[_assetId]).bridgeCheckCounterpartAddress(\n            _chainId,\n            _assetId,\n            _originalCaller,\n            _assetHandlerAddressOnCounterpart\n        );\n\n        bytes memory l2Calldata = abi.encodeCall(\n            IL2AssetRouter.setAssetHandlerAddress,\n            (block.chainid, _assetId, _assetHandlerAddressOnCounterpart)\n        );\n        request = L2TransactionRequestTwoBridgesInner({\n            magicValue: TWO_BRIDGES_MAGIC_VALUE,\n            l2Contract: L2_ASSET_ROUTER_ADDR,\n            l2Calldata: l2Calldata,\n            factoryDeps: new bytes[](0),\n            txDataHash: bytes32(0x00)\n        });\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INITIATTE DEPOSIT Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IL1AssetRouter\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        bytes32 _assetId,\n        address _originalCaller,\n        uint256 _amount\n    ) public payable virtual override onlyBridgehubOrEra(_chainId) whenNotPaused {\n        address assetHandler = assetHandlerAddress[_assetId];\n        if (assetHandler == address(0)) {\n            revert AssetHandlerDoesNotExist(_assetId);\n        }\n\n        // slither-disable-next-line unused-return\n        IAssetHandler(assetHandler).bridgeBurn{value: msg.value}({\n            _chainId: _chainId,\n            _msgValue: 0,\n            _assetId: _assetId,\n            _originalCaller: _originalCaller,\n            _data: DataEncoding.encodeBridgeBurnData(_amount, address(0), address(0))\n        });\n\n        // Note that we don't save the deposited amount, as this is for the base token, which gets sent to the refundRecipient if the tx fails\n        emit BridgehubDepositBaseTokenInitiated(_chainId, _originalCaller, _assetId, _amount);\n    }\n\n    /// @inheritdoc IL1AssetRouter\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _originalCaller,\n        uint256 _value,\n        bytes calldata _data\n    )\n        external\n        payable\n        virtual\n        override\n        onlyBridgehub\n        whenNotPaused\n        returns (L2TransactionRequestTwoBridgesInner memory request)\n    {\n        bytes32 assetId;\n        bytes memory transferData;\n        bytes1 encodingVersion = _data[0];\n        // The new encoding ensures that the calldata is collision-resistant with respect to the legacy format.\n        // In the legacy calldata, the first input was the address, meaning the most significant byte was always `0x00`.\n        if (encodingVersion == SET_ASSET_HANDLER_COUNTERPART_ENCODING_VERSION) {\n            if (msg.value != 0 || _value != 0) {\n                revert NonEmptyMsgValue();\n            }\n\n            (bytes32 _assetId, address _assetHandlerAddressOnCounterpart) = abi.decode(_data[1:], (bytes32, address));\n            return\n                _setAssetHandlerAddressOnCounterpart(\n                    _chainId,\n                    _originalCaller,\n                    _assetId,\n                    _assetHandlerAddressOnCounterpart\n                );\n        } else if (encodingVersion == NEW_ENCODING_VERSION) {\n            (assetId, transferData) = abi.decode(_data[1:], (bytes32, bytes));\n        } else if (encodingVersion == LEGACY_ENCODING_VERSION) {\n            (assetId, transferData) = _handleLegacyData(_data, _originalCaller);\n        } else {\n            revert UnsupportedEncodingVersion();\n        }\n\n        if (BRIDGE_HUB.baseTokenAssetId(_chainId) == assetId) {\n            revert AssetIdNotSupported(assetId);\n        }\n\n        address ntvCached = address(nativeTokenVault);\n\n        bytes memory bridgeMintCalldata = _burn({\n            _chainId: _chainId,\n            _nextMsgValue: _value,\n            _assetId: assetId,\n            _originalCaller: _originalCaller,\n            _transferData: transferData,\n            _passValue: true,\n            _nativeTokenVault: ntvCached\n        });\n\n        bytes32 txDataHash = DataEncoding.encodeTxDataHash({\n            _nativeTokenVault: ntvCached,\n            _encodingVersion: encodingVersion,\n            _originalCaller: _originalCaller,\n            _assetId: assetId,\n            _transferData: transferData\n        });\n\n        request = _requestToBridge({\n            _originalCaller: _originalCaller,\n            _assetId: assetId,\n            _bridgeMintCalldata: bridgeMintCalldata,\n            _txDataHash: txDataHash\n        });\n\n        emit BridgehubDepositInitiated({\n            chainId: _chainId,\n            txDataHash: txDataHash,\n            from: _originalCaller,\n            assetId: assetId,\n            bridgeMintCalldata: bridgeMintCalldata\n        });\n    }\n\n    /// @inheritdoc IL1AssetRouter\n    function bridgehubConfirmL2Transaction(\n        uint256 _chainId,\n        bytes32 _txDataHash,\n        bytes32 _txHash\n    ) external override onlyBridgehub whenNotPaused {\n        L1_NULLIFIER.bridgehubConfirmL2TransactionForwarded(_chainId, _txDataHash, _txHash);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Receive transaction Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IAssetRouterBase\n    function finalizeDeposit(\n        uint256 _chainId,\n        bytes32 _assetId,\n        bytes calldata _transferData\n    ) public payable override(AssetRouterBase, IAssetRouterBase) onlyNullifier {\n        _finalizeDeposit(_chainId, _assetId, _transferData, address(nativeTokenVault));\n        emit DepositFinalizedAssetRouter(_chainId, _assetId, _transferData);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            CLAIM FAILED DEPOSIT Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IL1AssetRouter\n    function bridgeRecoverFailedTransfer(\n        uint256 _chainId,\n        address _depositSender,\n        bytes32 _assetId,\n        bytes calldata _assetData\n    ) external override onlyNullifier nonReentrant whenNotPaused {\n        IL1AssetHandler(assetHandlerAddress[_assetId]).bridgeRecoverFailedTransfer(\n            _chainId,\n            _assetId,\n            _depositSender,\n            _assetData\n        );\n\n        emit ClaimedFailedDepositAssetRouter(_chainId, _assetId, _assetData);\n    }\n\n    function bridgeRecoverFailedTransfer(\n        uint256 _chainId,\n        address _depositSender,\n        bytes32 _assetId,\n        bytes calldata _assetData,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external {\n        L1_NULLIFIER.bridgeRecoverFailedTransfer({\n            _chainId: _chainId,\n            _depositSender: _depositSender,\n            _assetId: _assetId,\n            _assetData: _assetData,\n            _l2TxHash: _l2TxHash,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     Internal & Helpers\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Decodes the transfer input for legacy data and transfers allowance to NTV.\n    /// @dev Is not applicable for custom asset handlers.\n    /// @param _data The encoded transfer data (address _l1Token, uint256 _depositAmount, address _l2Receiver).\n    /// @return Tuple of asset ID and encoded transfer data to conform with new encoding standard.\n    function _handleLegacyData(bytes calldata _data, address) internal returns (bytes32, bytes memory) {\n        (address _l1Token, uint256 _depositAmount, address _l2Receiver) = abi.decode(\n            _data,\n            (address, uint256, address)\n        );\n        bytes32 assetId = _ensureTokenRegisteredWithNTV(_l1Token);\n\n        // We ensure that the legacy data format can not be used for tokens that did not originate from L1.\n        bytes32 expectedAssetId = DataEncoding.encodeNTVAssetId(block.chainid, _l1Token);\n        if (assetId != expectedAssetId) {\n            revert LegacyEncodingUsedForNonL1Token();\n        }\n\n        if (assetId == ETH_TOKEN_ASSET_ID) {\n            // In the old SDK/contracts the user had to always provide `0` as the deposit amount for ETH token, while\n            // ultimately the provided `msg.value` was used as the deposit amount. This check is needed for backwards compatibility.\n\n            if (_depositAmount == 0) {\n                _depositAmount = msg.value;\n            }\n        }\n\n        return (assetId, DataEncoding.encodeBridgeBurnData(_depositAmount, _l2Receiver, _l1Token));\n    }\n\n    /// @notice Ensures that token is registered with native token vault.\n    /// @dev Only used when deposit is made with legacy data encoding format.\n    /// @param _token The native token address which should be registered with native token vault.\n    /// @return assetId The asset ID of the token provided.\n    function _ensureTokenRegisteredWithNTV(address _token) internal override returns (bytes32 assetId) {\n        assetId = nativeTokenVault.assetId(_token);\n        if (assetId != bytes32(0)) {\n            return assetId;\n        }\n        nativeTokenVault.ensureTokenIsRegistered(_token);\n        assetId = nativeTokenVault.assetId(_token);\n    }\n\n    /// @inheritdoc IL1AssetRouter\n    function transferFundsToNTV(\n        bytes32 _assetId,\n        uint256 _amount,\n        address _originalCaller\n    ) external onlyNativeTokenVault returns (bool) {\n        address l1TokenAddress = INativeTokenVault(address(nativeTokenVault)).tokenAddress(_assetId);\n        if (l1TokenAddress == address(0) || l1TokenAddress == ETH_TOKEN_ADDRESS) {\n            return false;\n        }\n        IERC20 l1Token = IERC20(l1TokenAddress);\n\n        // Do the transfer if allowance to Shared bridge is bigger than amount\n        // And if there is not enough allowance for the NTV\n        bool weCanTransfer = false;\n        if (l1Token.allowance(address(legacyBridge), address(this)) >= _amount) {\n            _originalCaller = address(legacyBridge);\n            weCanTransfer = true;\n        } else if (\n            l1Token.allowance(_originalCaller, address(this)) >= _amount &&\n            l1Token.allowance(_originalCaller, address(nativeTokenVault)) < _amount\n        ) {\n            weCanTransfer = true;\n        }\n        if (weCanTransfer) {\n            uint256 balanceBefore = l1Token.balanceOf(address(nativeTokenVault));\n            // slither-disable-next-line arbitrary-send-erc20\n            l1Token.safeTransferFrom(_originalCaller, address(nativeTokenVault), _amount);\n            uint256 balanceAfter = l1Token.balanceOf(address(nativeTokenVault));\n\n            if (balanceAfter - balanceBefore != _amount) {\n                revert TokensWithFeesNotSupported();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /// @dev The request data that is passed to the bridgehub.\n    /// @param _originalCaller The `msg.sender` address from the external call that initiated current one.\n    /// @param _assetId The deposited asset ID.\n    /// @param _bridgeMintCalldata The calldata used by remote asset handler to mint tokens for recipient.\n    /// @param _txDataHash The keccak256 hash of 0x01 || abi.encode(bytes32, bytes) to identify deposits.\n    /// @return request The data used by the bridgehub to create L2 transaction request to specific ZK chain.\n    function _requestToBridge(\n        address _originalCaller,\n        bytes32 _assetId,\n        bytes memory _bridgeMintCalldata,\n        bytes32 _txDataHash\n    ) internal view virtual returns (L2TransactionRequestTwoBridgesInner memory request) {\n        bytes memory l2TxCalldata = getDepositCalldata(_originalCaller, _assetId, _bridgeMintCalldata);\n\n        request = L2TransactionRequestTwoBridgesInner({\n            magicValue: TWO_BRIDGES_MAGIC_VALUE,\n            l2Contract: L2_ASSET_ROUTER_ADDR,\n            l2Calldata: l2TxCalldata,\n            factoryDeps: new bytes[](0),\n            txDataHash: _txDataHash\n        });\n    }\n\n    /// @inheritdoc IL1AssetRouter\n    function getDepositCalldata(\n        address _sender,\n        bytes32 _assetId,\n        bytes memory _assetData\n    ) public view override returns (bytes memory) {\n        // First branch covers the case when asset is not registered with NTV (custom asset handler)\n        // Second branch handles tokens registered with NTV and uses legacy calldata encoding\n        // We need to use the legacy encoding to support the old SDK, which relies on a specific encoding of the data.\n        if (\n            (nativeTokenVault.tokenAddress(_assetId) == address(0)) ||\n            (nativeTokenVault.originChainId(_assetId) != block.chainid)\n        ) {\n            return abi.encodeCall(IAssetRouterBase.finalizeDeposit, (block.chainid, _assetId, _assetData));\n        } else {\n            // slither-disable-next-line unused-return\n            (, address _receiver, address _parsedNativeToken, uint256 _amount, bytes memory _gettersData) = DataEncoding\n                .decodeBridgeMintData(_assetData);\n            return\n                _getLegacyNTVCalldata({\n                    _sender: _sender,\n                    _receiver: _receiver,\n                    _parsedNativeToken: _parsedNativeToken,\n                    _amount: _amount,\n                    _gettersData: _gettersData\n                });\n        }\n    }\n\n    function _getLegacyNTVCalldata(\n        address _sender,\n        address _receiver,\n        address _parsedNativeToken,\n        uint256 _amount,\n        bytes memory _gettersData\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeCall(\n                IL2SharedBridgeLegacyFunctions.finalizeDeposit,\n                (_sender, _receiver, _parsedNativeToken, _amount, _gettersData)\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     Legacy Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IL1AssetRouter\n    function depositLegacyErc20Bridge(\n        address _originalCaller,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable override onlyLegacyBridge nonReentrant whenNotPaused returns (bytes32 txHash) {\n        if (_l1Token == L1_WETH_TOKEN) {\n            revert TokenNotSupported(L1_WETH_TOKEN);\n        }\n\n        bytes32 _assetId;\n        {\n            // Note, that to keep the code simple, while avoiding \"stack too deep\" error,\n            // this `bridgeData` variable is reused in two places with different meanings:\n            // - Firstly, it denotes the bridgeBurn data to be used for the NativeTokenVault\n            // - Secondly, after the call to `_burn` function, it denotes the `bridgeMint` data that\n            // will be sent to the L2 counterpart of the L1NTV.\n            bytes memory bridgeData = DataEncoding.encodeBridgeBurnData(_amount, _l2Receiver, _l1Token);\n            // Inner call to encode data to decrease local var numbers\n            _assetId = _ensureTokenRegisteredWithNTV(_l1Token);\n            // Legacy bridge is only expected to use native tokens for L1.\n            if (_assetId != DataEncoding.encodeNTVAssetId(block.chainid, _l1Token)) {\n                revert LegacyBridgeUsesNonNativeToken();\n            }\n\n            // Note, that starting from here `bridgeData` starts denoting bridgeMintData.\n            bridgeData = _burn({\n                _chainId: ERA_CHAIN_ID,\n                _nextMsgValue: 0,\n                _assetId: _assetId,\n                _originalCaller: _originalCaller,\n                _transferData: bridgeData,\n                _passValue: false,\n                _nativeTokenVault: address(nativeTokenVault)\n            });\n\n            bytes memory l2TxCalldata = getDepositCalldata(_originalCaller, _assetId, bridgeData);\n\n            // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n            // Otherwise, the refund will be sent to the specified address.\n            // If the recipient is a contract on L1, the address alias will be applied.\n            address refundRecipient = AddressAliasHelper.actualRefundRecipient(_refundRecipient, _originalCaller);\n\n            L2TransactionRequestDirect memory request = L2TransactionRequestDirect({\n                chainId: ERA_CHAIN_ID,\n                l2Contract: L2_ASSET_ROUTER_ADDR,\n                mintValue: msg.value, // l2 gas + l2 msg.Value the bridgehub will withdraw the mintValue from the base token bridge for gas\n                l2Value: 0, // L2 msg.value, this contract doesn't support base token deposits or wrapping functionality, for direct deposits use bridgehub\n                l2Calldata: l2TxCalldata,\n                l2GasLimit: _l2TxGasLimit,\n                l2GasPerPubdataByteLimit: _l2TxGasPerPubdataByte,\n                factoryDeps: new bytes[](0),\n                refundRecipient: refundRecipient\n            });\n            txHash = BRIDGE_HUB.requestL2TransactionDirect{value: msg.value}(request);\n        }\n\n        {\n            bytes memory transferData = DataEncoding.encodeBridgeBurnData(_amount, _l2Receiver, _l1Token);\n            // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n            L1_NULLIFIER.bridgehubConfirmL2TransactionForwarded(\n                ERA_CHAIN_ID,\n                DataEncoding.encodeTxDataHash({\n                    _encodingVersion: LEGACY_ENCODING_VERSION,\n                    _originalCaller: _originalCaller,\n                    _assetId: _assetId,\n                    _nativeTokenVault: address(nativeTokenVault),\n                    _transferData: transferData\n                }),\n                txHash\n            );\n        }\n\n        emit LegacyDepositInitiated({\n            chainId: ERA_CHAIN_ID,\n            l2DepositTxHash: txHash,\n            from: _originalCaller,\n            to: _l2Receiver,\n            l1Token: _l1Token,\n            amount: _amount\n        });\n    }\n\n    /// @inheritdoc IL1AssetRouter\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external override {\n        L1_NULLIFIER.finalizeWithdrawal({\n            _chainId: _chainId,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2.\n    /// @param _depositSender The address of the deposit initiator.\n    /// @param _l1Token The address of the deposited L1 ERC20 token.\n    /// @param _amount The amount of the deposit that failed.\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization.\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed.\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message.\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent.\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization.\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external {\n        L1_NULLIFIER.claimFailedDeposit({\n            _chainId: _chainId,\n            _depositSender: _depositSender,\n            _l1Token: _l1Token,\n            _amount: _amount,\n            _l2TxHash: _l2TxHash,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    /// @notice Legacy read method, which forwards the call to L1Nullifier to check if withdrawal was finalized\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool) {\n        return L1_NULLIFIER.isWithdrawalFinalized(_chainId, _l2BatchNumber, _l2MessageIndex);\n    }\n\n    /// @notice Legacy function to get the L2 shared bridge address for a chain.\n    /// @dev In case the chain has been deployed after the gateway release,\n    /// the returned value is 0.\n    function l2BridgeAddress(uint256 _chainId) external view override returns (address) {\n        return L1_NULLIFIER.l2BridgeAddress(_chainId);\n    }\n}\n"
      },
      "contracts/bridge/asset-router/L2AssetRouter.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IL2AssetRouter} from \"./IL2AssetRouter.sol\";\nimport {IAssetRouterBase} from \"./IAssetRouterBase.sol\";\nimport {AssetRouterBase} from \"./AssetRouterBase.sol\";\n\nimport {IL2NativeTokenVault} from \"../ntv/IL2NativeTokenVault.sol\";\nimport {IL2SharedBridgeLegacy} from \"../interfaces/IL2SharedBridgeLegacy.sol\";\nimport {IBridgedStandardToken} from \"../interfaces/IBridgedStandardToken.sol\";\nimport {IL1ERC20Bridge} from \"../interfaces/IL1ERC20Bridge.sol\";\n\nimport {IBridgehub} from \"../../bridgehub/IBridgehub.sol\";\nimport {AddressAliasHelper} from \"../../vendor/AddressAliasHelper.sol\";\nimport {ReentrancyGuard} from \"../../common/ReentrancyGuard.sol\";\n\nimport {L2_NATIVE_TOKEN_VAULT_ADDR, L2_BRIDGEHUB_ADDR} from \"../../common/L2ContractAddresses.sol\";\nimport {L2ContractHelper} from \"../../common/libraries/L2ContractHelper.sol\";\nimport {DataEncoding} from \"../../common/libraries/DataEncoding.sol\";\nimport {TokenNotLegacy, EmptyAddress, InvalidCaller, AmountMustBeGreaterThanZero, AssetIdNotSupported} from \"../../common/L1ContractErrors.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The \"default\" bridge implementation for the ERC20 tokens. Note, that it does not\n/// support any custom token logic, i.e. rebase tokens' functionality is not supported.\ncontract L2AssetRouter is AssetRouterBase, IL2AssetRouter, ReentrancyGuard {\n    /// @dev The address of the L2 legacy shared bridge.\n    address public immutable L2_LEGACY_SHARED_BRIDGE;\n\n    /// @dev The asset id of the base token.\n    bytes32 public immutable BASE_TOKEN_ASSET_ID;\n\n    /// @dev The address of the L1 asset router counterpart.\n    address public immutable override L1_ASSET_ROUTER;\n\n    /// @notice Checks that the message sender is the L1 Asset Router.\n    modifier onlyAssetRouterCounterpart(uint256 _originChainId) {\n        if (_originChainId == L1_CHAIN_ID) {\n            // Only the L1 Asset Router counterpart can initiate and finalize the deposit.\n            if (AddressAliasHelper.undoL1ToL2Alias(msg.sender) != L1_ASSET_ROUTER) {\n                revert InvalidCaller(msg.sender);\n            }\n        } else {\n            revert InvalidCaller(msg.sender); // xL2 messaging not supported for now\n        }\n        _;\n    }\n\n    /// @notice Checks that the message sender is the L1 Asset Router.\n    modifier onlyAssetRouterCounterpartOrSelf(uint256 _chainId) {\n        if (_chainId == L1_CHAIN_ID) {\n            // Only the L1 Asset Router counterpart can initiate and finalize the deposit.\n            if ((AddressAliasHelper.undoL1ToL2Alias(msg.sender) != L1_ASSET_ROUTER) && (msg.sender != address(this))) {\n                revert InvalidCaller(msg.sender);\n            }\n        } else {\n            revert InvalidCaller(msg.sender); // xL2 messaging not supported for now\n        }\n        _;\n    }\n\n    /// @notice Checks that the message sender is the legacy L2 bridge.\n    modifier onlyLegacyBridge() {\n        if (msg.sender != L2_LEGACY_SHARED_BRIDGE) {\n            revert InvalidCaller(msg.sender);\n        }\n        _;\n    }\n\n    modifier onlyNTV() {\n        if (msg.sender != L2_NATIVE_TOKEN_VAULT_ADDR) {\n            revert InvalidCaller(msg.sender);\n        }\n        _;\n    }\n\n    /// @dev Disable the initialization to prevent Parity hack.\n    /// @dev this contract is deployed in the L2GenesisUpgrade, and is meant as direct deployment without a proxy.\n    /// @param _l1AssetRouter The address of the L1 Bridge contract.\n    constructor(\n        uint256 _l1ChainId,\n        uint256 _eraChainId,\n        address _l1AssetRouter,\n        address _legacySharedBridge,\n        bytes32 _baseTokenAssetId,\n        address _aliasedOwner\n    ) AssetRouterBase(_l1ChainId, _eraChainId, IBridgehub(L2_BRIDGEHUB_ADDR)) reentrancyGuardInitializer {\n        L2_LEGACY_SHARED_BRIDGE = _legacySharedBridge;\n        if (_l1AssetRouter == address(0)) {\n            revert EmptyAddress();\n        }\n        L1_ASSET_ROUTER = _l1AssetRouter;\n        _setAssetHandler(_baseTokenAssetId, L2_NATIVE_TOKEN_VAULT_ADDR);\n        BASE_TOKEN_ASSET_ID = _baseTokenAssetId;\n        _disableInitializers();\n        _transferOwnership(_aliasedOwner);\n    }\n\n    /// @inheritdoc IL2AssetRouter\n    function setAssetHandlerAddress(\n        uint256 _originChainId,\n        bytes32 _assetId,\n        address _assetHandlerAddress\n    ) external override onlyAssetRouterCounterpart(_originChainId) {\n        _setAssetHandler(_assetId, _assetHandlerAddress);\n    }\n\n    /// @inheritdoc IAssetRouterBase\n    function setAssetHandlerAddressThisChain(\n        bytes32 _assetRegistrationData,\n        address _assetHandlerAddress\n    ) external override(AssetRouterBase, IAssetRouterBase) {\n        _setAssetHandlerAddressThisChain(L2_NATIVE_TOKEN_VAULT_ADDR, _assetRegistrationData, _assetHandlerAddress);\n    }\n\n    function setLegacyTokenAssetHandler(bytes32 _assetId) external override onlyNTV {\n        // Note, that it is an asset handler, but not asset deployment tracker,\n        // which is located on L1.\n        _setAssetHandler(_assetId, L2_NATIVE_TOKEN_VAULT_ADDR);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Receive transaction Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Finalize the deposit and mint funds\n    /// @param _assetId The encoding of the asset on L2\n    /// @param _transferData The encoded data required for deposit (address _l1Sender, uint256 _amount, address _l2Receiver, bytes memory erc20Data, address originToken)\n    function finalizeDeposit(\n        // solhint-disable-next-line no-unused-vars\n        uint256,\n        bytes32 _assetId,\n        bytes calldata _transferData\n    )\n        public\n        payable\n        override(AssetRouterBase, IAssetRouterBase)\n        onlyAssetRouterCounterpartOrSelf(L1_CHAIN_ID)\n        nonReentrant\n    {\n        if (_assetId == BASE_TOKEN_ASSET_ID) {\n            revert AssetIdNotSupported(BASE_TOKEN_ASSET_ID);\n        }\n        _finalizeDeposit(L1_CHAIN_ID, _assetId, _transferData, L2_NATIVE_TOKEN_VAULT_ADDR);\n\n        emit DepositFinalizedAssetRouter(L1_CHAIN_ID, _assetId, _transferData);\n    }\n\n    /// @notice Initiates a withdrawal by burning funds on the contract and sending the message to L1\n    /// where tokens would be unlocked\n    /// @dev IMPORTANT: this method will be deprecated in one of the future releases, so contracts\n    /// that rely on it must be upgradeable.\n    /// @param _assetId The asset id of the withdrawn asset\n    /// @param _assetData The data that is passed to the asset handler contract\n    function withdraw(bytes32 _assetId, bytes memory _assetData) public override nonReentrant returns (bytes32) {\n        return _withdrawSender(_assetId, _assetData, msg.sender, true);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     Internal & Helpers\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc AssetRouterBase\n    function _ensureTokenRegisteredWithNTV(address _token) internal override returns (bytes32 assetId) {\n        IL2NativeTokenVault nativeTokenVault = IL2NativeTokenVault(L2_NATIVE_TOKEN_VAULT_ADDR);\n        nativeTokenVault.ensureTokenIsRegistered(_token);\n        assetId = nativeTokenVault.assetId(_token);\n    }\n\n    /// @param _assetId The asset id of the withdrawn asset\n    /// @param _assetData The data that is passed to the asset handler contract\n    /// @param _sender The address of the sender of the message\n    /// @param _alwaysNewMessageFormat Whether to use the new message format compatible with Custom Asset Handlers\n    function _withdrawSender(\n        bytes32 _assetId,\n        bytes memory _assetData,\n        address _sender,\n        bool _alwaysNewMessageFormat\n    ) internal returns (bytes32 txHash) {\n        bytes memory l1bridgeMintData = _burn({\n            _chainId: L1_CHAIN_ID,\n            _nextMsgValue: 0,\n            _assetId: _assetId,\n            _originalCaller: _sender,\n            _transferData: _assetData,\n            _passValue: false,\n            _nativeTokenVault: L2_NATIVE_TOKEN_VAULT_ADDR\n        });\n\n        bytes memory message;\n        if (_alwaysNewMessageFormat || L2_LEGACY_SHARED_BRIDGE == address(0)) {\n            message = _getAssetRouterWithdrawMessage(_assetId, l1bridgeMintData);\n            // slither-disable-next-line unused-return\n            txHash = L2ContractHelper.sendMessageToL1(message);\n        } else {\n            address l1Token = IBridgedStandardToken(\n                IL2NativeTokenVault(L2_NATIVE_TOKEN_VAULT_ADDR).tokenAddress(_assetId)\n            ).originToken();\n            if (l1Token == address(0)) {\n                revert AssetIdNotSupported(_assetId);\n            }\n            // slither-disable-next-line unused-return\n            (uint256 amount, address l1Receiver, ) = DataEncoding.decodeBridgeBurnData(_assetData);\n            message = _getSharedBridgeWithdrawMessage(l1Receiver, l1Token, amount);\n            txHash = IL2SharedBridgeLegacy(L2_LEGACY_SHARED_BRIDGE).sendMessageToL1(message);\n        }\n\n        emit WithdrawalInitiatedAssetRouter(L1_CHAIN_ID, _sender, _assetId, _assetData);\n    }\n\n    /// @notice Encodes the message for l2ToL1log sent during withdraw initialization.\n    /// @param _assetId The encoding of the asset on L2 which is withdrawn.\n    /// @param _l1bridgeMintData The calldata used by l1 asset handler to unlock tokens for recipient.\n    function _getAssetRouterWithdrawMessage(\n        bytes32 _assetId,\n        bytes memory _l1bridgeMintData\n    ) internal view returns (bytes memory) {\n        // solhint-disable-next-line func-named-parameters\n        return abi.encodePacked(IAssetRouterBase.finalizeDeposit.selector, block.chainid, _assetId, _l1bridgeMintData);\n    }\n\n    /// @notice Encodes the message for l2ToL1log sent during withdraw initialization.\n    function _getSharedBridgeWithdrawMessage(\n        address _l1Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) internal pure returns (bytes memory) {\n        // solhint-disable-next-line func-named-parameters\n        return abi.encodePacked(IL1ERC20Bridge.finalizeWithdrawal.selector, _l1Receiver, _l1Token, _amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            LEGACY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Legacy finalizeDeposit.\n    /// @dev Finalizes the deposit and mint funds.\n    /// @param _l1Sender The address of token sender on L1.\n    /// @param _l2Receiver The address of token receiver on L2.\n    /// @param _l1Token The address of the token transferred.\n    /// @param _amount The amount of the token transferred.\n    /// @param _data The metadata of the token transferred.\n    function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable onlyAssetRouterCounterpart(L1_CHAIN_ID) {\n        _translateLegacyFinalizeDeposit({\n            _l1Sender: _l1Sender,\n            _l2Receiver: _l2Receiver,\n            _l1Token: _l1Token,\n            _amount: _amount,\n            _data: _data\n        });\n    }\n\n    function finalizeDepositLegacyBridge(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external onlyLegacyBridge {\n        _translateLegacyFinalizeDeposit({\n            _l1Sender: _l1Sender,\n            _l2Receiver: _l2Receiver,\n            _l1Token: _l1Token,\n            _amount: _amount,\n            _data: _data\n        });\n    }\n\n    function _translateLegacyFinalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) internal {\n        bytes32 assetId = DataEncoding.encodeNTVAssetId(L1_CHAIN_ID, _l1Token);\n        // solhint-disable-next-line func-named-parameters\n        bytes memory data = DataEncoding.encodeBridgeMintData(_l1Sender, _l2Receiver, _l1Token, _amount, _data);\n        this.finalizeDeposit{value: msg.value}(L1_CHAIN_ID, assetId, data);\n    }\n\n    /// @notice Initiates a withdrawal by burning funds on the contract and sending the message to L1\n    /// where tokens would be unlocked\n    /// @dev A compatibility method to support legacy functionality for the SDK.\n    /// @param _l1Receiver The account address that should receive funds on L1\n    /// @param _l2Token The L2 token address which is withdrawn\n    /// @param _amount The total amount of tokens to be withdrawn\n    function withdraw(address _l1Receiver, address _l2Token, uint256 _amount) external nonReentrant {\n        if (_amount == 0) {\n            revert AmountMustBeGreaterThanZero();\n        }\n        _withdrawLegacy(_l1Receiver, _l2Token, _amount, msg.sender);\n    }\n\n    /// @notice Legacy withdraw.\n    /// @dev Finalizes the deposit and mint funds.\n    /// @param _l1Receiver The address of token receiver on L1.\n    /// @param _l2Token The address of token on L2.\n    /// @param _amount The amount of the token transferred.\n    /// @param _sender The original msg.sender.\n    function withdrawLegacyBridge(\n        address _l1Receiver,\n        address _l2Token,\n        uint256 _amount,\n        address _sender\n    ) external onlyLegacyBridge nonReentrant {\n        _withdrawLegacy(_l1Receiver, _l2Token, _amount, _sender);\n    }\n\n    function _withdrawLegacy(address _l1Receiver, address _l2Token, uint256 _amount, address _sender) internal {\n        address l1Address = l1TokenAddress(_l2Token);\n        if (l1Address == address(0)) {\n            revert TokenNotLegacy();\n        }\n        bytes32 assetId = DataEncoding.encodeNTVAssetId(L1_CHAIN_ID, l1Address);\n        bytes memory data = DataEncoding.encodeBridgeBurnData(_amount, _l1Receiver, _l2Token);\n        _withdrawSender(assetId, data, _sender, false);\n    }\n\n    /// @notice Legacy getL1TokenAddress.\n    /// @param _l2Token The address of token on L2.\n    /// @return The address of token on L1.\n    function l1TokenAddress(address _l2Token) public view returns (address) {\n        bytes32 assetId = IL2NativeTokenVault(L2_NATIVE_TOKEN_VAULT_ADDR).assetId(_l2Token);\n        if (assetId == bytes32(0)) {\n            return address(0);\n        }\n        uint256 originChainId = IL2NativeTokenVault(L2_NATIVE_TOKEN_VAULT_ADDR).originChainId(assetId);\n        if (originChainId != L1_CHAIN_ID) {\n            return address(0);\n        }\n\n        return IBridgedStandardToken(_l2Token).originToken();\n    }\n\n    /// @notice Legacy function used for backward compatibility to return L2 wrapped token\n    /// @notice address corresponding to provided L1 token address and deployed through NTV.\n    /// @dev However, the shared bridge can use custom asset handlers such that L2 addresses differ,\n    /// @dev or an L1 token may not have an L2 counterpart.\n    /// @param _l1Token The address of token on L1.\n    /// @return Address of an L2 token counterpart\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        IL2NativeTokenVault l2NativeTokenVault = IL2NativeTokenVault(L2_NATIVE_TOKEN_VAULT_ADDR);\n        address currentlyDeployedAddress = l2NativeTokenVault.l2TokenAddress(_l1Token);\n\n        if (currentlyDeployedAddress != address(0)) {\n            return currentlyDeployedAddress;\n        }\n\n        // For backwards compatibility, the bridge smust return the address of the token even if it\n        // has not been deployed yet.\n        return l2NativeTokenVault.calculateCreate2TokenAddress(L1_CHAIN_ID, _l1Token);\n    }\n\n    /// @notice Returns the address of the L1 asset router.\n    /// @dev The old name is kept for backward compatibility.\n    function l1Bridge() external view returns (address) {\n        return L1_ASSET_ROUTER;\n    }\n}\n"
      },
      "contracts/bridge/interfaces/AssetHandlerModifiers.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {NonEmptyMsgValue} from \"../../common/L1ContractErrors.sol\";\n\nabstract contract AssetHandlerModifiers {\n    /// @notice Modifier that ensures that a certain value is zero.\n    /// @dev This should be used in bridgeBurn-like functions to ensure that users\n    /// do not accidentally provide value there.\n    modifier requireZeroValue(uint256 _value) {\n        if (_value != 0) {\n            revert NonEmptyMsgValue();\n        }\n        _;\n    }\n}\n"
      },
      "contracts/bridge/interfaces/IAssetHandler.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\n/// @title Asset Handler contract interface\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Used for any asset handler and called by the AssetRouter\ninterface IAssetHandler {\n    /// @dev Emitted when a token is minted\n    event BridgeMint(uint256 indexed chainId, bytes32 indexed assetId, address receiver, uint256 amount);\n\n    /// @dev Emitted when a token is burned\n    event BridgeBurn(\n        uint256 indexed chainId,\n        bytes32 indexed assetId,\n        address indexed sender,\n        address receiver,\n        uint256 amount\n    );\n\n    /// @param _chainId the chainId that the message is from\n    /// @param _assetId the assetId of the asset being bridged\n    /// @param _data the actual data specified for the function\n    /// @dev Note, that while payable, this function will only receive base token on L2 chains,\n    /// while L1 the provided msg.value is always 0. However, this may change in the future,\n    /// so if your AssetHandler implementation relies on it, it is better to explicitly check it.\n    function bridgeMint(uint256 _chainId, bytes32 _assetId, bytes calldata _data) external payable;\n\n    /// @notice Burns bridged tokens and returns the calldata for L2 <-> L1 message.\n    /// @dev In case of native token vault _data is the tuple of _depositAmount and _l2Receiver.\n    /// @param _chainId the chainId that the message will be sent to\n    /// @param _msgValue the msg.value of the L2 transaction. For now it is always 0.\n    /// @param _assetId the assetId of the asset being bridged\n    /// @param _originalCaller the original caller of the\n    /// @param _data the actual data specified for the function\n    /// @return _bridgeMintData The calldata used by counterpart asset handler to unlock tokens for recipient.\n    function bridgeBurn(\n        uint256 _chainId,\n        uint256 _msgValue,\n        bytes32 _assetId,\n        address _originalCaller,\n        bytes calldata _data\n    ) external payable returns (bytes memory _bridgeMintData);\n}\n"
      },
      "contracts/bridge/interfaces/IBridgedStandardToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.20;\n\ninterface IBridgedStandardToken {\n    event BridgeInitialize(address indexed l1Token, string name, string symbol, uint8 decimals);\n\n    event BridgeMint(address indexed account, uint256 amount);\n\n    event BridgeBurn(address indexed account, uint256 amount);\n\n    function bridgeMint(address _account, uint256 _amount) external;\n\n    function bridgeBurn(address _account, uint256 _amount) external;\n\n    function l1Address() external view returns (address);\n\n    function originToken() external view returns (address);\n\n    function l2Bridge() external view returns (address);\n\n    function assetId() external view returns (bytes32);\n\n    function nativeTokenVault() external view returns (address);\n}\n"
      },
      "contracts/bridge/interfaces/IL1AssetDeploymentTracker.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IL1AssetDeploymentTracker {\n    function bridgeCheckCounterpartAddress(\n        uint256 _chainId,\n        bytes32 _assetId,\n        address _originalCaller,\n        address _assetHandlerAddressOnCounterpart\n    ) external view;\n}\n"
      },
      "contracts/bridge/interfaces/IL1AssetHandler.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\n/// @title L1 Asset Handler contract interface\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Used for any asset handler and called by the L1AssetRouter\ninterface IL1AssetHandler {\n    /// @param _chainId the chainId that the message will be sent to\n    /// @param _assetId the assetId of the asset being bridged\n    /// @param _depositSender the address of the entity that initiated the deposit.\n    /// @param _data the actual data specified for the function\n    function bridgeRecoverFailedTransfer(\n        uint256 _chainId,\n        bytes32 _assetId,\n        address _depositSender,\n        bytes calldata _data\n    ) external payable;\n}\n"
      },
      "contracts/bridge/interfaces/IL1BaseTokenAssetHandler.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\n/// @title L1 Base Token Asset Handler contract interface\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Used for any asset handler and called by the L1AssetRouter\ninterface IL1BaseTokenAssetHandler {\n    /// @notice Used to get the token address of an assetId\n    function tokenAddress(bytes32 _assetId) external view returns (address);\n}\n"
      },
      "contracts/bridge/interfaces/IL1ERC20Bridge.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {IL1Nullifier} from \"./IL1Nullifier.sol\";\nimport {IL1NativeTokenVault} from \"../ntv/IL1NativeTokenVault.sol\";\nimport {IL1AssetRouter} from \"../asset-router/IL1AssetRouter.sol\";\n\n/// @title L1 Bridge contract legacy interface\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Legacy Bridge interface before ZK chain migration, used for backward compatibility with ZKsync Era\ninterface IL1ERC20Bridge {\n    event DepositInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);\n\n    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);\n\n    function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function L1_NULLIFIER() external view returns (IL1Nullifier);\n\n    function L1_ASSET_ROUTER() external view returns (IL1AssetRouter);\n\n    function L1_NATIVE_TOKEN_VAULT() external view returns (IL1NativeTokenVault);\n\n    function l2TokenBeacon() external view returns (address);\n\n    function l2Bridge() external view returns (address);\n\n    function depositAmount(\n        address _account,\n        address _l1Token,\n        bytes32 _depositL2TxHash\n    ) external view returns (uint256 amount);\n}\n"
      },
      "contracts/bridge/interfaces/IL1Nullifier.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IBridgehub} from \"../../bridgehub/IBridgehub.sol\";\nimport {IL1NativeTokenVault} from \"../ntv/IL1NativeTokenVault.sol\";\nimport {IL1ERC20Bridge} from \"./IL1ERC20Bridge.sol\";\n\n/// @param chainId The chain ID of the transaction to check.\n/// @param l2BatchNumber The L2 batch number where the withdrawal was processed.\n/// @param l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message.\n/// @param l2sender The address of the message sender on L2 (base token system contract address or asset handler)\n/// @param l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent.\n/// @param message The L2 withdraw data, stored in an L2 -> L1 message.\n/// @param merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization.\nstruct FinalizeL1DepositParams {\n    uint256 chainId;\n    uint256 l2BatchNumber;\n    uint256 l2MessageIndex;\n    address l2Sender;\n    uint16 l2TxNumberInBatch;\n    bytes message;\n    bytes32[] merkleProof;\n}\n\n/// @title L1 Bridge contract interface\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IL1Nullifier {\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeDeposit(FinalizeL1DepositParams calldata _finalizeWithdrawalParams) external;\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function legacyBridge() external view returns (IL1ERC20Bridge);\n\n    function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);\n\n    function bridgehubConfirmL2TransactionForwarded(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function l1NativeTokenVault() external view returns (IL1NativeTokenVault);\n\n    function setL1NativeTokenVault(IL1NativeTokenVault _nativeTokenVault) external;\n\n    function setL1AssetRouter(address _l1AssetRouter) external;\n\n    function chainBalance(uint256 _chainId, address _token) external view returns (uint256);\n\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n\n    function transferTokenToNTV(address _token) external;\n\n    function nullifyChainBalanceByNTV(uint256 _chainId, address _token) external;\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2.\n    /// @param _chainId The ZK chain id to which deposit was initiated.\n    /// @param _depositSender The address of the entity that initiated the deposit.\n    /// @param _assetId The unique identifier of the deposited L1 token.\n    /// @param _assetData The encoded transfer data, which includes both the deposit amount and the address of the L2 receiver. Might include extra information.\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization.\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed.\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message.\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent.\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization.\n    /// @dev Processes claims of failed deposit, whether they originated from the legacy bridge or the current system.\n    function bridgeRecoverFailedTransfer(\n        uint256 _chainId,\n        address _depositSender,\n        bytes32 _assetId,\n        bytes memory _assetData,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    /// @notice Legacy function to finalize withdrawal via the same\n    /// interface as the old L1SharedBridge.\n    /// @dev Note, that we need to keep this interface, since the `L2AssetRouter`\n    /// will continue returning the previous address as the `l1SharedBridge`. The value\n    /// returned by it is used in the SDK for finalizing withdrawals.\n    /// @param _chainId The chain ID of the transaction to check\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n}\n"
      },
      "contracts/bridge/interfaces/IL1SharedBridgeLegacy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\n/// @title L1 Bridge contract interface\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IL1SharedBridgeLegacy {\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n}\n"
      },
      "contracts/bridge/interfaces/IL2SharedBridgeLegacy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts-v4/proxy/beacon/UpgradeableBeacon.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IL2SharedBridgeLegacy {\n    event FinalizeDeposit(\n        address indexed l1Sender,\n        address indexed l2Receiver,\n        address indexed l2Token,\n        uint256 amount\n    );\n\n    function l2TokenBeacon() external returns (UpgradeableBeacon);\n\n    function withdraw(address _l1Receiver, address _l2Token, uint256 _amount) external;\n\n    function l1TokenAddress(address _l2Token) external view returns (address);\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function l1Bridge() external view returns (address);\n\n    function l1SharedBridge() external view returns (address);\n\n    function deployBeaconProxy(bytes32 _salt) external returns (address);\n\n    function sendMessageToL1(bytes calldata _message) external returns (bytes32);\n}\n"
      },
      "contracts/bridge/interfaces/IL2SharedBridgeLegacyFunctions.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.20;\n\n/// @author Matter Labs\ninterface IL2SharedBridgeLegacyFunctions {\n    event FinalizeDeposit(\n        address indexed l1Sender,\n        address indexed l2Receiver,\n        address indexed l2Token,\n        uint256 amount\n    );\n\n    event WithdrawalInitiated(\n        address indexed l2Sender,\n        address indexed l1Receiver,\n        address indexed l2Token,\n        uint256 amount\n    );\n\n    function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n}\n"
      },
      "contracts/bridge/interfaces/IL2WrappedBaseToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.20;\n\ninterface IL2WrappedBaseToken {\n    event Initialize(string name, string symbol, uint8 decimals);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 _amount) external;\n\n    function depositTo(address _to) external payable;\n\n    function withdrawTo(address _to, uint256 _amount) external;\n}\n"
      },
      "contracts/bridge/interfaces/IWETH9.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n"
      },
      "contracts/bridge/ntv/IL1NativeTokenVault.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IL1Nullifier} from \"../interfaces/IL1Nullifier.sol\";\nimport {INativeTokenVault} from \"./INativeTokenVault.sol\";\nimport {IL1AssetDeploymentTracker} from \"../interfaces/IL1AssetDeploymentTracker.sol\";\n\n/// @title L1 Native token vault contract interface\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The NTV is an Asset Handler for the L1AssetRouter to handle native tokens\n// is IL1AssetHandler, IL1BaseTokenAssetHandler {\ninterface IL1NativeTokenVault is INativeTokenVault, IL1AssetDeploymentTracker {\n    /// @notice The L1Nullifier contract\n    function L1_NULLIFIER() external view returns (IL1Nullifier);\n\n    /// @notice Returns the total number of specific tokens locked for some chain\n    function chainBalance(uint256 _chainId, bytes32 _assetId) external view returns (uint256);\n\n    /// @notice Registers ETH token\n    function registerEthToken() external;\n\n    event TokenBeaconUpdated(address indexed l2TokenBeacon);\n}\n"
      },
      "contracts/bridge/ntv/IL2NativeTokenVault.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {INativeTokenVault} from \"./INativeTokenVault.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IL2NativeTokenVault is INativeTokenVault {\n    event FinalizeDeposit(\n        address indexed l1Sender,\n        address indexed l2Receiver,\n        address indexed l2Token,\n        uint256 amount\n    );\n\n    event WithdrawalInitiated(\n        address indexed l2Sender,\n        address indexed l1Receiver,\n        address indexed l2Token,\n        uint256 amount\n    );\n\n    event L2TokenBeaconUpdated(address indexed l2TokenBeacon, bytes32 indexed l2TokenProxyBytecodeHash);\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n}\n"
      },
      "contracts/bridge/ntv/INativeTokenVault.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IAssetRouterBase} from \"../asset-router/IAssetRouterBase.sol\";\n\n/// @title Base Native token vault contract interface\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The NTV is an Asset Handler for the L1AssetRouter to handle native tokens\ninterface INativeTokenVault {\n    event BridgedTokenBeaconUpdated(address bridgedTokenBeacon, bytes32 bridgedTokenProxyBytecodeHash);\n\n    /// @notice The Weth token address\n    function WETH_TOKEN() external view returns (address);\n\n    /// @notice The AssetRouter contract\n    function ASSET_ROUTER() external view returns (IAssetRouterBase);\n\n    /// @notice The chain ID of the L1 chain\n    function L1_CHAIN_ID() external view returns (uint256);\n\n    /// @notice Returns the chain ID of the origin chain for a given asset ID\n    function originChainId(bytes32 assetId) external view returns (uint256);\n\n    /// @notice Registers tokens within the NTV.\n    /// @dev The goal is to allow bridging native tokens automatically, by registering them on the fly.\n    /// @notice Allows the bridge to register a token address for the vault.\n    /// @notice No access control is ok, since the bridging of tokens should be permissionless. This requires permissionless registration.\n    function registerToken(address _l1Token) external;\n\n    /// @notice Ensures that the native token is registered with the NTV.\n    /// @dev This function is used to ensure that the token is registered with the NTV.\n    function ensureTokenIsRegistered(address _nativeToken) external;\n\n    /// @notice Used to get the the ERC20 data for a token\n    function getERC20Getters(address _token, uint256 _originChainId) external view returns (bytes memory);\n\n    /// @notice Used to get the token address of an assetId\n    function tokenAddress(bytes32 assetId) external view returns (address);\n\n    /// @notice Used to get the assetId of a token\n    function assetId(address token) external view returns (bytes32);\n\n    /// @notice Used to get the expected bridged token address corresponding to its native counterpart\n    function calculateCreate2TokenAddress(uint256 _originChainId, address _originToken) external view returns (address);\n\n    /// @notice Tries to register a token from the provided `_burnData` and reverts if it is not possible.\n    function tryRegisterTokenFromBurnData(bytes calldata _burnData, bytes32 _expectedAssetId) external;\n}\n"
      },
      "contracts/bridge/ntv/L1NativeTokenVault.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {BeaconProxy} from \"@openzeppelin/contracts-v4/proxy/beacon/BeaconProxy.sol\";\nimport {IBeacon} from \"@openzeppelin/contracts-v4/proxy/beacon/IBeacon.sol\";\nimport {Create2} from \"@openzeppelin/contracts-v4/utils/Create2.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts-v4/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts-v4/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IL1NativeTokenVault} from \"./IL1NativeTokenVault.sol\";\nimport {INativeTokenVault} from \"./INativeTokenVault.sol\";\nimport {NativeTokenVault} from \"./NativeTokenVault.sol\";\n\nimport {IL1AssetHandler} from \"../interfaces/IL1AssetHandler.sol\";\nimport {IL1Nullifier} from \"../interfaces/IL1Nullifier.sol\";\nimport {IBridgedStandardToken} from \"../interfaces/IBridgedStandardToken.sol\";\nimport {IL1AssetRouter} from \"../asset-router/IL1AssetRouter.sol\";\n\nimport {ETH_TOKEN_ADDRESS} from \"../../common/Config.sol\";\nimport {L2_NATIVE_TOKEN_VAULT_ADDR} from \"../../common/L2ContractAddresses.sol\";\nimport {DataEncoding} from \"../../common/libraries/DataEncoding.sol\";\n\nimport {OriginChainIdNotFound, Unauthorized, ZeroAddress, NoFundsTransferred, InsufficientChainBalance, WithdrawFailed} from \"../../common/L1ContractErrors.sol\";\nimport {ClaimFailedDepositFailed, ZeroAmountToTransfer, WrongAmountTransferred, WrongCounterpart} from \"../L1BridgeContractErrors.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev Vault holding L1 native ETH and ERC20 tokens bridged into the ZK chains.\n/// @dev Designed for use with a proxy for upgradability.\ncontract L1NativeTokenVault is IL1NativeTokenVault, IL1AssetHandler, NativeTokenVault {\n    using SafeERC20 for IERC20;\n\n    /// @dev L1 nullifier contract that handles legacy functions & finalize withdrawal, confirm l2 tx mappings\n    IL1Nullifier public immutable override L1_NULLIFIER;\n\n    /// @dev Maps token balances for each chain to prevent unauthorized spending across ZK chains.\n    /// This serves as a security measure until hyperbridging is implemented.\n    /// NOTE: this function may be removed in the future, don't rely on it!\n    mapping(uint256 chainId => mapping(bytes32 assetId => uint256 balance)) public chainBalance;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    /// @param _l1WethAddress Address of WETH on deployed chain\n    /// @param _l1AssetRouter Address of Asset Router on L1.\n    /// @param _l1Nullifier Address of the nullifier contract, which handles transaction progress between L1 and ZK chains.\n    constructor(\n        address _l1WethAddress,\n        address _l1AssetRouter,\n        IL1Nullifier _l1Nullifier\n    )\n        NativeTokenVault(\n            _l1WethAddress,\n            _l1AssetRouter,\n            DataEncoding.encodeNTVAssetId(block.chainid, ETH_TOKEN_ADDRESS),\n            block.chainid\n        )\n    {\n        L1_NULLIFIER = _l1Nullifier;\n    }\n\n    /// @dev Accepts ether only from the contract that was the shared Bridge.\n    receive() external payable {\n        if (address(L1_NULLIFIER) != msg.sender) {\n            revert Unauthorized(msg.sender);\n        }\n    }\n\n    /// @dev Initializes a contract for later use. Expected to be used in the proxy\n    /// @param _owner Address which can change pause / unpause the NTV\n    /// implementation. The owner is the Governor and separate from the ProxyAdmin from now on, so that the Governor can call the bridge.\n    function initialize(address _owner, address _bridgedTokenBeacon) external initializer {\n        if (_owner == address(0)) {\n            revert ZeroAddress();\n        }\n        bridgedTokenBeacon = IBeacon(_bridgedTokenBeacon);\n        _transferOwnership(_owner);\n    }\n\n    /// @inheritdoc IL1NativeTokenVault\n    function registerEthToken() external {\n        _unsafeRegisterNativeToken(ETH_TOKEN_ADDRESS);\n    }\n\n    /// @notice Transfers tokens from shared bridge as part of the migration process.\n    /// The shared bridge becomes the L1Nullifier contract.\n    /// @dev Both ETH and ERC20 tokens can be transferred. Exhausts balance of shared bridge after the first call.\n    /// @dev Calling second time for the same token will revert.\n    /// @param _token The address of token to be transferred (address(1) for ether and contract address for ERC20).\n    function transferFundsFromSharedBridge(address _token) external {\n        ensureTokenIsRegistered(_token);\n        if (_token == ETH_TOKEN_ADDRESS) {\n            uint256 balanceBefore = address(this).balance;\n            L1_NULLIFIER.transferTokenToNTV(_token);\n            uint256 balanceAfter = address(this).balance;\n            if (balanceAfter <= balanceBefore) {\n                revert NoFundsTransferred();\n            }\n        } else {\n            uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\n            uint256 nullifierChainBalance = IERC20(_token).balanceOf(address(L1_NULLIFIER));\n            if (nullifierChainBalance == 0) {\n                revert ZeroAmountToTransfer();\n            }\n            L1_NULLIFIER.transferTokenToNTV(_token);\n            uint256 balanceAfter = IERC20(_token).balanceOf(address(this));\n            if (balanceAfter - balanceBefore < nullifierChainBalance) {\n                revert WrongAmountTransferred(balanceAfter - balanceBefore, nullifierChainBalance);\n            }\n        }\n    }\n\n    /// @notice Updates chain token balance within NTV to account for tokens transferred from the shared bridge (part of the migration process).\n    /// @dev Clears chain balance on the shared bridge after the first call. Subsequent calls will not affect the state.\n    /// @param _token The address of token to be transferred (address(1) for ether and contract address for ERC20).\n    /// @param _targetChainId The chain ID of the corresponding ZK chain.\n    function updateChainBalancesFromSharedBridge(address _token, uint256 _targetChainId) external {\n        uint256 nullifierChainBalance = L1_NULLIFIER.chainBalance(_targetChainId, _token);\n        bytes32 assetId = DataEncoding.encodeNTVAssetId(block.chainid, _token);\n        chainBalance[_targetChainId][assetId] = chainBalance[_targetChainId][assetId] + nullifierChainBalance;\n        originChainId[assetId] = block.chainid;\n        L1_NULLIFIER.nullifyChainBalanceByNTV(_targetChainId, _token);\n    }\n\n    /// @notice Used to register the Asset Handler asset in L2 AssetRouter.\n    /// @param _assetHandlerAddressOnCounterpart the address of the asset handler on the counterpart chain.\n    function bridgeCheckCounterpartAddress(\n        uint256,\n        bytes32,\n        address,\n        address _assetHandlerAddressOnCounterpart\n    ) external view override onlyAssetRouter {\n        if (_assetHandlerAddressOnCounterpart != L2_NATIVE_TOKEN_VAULT_ADDR) {\n            revert WrongCounterpart();\n        }\n    }\n\n    function _getOriginChainId(bytes32 _assetId) internal view returns (uint256) {\n        uint256 chainId = originChainId[_assetId];\n        if (chainId != 0) {\n            return chainId;\n        } else {\n            address token = tokenAddress[_assetId];\n            if (token == ETH_TOKEN_ADDRESS) {\n                return block.chainid;\n            } else if (IERC20(token).balanceOf(address(this)) > 0) {\n                return block.chainid;\n            } else if (IERC20(token).balanceOf(address(L1_NULLIFIER)) > 0) {\n                return block.chainid;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Start transaction Functions\n    //////////////////////////////////////////////////////////////*/\n\n    function _bridgeBurnNativeToken(\n        uint256 _chainId,\n        bytes32 _assetId,\n        address _originalCaller,\n        // solhint-disable-next-line no-unused-vars\n        bool _depositChecked,\n        uint256 _depositAmount,\n        address _receiver,\n        address _nativeToken\n    ) internal override returns (bytes memory _bridgeMintData) {\n        bool depositChecked = IL1AssetRouter(address(ASSET_ROUTER)).transferFundsToNTV(\n            _assetId,\n            _depositAmount,\n            _originalCaller\n        );\n        _bridgeMintData = super._bridgeBurnNativeToken({\n            _chainId: _chainId,\n            _assetId: _assetId,\n            _originalCaller: _originalCaller,\n            _depositChecked: depositChecked,\n            _depositAmount: _depositAmount,\n            _receiver: _receiver,\n            _nativeToken: _nativeToken\n        });\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            L1 SPECIFIC FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    ///  @inheritdoc IL1AssetHandler\n    function bridgeRecoverFailedTransfer(\n        uint256 _chainId,\n        bytes32 _assetId,\n        address _depositSender,\n        bytes calldata _data\n    ) external payable override requireZeroValue(msg.value) onlyAssetRouter whenNotPaused {\n        // slither-disable-next-line unused-return\n        (uint256 _amount, , ) = DataEncoding.decodeBridgeBurnData(_data);\n        address l1Token = tokenAddress[_assetId];\n        if (_amount == 0) {\n            revert NoFundsTransferred();\n        }\n\n        _handleChainBalanceDecrease(_chainId, _assetId, _amount, false);\n\n        if (l1Token == ETH_TOKEN_ADDRESS) {\n            bool callSuccess;\n            // Low-level assembly call, to avoid any memory copying (save gas)\n            assembly {\n                callSuccess := call(gas(), _depositSender, _amount, 0, 0, 0, 0)\n            }\n            if (!callSuccess) {\n                revert ClaimFailedDepositFailed();\n            }\n        } else {\n            uint256 originChainId = _getOriginChainId(_assetId);\n            if (originChainId == block.chainid) {\n                IERC20(l1Token).safeTransfer(_depositSender, _amount);\n            } else if (originChainId != 0) {\n                IBridgedStandardToken(l1Token).bridgeMint(_depositSender, _amount);\n            } else {\n                revert OriginChainIdNotFound();\n            }\n            // Note we don't allow weth deposits anymore, but there might be legacy weth deposits.\n            // until we add Weth bridging capabilities, we don't wrap/unwrap weth to ether.\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INTERNAL & HELPER FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function _registerTokenIfBridgedLegacy(address) internal override returns (bytes32) {\n        // There are no legacy tokens present on L1.\n        return bytes32(0);\n    }\n\n    // get the computed address before the contract DeployWithCreate2 deployed using Bytecode of contract DeployWithCreate2 and salt specified by the sender\n    function calculateCreate2TokenAddress(\n        uint256 _originChainId,\n        address _nonNativeToken\n    ) public view override(INativeTokenVault, NativeTokenVault) returns (address) {\n        bytes32 salt = _getCreate2Salt(_originChainId, _nonNativeToken);\n        return\n            Create2.computeAddress(\n                salt,\n                keccak256(abi.encodePacked(type(BeaconProxy).creationCode, abi.encode(bridgedTokenBeacon, \"\")))\n            );\n    }\n\n    function _withdrawFunds(bytes32 _assetId, address _to, address _token, uint256 _amount) internal override {\n        if (_assetId == BASE_TOKEN_ASSET_ID) {\n            bool callSuccess;\n            // Low-level assembly call, to avoid any memory copying (save gas)\n            assembly {\n                callSuccess := call(gas(), _to, _amount, 0, 0, 0, 0)\n            }\n            if (!callSuccess) {\n                revert WithdrawFailed();\n            }\n        } else {\n            // Withdraw funds\n            IERC20(_token).safeTransfer(_to, _amount);\n        }\n    }\n\n    function _deployBeaconProxy(bytes32 _salt, uint256) internal override returns (BeaconProxy proxy) {\n        // Use CREATE2 to deploy the BeaconProxy\n        address proxyAddress = Create2.deploy(\n            0,\n            _salt,\n            abi.encodePacked(type(BeaconProxy).creationCode, abi.encode(bridgedTokenBeacon, \"\"))\n        );\n        return BeaconProxy(payable(proxyAddress));\n    }\n\n    function _handleChainBalanceIncrease(\n        uint256 _chainId,\n        bytes32 _assetId,\n        uint256 _amount,\n        bool _isNative\n    ) internal override {\n        // Note, that we do not update balances for chains where the assetId comes from,\n        // since these chains can mint new instances of the token.\n        if (!_hasInfiniteBalance(_isNative, _assetId, _chainId)) {\n            chainBalance[_chainId][_assetId] += _amount;\n        }\n    }\n\n    function _handleChainBalanceDecrease(\n        uint256 _chainId,\n        bytes32 _assetId,\n        uint256 _amount,\n        bool _isNative\n    ) internal override {\n        // Note, that we do not update balances for chains where the assetId comes from,\n        // since these chains can mint new instances of the token.\n        if (!_hasInfiniteBalance(_isNative, _assetId, _chainId)) {\n            // Check that the chain has sufficient balance\n            if (chainBalance[_chainId][_assetId] < _amount) {\n                revert InsufficientChainBalance();\n            }\n            chainBalance[_chainId][_assetId] -= _amount;\n        }\n    }\n\n    /// @dev Returns whether a chain `_chainId` has infinite balance for an asset `_assetId`, i.e.\n    /// it can be minted by it.\n    /// @param _isNative Whether the asset is native to the L1 chain.\n    /// @param _assetId The asset id\n    /// @param _chainId An id of a chain which we test against.\n    /// @return Whether The chain `_chainId` has infinite balance of the token\n    function _hasInfiniteBalance(bool _isNative, bytes32 _assetId, uint256 _chainId) private view returns (bool) {\n        return !_isNative && originChainId[_assetId] == _chainId;\n    }\n}\n"
      },
      "contracts/bridge/ntv/L2NativeTokenVault.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {BeaconProxy} from \"@openzeppelin/contracts-v4/proxy/beacon/BeaconProxy.sol\";\nimport {IBeacon} from \"@openzeppelin/contracts-v4/proxy/beacon/IBeacon.sol\";\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts-v4/proxy/beacon/UpgradeableBeacon.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts-v4/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts-v4/token/ERC20/utils/SafeERC20.sol\";\n\nimport {INativeTokenVault} from \"./INativeTokenVault.sol\";\nimport {IL2NativeTokenVault} from \"./IL2NativeTokenVault.sol\";\nimport {NativeTokenVault} from \"./NativeTokenVault.sol\";\n\nimport {IL2SharedBridgeLegacy} from \"../interfaces/IL2SharedBridgeLegacy.sol\";\nimport {BridgedStandardERC20} from \"../BridgedStandardERC20.sol\";\nimport {IL2AssetRouter} from \"../asset-router/IL2AssetRouter.sol\";\n\nimport {L2_DEPLOYER_SYSTEM_CONTRACT_ADDR, L2_ASSET_ROUTER_ADDR} from \"../../common/L2ContractAddresses.sol\";\nimport {L2ContractHelper, IContractDeployer} from \"../../common/libraries/L2ContractHelper.sol\";\n\nimport {SystemContractsCaller} from \"../../common/libraries/SystemContractsCaller.sol\";\nimport {DataEncoding} from \"../../common/libraries/DataEncoding.sol\";\n\nimport {AssetIdAlreadyRegistered, NoLegacySharedBridge, TokenIsLegacy, TokenIsNotLegacy, EmptyAddress, EmptyBytes32, AddressMismatch, DeployFailed, AssetIdNotSupported} from \"../../common/L1ContractErrors.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The \"default\" bridge implementation for the ERC20 tokens. Note, that it does not\n/// support any custom token logic, i.e. rebase tokens' functionality is not supported.\ncontract L2NativeTokenVault is IL2NativeTokenVault, NativeTokenVault {\n    using SafeERC20 for IERC20;\n\n    IL2SharedBridgeLegacy public immutable L2_LEGACY_SHARED_BRIDGE;\n\n    /// @dev Bytecode hash of the proxy for tokens deployed by the bridge.\n    bytes32 internal immutable L2_TOKEN_PROXY_BYTECODE_HASH;\n\n    /// @notice Initializes the bridge contract for later use.\n    /// @dev this contract is deployed in the L2GenesisUpgrade, and is meant as direct deployment without a proxy.\n    /// @param _l1ChainId The L1 chain id differs between mainnet and testnets.\n    /// @param _l2TokenProxyBytecodeHash The bytecode hash of the proxy for tokens deployed by the bridge.\n    /// @param _aliasedOwner The address of the governor contract.\n    /// @param _legacySharedBridge The address of the L2 legacy shared bridge.\n    /// @param _bridgedTokenBeacon The address of the L2 token beacon for legacy chains.\n    /// @param _contractsDeployedAlready Ensures beacon proxy for standard ERC20 has not been deployed.\n    /// @param _wethToken Address of WETH on deployed chain\n    constructor(\n        uint256 _l1ChainId,\n        address _aliasedOwner,\n        bytes32 _l2TokenProxyBytecodeHash,\n        address _legacySharedBridge,\n        address _bridgedTokenBeacon,\n        bool _contractsDeployedAlready,\n        address _wethToken,\n        bytes32 _baseTokenAssetId\n    ) NativeTokenVault(_wethToken, L2_ASSET_ROUTER_ADDR, _baseTokenAssetId, _l1ChainId) {\n        L2_LEGACY_SHARED_BRIDGE = IL2SharedBridgeLegacy(_legacySharedBridge);\n\n        if (_l2TokenProxyBytecodeHash == bytes32(0)) {\n            revert EmptyBytes32();\n        }\n        if (_aliasedOwner == address(0)) {\n            revert EmptyAddress();\n        }\n\n        L2_TOKEN_PROXY_BYTECODE_HASH = _l2TokenProxyBytecodeHash;\n        _transferOwnership(_aliasedOwner);\n\n        if (_contractsDeployedAlready) {\n            if (_bridgedTokenBeacon == address(0)) {\n                revert EmptyAddress();\n            }\n            bridgedTokenBeacon = IBeacon(_bridgedTokenBeacon);\n        } else {\n            address l2StandardToken = address(new BridgedStandardERC20{salt: bytes32(0)}());\n\n            UpgradeableBeacon tokenBeacon = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n\n            tokenBeacon.transferOwnership(owner());\n            bridgedTokenBeacon = IBeacon(address(tokenBeacon));\n            emit L2TokenBeaconUpdated(address(bridgedTokenBeacon), _l2TokenProxyBytecodeHash);\n        }\n    }\n\n    function _registerTokenIfBridgedLegacy(address _tokenAddress) internal override returns (bytes32) {\n        // In zkEVM immutables are stored in a storage of a system contract,\n        // so it makes sense to cache them for efficiency.\n        IL2SharedBridgeLegacy legacyBridge = L2_LEGACY_SHARED_BRIDGE;\n        if (address(legacyBridge) == address(0)) {\n            // No legacy bridge, the token must be native\n            return bytes32(0);\n        }\n\n        address l1TokenAddress = legacyBridge.l1TokenAddress(_tokenAddress);\n        if (l1TokenAddress == address(0)) {\n            // The token is not legacy\n            return bytes32(0);\n        }\n\n        return _registerLegacyTokenAssetId(_tokenAddress, l1TokenAddress);\n    }\n\n    /// @notice Sets the legacy token asset ID for the given L2 token address.\n    function setLegacyTokenAssetId(address _l2TokenAddress) public {\n        if (assetId[_l2TokenAddress] != bytes32(0)) {\n            revert AssetIdAlreadyRegistered();\n        }\n        if (address(L2_LEGACY_SHARED_BRIDGE) == address(0)) {\n            revert NoLegacySharedBridge();\n        }\n        address l1TokenAddress = L2_LEGACY_SHARED_BRIDGE.l1TokenAddress(_l2TokenAddress);\n        if (l1TokenAddress == address(0)) {\n            revert TokenIsNotLegacy();\n        }\n\n        _registerLegacyTokenAssetId(_l2TokenAddress, l1TokenAddress);\n    }\n\n    function _registerLegacyTokenAssetId(\n        address _l2TokenAddress,\n        address _l1TokenAddress\n    ) internal returns (bytes32 newAssetId) {\n        newAssetId = DataEncoding.encodeNTVAssetId(L1_CHAIN_ID, _l1TokenAddress);\n        IL2AssetRouter(L2_ASSET_ROUTER_ADDR).setLegacyTokenAssetHandler(newAssetId);\n        tokenAddress[newAssetId] = _l2TokenAddress;\n        assetId[_l2TokenAddress] = newAssetId;\n        originChainId[newAssetId] = L1_CHAIN_ID;\n    }\n\n    /// @notice Ensures that the token is deployed.\n    /// @param _assetId The asset ID.\n    /// @param _originToken The origin token address.\n    /// @param _erc20Data The ERC20 data.\n    /// @return expectedToken The token address.\n    function _ensureAndSaveTokenDeployed(\n        bytes32 _assetId,\n        address _originToken,\n        bytes memory _erc20Data\n    ) internal override returns (address expectedToken) {\n        uint256 tokenOriginChainId;\n        (expectedToken, tokenOriginChainId) = _calculateExpectedTokenAddress(_originToken, _erc20Data);\n        address l1LegacyToken;\n        if (address(L2_LEGACY_SHARED_BRIDGE) != address(0)) {\n            l1LegacyToken = L2_LEGACY_SHARED_BRIDGE.l1TokenAddress(expectedToken);\n        }\n\n        if (l1LegacyToken != address(0)) {\n            _ensureAndSaveTokenDeployedInnerLegacyToken({\n                _assetId: _assetId,\n                _originToken: _originToken,\n                _expectedToken: expectedToken,\n                _l1LegacyToken: l1LegacyToken\n            });\n        } else {\n            super._ensureAndSaveTokenDeployedInner({\n                _tokenOriginChainId: tokenOriginChainId,\n                _assetId: _assetId,\n                _originToken: _originToken,\n                _erc20Data: _erc20Data,\n                _expectedToken: expectedToken\n            });\n        }\n    }\n\n    /// @notice Ensures that the token is deployed inner for legacy tokens.\n    function _ensureAndSaveTokenDeployedInnerLegacyToken(\n        bytes32 _assetId,\n        address _originToken,\n        address _expectedToken,\n        address _l1LegacyToken\n    ) internal {\n        _assetIdCheck(L1_CHAIN_ID, _assetId, _originToken);\n\n        /// token is a legacy token, no need to deploy\n        if (_l1LegacyToken != _originToken) {\n            revert AddressMismatch(_originToken, _l1LegacyToken);\n        }\n\n        tokenAddress[_assetId] = _expectedToken;\n        assetId[_expectedToken] = _assetId;\n    }\n\n    /// @notice Deploys the beacon proxy for the L2 token, while using ContractDeployer system contract.\n    /// @dev This function uses raw call to ContractDeployer to make sure that exactly `L2_TOKEN_PROXY_BYTECODE_HASH` is used\n    /// for the code of the proxy.\n    /// @param _salt The salt used for beacon proxy deployment of L2 bridged token.\n    /// @param _tokenOriginChainId The origin chain id of the token.\n    /// @return proxy The beacon proxy, i.e. L2 bridged token.\n    function _deployBeaconProxy(\n        bytes32 _salt,\n        uint256 _tokenOriginChainId\n    ) internal virtual override returns (BeaconProxy proxy) {\n        if (address(L2_LEGACY_SHARED_BRIDGE) == address(0) || _tokenOriginChainId != L1_CHAIN_ID) {\n            // Deploy the beacon proxy for the L2 token\n\n            (bool success, bytes memory returndata) = SystemContractsCaller.systemCallWithReturndata(\n                uint32(gasleft()),\n                L2_DEPLOYER_SYSTEM_CONTRACT_ADDR,\n                0,\n                abi.encodeCall(\n                    IContractDeployer.create2,\n                    (_salt, L2_TOKEN_PROXY_BYTECODE_HASH, abi.encode(address(bridgedTokenBeacon), \"\"))\n                )\n            );\n\n            // The deployment should be successful and return the address of the proxy\n            if (!success) {\n                revert DeployFailed();\n            }\n            proxy = BeaconProxy(abi.decode(returndata, (address)));\n        } else {\n            // Deploy the beacon proxy for the L2 token\n            address l2TokenAddr = L2_LEGACY_SHARED_BRIDGE.deployBeaconProxy(_salt);\n            proxy = BeaconProxy(payable(l2TokenAddr));\n        }\n    }\n\n    function _withdrawFunds(bytes32 _assetId, address _to, address _token, uint256 _amount) internal override {\n        if (_assetId == BASE_TOKEN_ASSET_ID) {\n            revert AssetIdNotSupported(BASE_TOKEN_ASSET_ID);\n        } else {\n            // Withdraw funds\n            IERC20(_token).safeTransfer(_to, _amount);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INTERNAL & HELPER FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Calculates L2 wrapped token address given the currently stored beacon proxy bytecode hash and beacon address.\n    /// @param _tokenOriginChainId The chain id of the origin token.\n    /// @param _nonNativeToken The address of token on its origin chain..\n    /// @return Address of an L2 token counterpart.\n    function calculateCreate2TokenAddress(\n        uint256 _tokenOriginChainId,\n        address _nonNativeToken\n    ) public view virtual override(INativeTokenVault, NativeTokenVault) returns (address) {\n        if (address(L2_LEGACY_SHARED_BRIDGE) != address(0) && _tokenOriginChainId == L1_CHAIN_ID) {\n            return L2_LEGACY_SHARED_BRIDGE.l2TokenAddress(_nonNativeToken);\n        } else {\n            bytes32 constructorInputHash = keccak256(abi.encode(address(bridgedTokenBeacon), \"\"));\n            bytes32 salt = _getCreate2Salt(_tokenOriginChainId, _nonNativeToken);\n            return\n                L2ContractHelper.computeCreate2Address(\n                    address(this),\n                    salt,\n                    L2_TOKEN_PROXY_BYTECODE_HASH,\n                    constructorInputHash\n                );\n        }\n    }\n\n    /// @notice Calculates the salt for the Create2 deployment of the L2 token.\n    function _getCreate2Salt(\n        uint256 _tokenOriginChainId,\n        address _l1Token\n    ) internal view override returns (bytes32 salt) {\n        salt = _tokenOriginChainId == L1_CHAIN_ID\n            ? bytes32(uint256(uint160(_l1Token)))\n            : keccak256(abi.encode(_tokenOriginChainId, _l1Token));\n    }\n\n    function _handleChainBalanceIncrease(\n        uint256 _chainId,\n        bytes32 _assetId,\n        uint256 _amount,\n        bool _isNative\n    ) internal override {\n        // on L2s we don't track the balance\n    }\n\n    function _handleChainBalanceDecrease(\n        uint256 _chainId,\n        bytes32 _assetId,\n        uint256 _amount,\n        bool _isNative\n    ) internal override {\n        // on L2s we don't track the balance\n    }\n\n    function _registerToken(address _nativeToken) internal override returns (bytes32) {\n        if (\n            address(L2_LEGACY_SHARED_BRIDGE) != address(0) &&\n            L2_LEGACY_SHARED_BRIDGE.l1TokenAddress(_nativeToken) != address(0)\n        ) {\n            // Legacy tokens should be registered via `setLegacyTokenAssetId`.\n            revert TokenIsLegacy();\n        }\n        return super._registerToken(_nativeToken);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            LEGACY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Calculates L2 wrapped token address corresponding to L1 token counterpart.\n    /// @param _l1Token The address of token on L1.\n    /// @return expectedToken The address of token on L2.\n    function l2TokenAddress(address _l1Token) public view returns (address expectedToken) {\n        bytes32 expectedAssetId = DataEncoding.encodeNTVAssetId(L1_CHAIN_ID, _l1Token);\n        expectedToken = tokenAddress[expectedAssetId];\n    }\n}\n"
      },
      "contracts/bridge/ntv/NativeTokenVault.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Ownable2StepUpgradeable} from \"@openzeppelin/contracts-upgradeable-v4/access/Ownable2StepUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable-v4/security/PausableUpgradeable.sol\";\nimport {BeaconProxy} from \"@openzeppelin/contracts-v4/proxy/beacon/BeaconProxy.sol\";\nimport {IBeacon} from \"@openzeppelin/contracts-v4/proxy/beacon/IBeacon.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts-v4/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts-v4/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IBridgedStandardToken} from \"../interfaces/IBridgedStandardToken.sol\";\nimport {INativeTokenVault} from \"./INativeTokenVault.sol\";\nimport {IAssetHandler} from \"../interfaces/IAssetHandler.sol\";\nimport {IAssetRouterBase} from \"../asset-router/IAssetRouterBase.sol\";\nimport {DataEncoding} from \"../../common/libraries/DataEncoding.sol\";\n\nimport {BridgedStandardERC20} from \"../BridgedStandardERC20.sol\";\nimport {BridgeHelper} from \"../BridgeHelper.sol\";\n\nimport {EmptyToken} from \"../L1BridgeContractErrors.sol\";\nimport {BurningNativeWETHNotSupported, AssetIdAlreadyRegistered, EmptyDeposit, Unauthorized, TokensWithFeesNotSupported, TokenNotSupported, NonEmptyMsgValue, ValueMismatch, AddressMismatch, AssetIdMismatch, AmountMustBeGreaterThanZero, ZeroAddress, DeployingBridgedTokenForNativeToken} from \"../../common/L1ContractErrors.sol\";\nimport {AssetHandlerModifiers} from \"../interfaces/AssetHandlerModifiers.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev Vault holding L1 native ETH and ERC20 tokens bridged into the ZK chains.\n/// @dev Designed for use with a proxy for upgradability.\nabstract contract NativeTokenVault is\n    INativeTokenVault,\n    IAssetHandler,\n    Ownable2StepUpgradeable,\n    PausableUpgradeable,\n    AssetHandlerModifiers\n{\n    using SafeERC20 for IERC20;\n\n    /// @dev The address of the WETH token.\n    address public immutable override WETH_TOKEN;\n\n    /// @dev L1 Shared Bridge smart contract that handles communication with its counterparts on L2s\n    IAssetRouterBase public immutable override ASSET_ROUTER;\n\n    /// @dev The assetId of the base token.\n    bytes32 public immutable BASE_TOKEN_ASSET_ID;\n\n    /// @dev Chain ID of L1 for bridging reasons.\n    uint256 public immutable L1_CHAIN_ID;\n\n    /// @dev Contract that stores the implementation address for token.\n    /// @dev For more details see https://docs.openzeppelin.com/contracts/3.x/api/proxy#UpgradeableBeacon.\n    IBeacon public bridgedTokenBeacon;\n\n    /// @dev A mapping assetId => originChainId\n    mapping(bytes32 assetId => uint256 originChainId) public originChainId;\n\n    /// @dev A mapping assetId => tokenAddress\n    mapping(bytes32 assetId => address tokenAddress) public tokenAddress;\n\n    /// @dev A mapping tokenAddress => assetId\n    mapping(address tokenAddress => bytes32 assetId) public assetId;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n\n    /// @notice Checks that the message sender is the bridgehub.\n    modifier onlyAssetRouter() {\n        if (msg.sender != address(ASSET_ROUTER)) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Disable the initialization to prevent Parity hack.\n    /// @param _wethToken Address of WETH on deployed chain\n    /// @param _assetRouter Address of assetRouter\n    constructor(address _wethToken, address _assetRouter, bytes32 _baseTokenAssetId, uint256 _l1ChainId) {\n        _disableInitializers();\n        L1_CHAIN_ID = _l1ChainId;\n        ASSET_ROUTER = IAssetRouterBase(_assetRouter);\n        WETH_TOKEN = _wethToken;\n        BASE_TOKEN_ASSET_ID = _baseTokenAssetId;\n    }\n\n    /// @inheritdoc INativeTokenVault\n    function registerToken(address _nativeToken) external virtual {\n        _registerToken(_nativeToken);\n    }\n\n    function _registerToken(address _nativeToken) internal virtual returns (bytes32 newAssetId) {\n        // We allow registering `WETH_TOKEN` inside `NativeTokenVault` only for L1 native token vault.\n        // It is needed to allow withdrawing such assets. We restrict all WETH-related\n        // operations to deposits from L1 only to be able to upgrade their logic more easily in the\n        // future.\n        if (_nativeToken == WETH_TOKEN && block.chainid != L1_CHAIN_ID) {\n            revert TokenNotSupported(WETH_TOKEN);\n        }\n        if (_nativeToken.code.length == 0) {\n            revert EmptyToken();\n        }\n        if (assetId[_nativeToken] != bytes32(0)) {\n            revert AssetIdAlreadyRegistered();\n        }\n        newAssetId = _unsafeRegisterNativeToken(_nativeToken);\n    }\n\n    /// @inheritdoc INativeTokenVault\n    function ensureTokenIsRegistered(address _nativeToken) public {\n        if (assetId[_nativeToken] == bytes32(0)) {\n            _registerToken(_nativeToken);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            FINISH TRANSACTION FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IAssetHandler\n    /// @notice Used when the chain receives a transfer from L1 Shared Bridge and correspondingly mints the asset.\n    /// @param _chainId The chainId that the message is from.\n    /// @param _assetId The assetId of the asset being bridged.\n    /// @param _data The abi.encoded transfer data.\n    function bridgeMint(\n        uint256 _chainId,\n        bytes32 _assetId,\n        bytes calldata _data\n    ) external payable override requireZeroValue(msg.value) onlyAssetRouter whenNotPaused {\n        address receiver;\n        uint256 amount;\n        // we set all originChainId for all already bridged tokens with the setLegacyTokenAssetId and updateChainBalancesFromSharedBridge functions.\n        // for tokens that are bridged for the first time, the originChainId will be 0.\n        if (originChainId[_assetId] == block.chainid) {\n            (receiver, amount) = _bridgeMintNativeToken(_chainId, _assetId, _data);\n        } else {\n            (receiver, amount) = _bridgeMintBridgedToken(_chainId, _assetId, _data);\n        }\n        // solhint-disable-next-line func-named-parameters\n        emit BridgeMint(_chainId, _assetId, receiver, amount);\n    }\n\n    function _bridgeMintBridgedToken(\n        uint256 _chainId,\n        bytes32 _assetId,\n        bytes calldata _data\n    ) internal virtual returns (address receiver, uint256 amount) {\n        // Either it was bridged before, therefore address is not zero, or it is first time bridging and standard erc20 will be deployed\n        address token = tokenAddress[_assetId];\n        bytes memory erc20Data;\n        address originToken;\n        // slither-disable-next-line unused-return\n        (, receiver, originToken, amount, erc20Data) = DataEncoding.decodeBridgeMintData(_data);\n\n        if (token == address(0)) {\n            token = _ensureAndSaveTokenDeployed(_assetId, originToken, erc20Data);\n        }\n        _handleChainBalanceDecrease(_chainId, _assetId, amount, false);\n        IBridgedStandardToken(token).bridgeMint(receiver, amount);\n    }\n\n    function _bridgeMintNativeToken(\n        uint256 _chainId,\n        bytes32 _assetId,\n        bytes calldata _data\n    ) internal returns (address receiver, uint256 amount) {\n        address token = tokenAddress[_assetId];\n        // slither-disable-next-line unused-return\n        (, receiver, , amount, ) = DataEncoding.decodeBridgeMintData(_data);\n\n        _handleChainBalanceDecrease(_chainId, _assetId, amount, true);\n        _withdrawFunds(_assetId, receiver, token, amount);\n    }\n\n    function _withdrawFunds(bytes32 _assetId, address _to, address _token, uint256 _amount) internal virtual;\n\n    /*//////////////////////////////////////////////////////////////\n                            Start transaction Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IAssetHandler\n    /// @notice Allows bridgehub to acquire mintValue for L1->L2 transactions.\n    /// @dev In case of native token vault _data is the tuple of _depositAmount and _receiver.\n    function bridgeBurn(\n        uint256 _chainId,\n        uint256 _l2MsgValue,\n        bytes32 _assetId,\n        address _originalCaller,\n        bytes calldata _data\n    )\n        external\n        payable\n        override\n        requireZeroValue(_l2MsgValue)\n        onlyAssetRouter\n        whenNotPaused\n        returns (bytes memory _bridgeMintData)\n    {\n        (uint256 amount, address receiver, address tokenAddress) = _decodeBurnAndCheckAssetId(_data, _assetId);\n        if (originChainId[_assetId] != block.chainid) {\n            _bridgeMintData = _bridgeBurnBridgedToken({\n                _chainId: _chainId,\n                _assetId: _assetId,\n                _originalCaller: _originalCaller,\n                _amount: amount,\n                _receiver: receiver,\n                _tokenAddress: tokenAddress\n            });\n        } else {\n            _bridgeMintData = _bridgeBurnNativeToken({\n                _chainId: _chainId,\n                _assetId: _assetId,\n                _originalCaller: _originalCaller,\n                _depositChecked: false,\n                _depositAmount: amount,\n                _receiver: receiver,\n                _nativeToken: tokenAddress\n            });\n        }\n    }\n\n    function tryRegisterTokenFromBurnData(bytes calldata _burnData, bytes32 _expectedAssetId) external {\n        // slither-disable-next-line unused-return\n        (, , address tokenAddress) = DataEncoding.decodeBridgeBurnData(_burnData);\n\n        if (tokenAddress == address(0)) {\n            revert ZeroAddress();\n        }\n\n        bytes32 storedAssetId = assetId[tokenAddress];\n        if (storedAssetId != bytes32(0)) {\n            revert AssetIdAlreadyRegistered();\n        }\n\n        // This token has not been registered within this NTV yet. Usually this means that the\n        // token is native to the chain and the user would prefer to get it registered as such.\n        // However, there are exceptions (e.g. bridged legacy ERC20 tokens on L2) when the\n        // assetId has not been stored yet. We will ask the implementor to double check that the token\n        // is not legacy.\n\n        // We try to register it as legacy token. If it fails, we know\n        // it is a native one and so register it as a native token.\n        bytes32 newAssetId = _registerTokenIfBridgedLegacy(tokenAddress);\n        if (newAssetId == bytes32(0)) {\n            newAssetId = _registerToken(tokenAddress);\n        }\n\n        if (newAssetId != _expectedAssetId) {\n            revert AssetIdMismatch(_expectedAssetId, newAssetId);\n        }\n    }\n\n    function _decodeBurnAndCheckAssetId(\n        bytes calldata _data,\n        bytes32 _suppliedAssetId\n    ) internal returns (uint256 amount, address receiver, address parsedTokenAddress) {\n        (amount, receiver, parsedTokenAddress) = DataEncoding.decodeBridgeBurnData(_data);\n\n        if (parsedTokenAddress == address(0)) {\n            // This means that the user wants the native token vault to resolve the\n            // address. In this case, it is assumed that the assetId is already registered.\n            parsedTokenAddress = tokenAddress[_suppliedAssetId];\n        }\n\n        // If it is still zero, it means that the token has not been registered.\n        if (parsedTokenAddress == address(0)) {\n            revert ZeroAddress();\n        }\n\n        bytes32 storedAssetId = assetId[parsedTokenAddress];\n        if (_suppliedAssetId != storedAssetId) {\n            revert AssetIdMismatch(storedAssetId, _suppliedAssetId);\n        }\n    }\n\n    function _registerTokenIfBridgedLegacy(address _token) internal virtual returns (bytes32);\n\n    function _bridgeBurnBridgedToken(\n        uint256 _chainId,\n        bytes32 _assetId,\n        address _originalCaller,\n        uint256 _amount,\n        address _receiver,\n        address _tokenAddress\n    ) internal requireZeroValue(msg.value) returns (bytes memory _bridgeMintData) {\n        if (_amount == 0) {\n            // \"Amount cannot be zero\");\n            revert AmountMustBeGreaterThanZero();\n        }\n\n        IBridgedStandardToken(_tokenAddress).bridgeBurn(_originalCaller, _amount);\n        _handleChainBalanceIncrease(_chainId, _assetId, _amount, false);\n\n        emit BridgeBurn({\n            chainId: _chainId,\n            assetId: _assetId,\n            sender: _originalCaller,\n            receiver: _receiver,\n            amount: _amount\n        });\n        bytes memory erc20Metadata;\n        {\n            // we set all originChainId for all already bridged tokens with the setLegacyTokenAssetId and updateChainBalancesFromSharedBridge functions.\n            // for native tokens the originChainId is set when they register.\n            uint256 originChainId = originChainId[_assetId];\n            if (originChainId == 0) {\n                revert ZeroAddress();\n            }\n            erc20Metadata = getERC20Getters(_tokenAddress, originChainId);\n        }\n        address originToken;\n        {\n            originToken = IBridgedStandardToken(_tokenAddress).originToken();\n            if (originToken == address(0)) {\n                revert ZeroAddress();\n            }\n        }\n\n        _bridgeMintData = DataEncoding.encodeBridgeMintData({\n            _originalCaller: _originalCaller,\n            _remoteReceiver: _receiver,\n            _originToken: originToken,\n            _amount: _amount,\n            _erc20Metadata: erc20Metadata\n        });\n    }\n\n    function _bridgeBurnNativeToken(\n        uint256 _chainId,\n        bytes32 _assetId,\n        address _originalCaller,\n        bool _depositChecked,\n        uint256 _depositAmount,\n        address _receiver,\n        address _nativeToken\n    ) internal virtual returns (bytes memory _bridgeMintData) {\n        if (_nativeToken == WETH_TOKEN) {\n            // This ensures that WETH_TOKEN can never be bridged from chains it is native to.\n            // It can only be withdrawn from the chain where it has already gotten.\n            revert BurningNativeWETHNotSupported();\n        }\n\n        if (_assetId == BASE_TOKEN_ASSET_ID) {\n            if (_depositAmount != msg.value) {\n                revert ValueMismatch(_depositAmount, msg.value);\n            }\n\n            _handleChainBalanceIncrease(_chainId, _assetId, _depositAmount, true);\n        } else {\n            if (msg.value != 0) {\n                revert NonEmptyMsgValue();\n            }\n            _handleChainBalanceIncrease(_chainId, _assetId, _depositAmount, true);\n            if (!_depositChecked) {\n                uint256 expectedDepositAmount = _depositFunds(_originalCaller, IERC20(_nativeToken), _depositAmount); // note if _originalCaller is this contract, this will return 0. This does not happen.\n                // The token has non-standard transfer logic\n                if (_depositAmount != expectedDepositAmount) {\n                    revert TokensWithFeesNotSupported();\n                }\n            }\n        }\n        if (_depositAmount == 0) {\n            // empty deposit amount\n            revert EmptyDeposit();\n        }\n\n        bytes memory erc20Metadata;\n        {\n            erc20Metadata = getERC20Getters(_nativeToken, originChainId[_assetId]);\n        }\n        _bridgeMintData = DataEncoding.encodeBridgeMintData({\n            _originalCaller: _originalCaller,\n            _remoteReceiver: _receiver,\n            _originToken: _nativeToken,\n            _amount: _depositAmount,\n            _erc20Metadata: erc20Metadata\n        });\n\n        emit BridgeBurn({\n            chainId: _chainId,\n            assetId: _assetId,\n            sender: _originalCaller,\n            receiver: _receiver,\n            amount: _depositAmount\n        });\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INTERNAL & HELPER FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Transfers tokens from the depositor address to the smart contract address.\n    /// @param _from The address of the depositor.\n    /// @param _token The ERC20 token to be transferred.\n    /// @param _amount The amount to be transferred.\n    /// @return The difference between the contract balance before and after the transferring of funds.\n    function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal virtual returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        // slither-disable-next-line arbitrary-send-erc20\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @param _token The address of token of interest.\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function getERC20Getters(address _token, uint256 _originChainId) public view override returns (bytes memory) {\n        return BridgeHelper.getERC20Getters(_token, _originChainId);\n    }\n\n    /// @notice Registers a native token address for the vault.\n    /// @dev It does not perform any checks for the correctnesss of the token contract.\n    /// @param _nativeToken The address of the token to be registered.\n    function _unsafeRegisterNativeToken(address _nativeToken) internal returns (bytes32 newAssetId) {\n        newAssetId = DataEncoding.encodeNTVAssetId(block.chainid, _nativeToken);\n        tokenAddress[newAssetId] = _nativeToken;\n        assetId[_nativeToken] = newAssetId;\n        originChainId[newAssetId] = block.chainid;\n        ASSET_ROUTER.setAssetHandlerAddressThisChain(bytes32(uint256(uint160(_nativeToken))), address(this));\n    }\n\n    function _handleChainBalanceIncrease(\n        uint256 _chainId,\n        bytes32 _assetId,\n        uint256 _amount,\n        bool _isNative\n    ) internal virtual;\n\n    function _handleChainBalanceDecrease(\n        uint256 _chainId,\n        bytes32 _assetId,\n        uint256 _amount,\n        bool _isNative\n    ) internal virtual;\n\n    /*//////////////////////////////////////////////////////////////\n                            TOKEN DEPLOYER FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function _ensureAndSaveTokenDeployed(\n        bytes32 _assetId,\n        address _originToken,\n        bytes memory _erc20Data\n    ) internal virtual returns (address expectedToken) {\n        uint256 tokenOriginChainId;\n        (expectedToken, tokenOriginChainId) = _calculateExpectedTokenAddress(_originToken, _erc20Data);\n        _ensureAndSaveTokenDeployedInner({\n            _tokenOriginChainId: tokenOriginChainId,\n            _assetId: _assetId,\n            _originToken: _originToken,\n            _erc20Data: _erc20Data,\n            _expectedToken: expectedToken\n        });\n    }\n\n    /// @notice Calculates the bridged token address corresponding to native token counterpart.\n    function _calculateExpectedTokenAddress(\n        address _originToken,\n        bytes memory _erc20Data\n    ) internal view returns (address expectedToken, uint256 tokenOriginChainId) {\n        /// @dev calling externally to convert from memory to calldata\n        tokenOriginChainId = this.tokenDataOriginChainId(_erc20Data);\n        expectedToken = calculateCreate2TokenAddress(tokenOriginChainId, _originToken);\n    }\n\n    /// @notice Returns the origin chain id from the token data.\n    function tokenDataOriginChainId(bytes calldata _erc20Data) public view returns (uint256 tokenOriginChainId) {\n        // slither-disable-next-line unused-return\n        (tokenOriginChainId, , , ) = DataEncoding.decodeTokenData(_erc20Data);\n        if (tokenOriginChainId == 0) {\n            tokenOriginChainId = L1_CHAIN_ID;\n        }\n    }\n\n    /// @notice Checks that the assetId is correct for the origin token and chain.\n    function _assetIdCheck(uint256 _tokenOriginChainId, bytes32 _assetId, address _originToken) internal view {\n        bytes32 expectedAssetId = DataEncoding.encodeNTVAssetId(_tokenOriginChainId, _originToken);\n        if (_assetId != expectedAssetId) {\n            // Make sure that a NativeTokenVault sent the message\n            revert AssetIdMismatch(_assetId, expectedAssetId);\n        }\n    }\n\n    function _ensureAndSaveTokenDeployedInner(\n        uint256 _tokenOriginChainId,\n        bytes32 _assetId,\n        address _originToken,\n        bytes memory _erc20Data,\n        address _expectedToken\n    ) internal {\n        _assetIdCheck(_tokenOriginChainId, _assetId, _originToken);\n\n        address deployedToken = _deployBridgedToken(_tokenOriginChainId, _assetId, _originToken, _erc20Data);\n        if (deployedToken != _expectedToken) {\n            revert AddressMismatch(_expectedToken, deployedToken);\n        }\n\n        tokenAddress[_assetId] = _expectedToken;\n        assetId[_expectedToken] = _assetId;\n    }\n\n    /// @notice Calculates the bridged token address corresponding to native token counterpart.\n    /// @param _tokenOriginChainId The chain id of the origin token.\n    /// @param _bridgeToken The address of native token.\n    /// @return The address of bridged token.\n    function calculateCreate2TokenAddress(\n        uint256 _tokenOriginChainId,\n        address _bridgeToken\n    ) public view virtual override returns (address);\n\n    /// @notice Deploys and initializes the bridged token for the native counterpart.\n    /// @param _tokenOriginChainId The chain id of the origin token.\n    /// @param _originToken The address of origin token.\n    /// @param _erc20Data The ERC20 metadata of the token deployed.\n    /// @return The address of the beacon proxy (bridged token).\n    function _deployBridgedToken(\n        uint256 _tokenOriginChainId,\n        bytes32 _assetId,\n        address _originToken,\n        bytes memory _erc20Data\n    ) internal returns (address) {\n        if (_tokenOriginChainId == block.chainid) {\n            revert DeployingBridgedTokenForNativeToken();\n        }\n        bytes32 salt = _getCreate2Salt(_tokenOriginChainId, _originToken);\n\n        BeaconProxy l2Token = _deployBeaconProxy(salt, _tokenOriginChainId);\n        BridgedStandardERC20(address(l2Token)).bridgeInitialize(_assetId, _originToken, _erc20Data);\n\n        originChainId[_assetId] = _tokenOriginChainId;\n        return address(l2Token);\n    }\n\n    /// @notice Converts the L1 token address to the create2 salt of deployed L2 token.\n    /// @param _l1Token The address of token on L1.\n    /// @return salt The salt used to compute address of bridged token on L2 and for beacon proxy deployment.\n    function _getCreate2Salt(uint256 _originChainId, address _l1Token) internal view virtual returns (bytes32 salt) {\n        salt = keccak256(abi.encode(_originChainId, _l1Token));\n    }\n\n    /// @notice Deploys the beacon proxy for the bridged token.\n    /// @dev This function uses raw call to ContractDeployer to make sure that exactly `l2TokenProxyBytecodeHash` is used\n    /// for the code of the proxy.\n    /// @param _salt The salt used for beacon proxy deployment of the bridged token (we pass the native token address).\n    /// @return proxy The beacon proxy, i.e. bridged token.\n    function _deployBeaconProxy(\n        bytes32 _salt,\n        uint256 _tokenOriginChainId\n    ) internal virtual returns (BeaconProxy proxy);\n\n    /*//////////////////////////////////////////////////////////////\n                            PAUSE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Pauses all functions marked with the `whenNotPaused` modifier.\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Unpauses the contract, allowing all functions marked with the `whenNotPaused` modifier to be called again.\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n"
      },
      "contracts/bridgehub/Bridgehub.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {EnumerableMap} from \"@openzeppelin/contracts-v4/utils/structs/EnumerableMap.sol\";\n\nimport {Ownable2StepUpgradeable} from \"@openzeppelin/contracts-upgradeable-v4/access/Ownable2StepUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable-v4/security/PausableUpgradeable.sol\";\n\nimport {IBridgehub, L2TransactionRequestDirect, L2TransactionRequestTwoBridgesOuter, L2TransactionRequestTwoBridgesInner, BridgehubMintCTMAssetData, BridgehubBurnCTMAssetData} from \"./IBridgehub.sol\";\nimport {IAssetRouterBase} from \"../bridge/asset-router/IAssetRouterBase.sol\";\nimport {IL1AssetRouter} from \"../bridge/asset-router/IL1AssetRouter.sol\";\nimport {IL1BaseTokenAssetHandler} from \"../bridge/interfaces/IL1BaseTokenAssetHandler.sol\";\nimport {IChainTypeManager} from \"../state-transition/IChainTypeManager.sol\";\nimport {ReentrancyGuard} from \"../common/ReentrancyGuard.sol\";\nimport {DataEncoding} from \"../common/libraries/DataEncoding.sol\";\nimport {IZKChain} from \"../state-transition/chain-interfaces/IZKChain.sol\";\n\nimport {ETH_TOKEN_ADDRESS, TWO_BRIDGES_MAGIC_VALUE, BRIDGEHUB_MIN_SECOND_BRIDGE_ADDRESS, SETTLEMENT_LAYER_RELAY_SENDER, L1_SETTLEMENT_LAYER_VIRTUAL_ADDRESS} from \"../common/Config.sol\";\nimport {BridgehubL2TransactionRequest, L2Message, L2Log, TxStatus} from \"../common/Messaging.sol\";\nimport {AddressAliasHelper} from \"../vendor/AddressAliasHelper.sol\";\nimport {IMessageRoot} from \"./IMessageRoot.sol\";\nimport {ICTMDeploymentTracker} from \"./ICTMDeploymentTracker.sol\";\nimport {NotL1, NotRelayedSender, NotAssetRouter, ChainIdAlreadyPresent, ChainNotPresentInCTM, SecondBridgeAddressTooLow, NotInGatewayMode, SLNotWhitelisted, IncorrectChainAssetId, NotCurrentSL, HyperchainNotRegistered, IncorrectSender, AlreadyCurrentSL, ChainNotLegacy} from \"./L1BridgehubErrors.sol\";\nimport {NoCTMForAssetId, SettlementLayersMustSettleOnL1, MigrationPaused, AssetIdAlreadyRegistered, CTMNotRegistered, ChainIdNotRegistered, AssetHandlerNotRegistered, ZKChainLimitReached, CTMAlreadyRegistered, CTMNotRegistered, ZeroChainId, ChainIdTooBig, BridgeHubAlreadyRegistered, MsgValueMismatch, ZeroAddress, Unauthorized, SharedBridgeNotSet, WrongMagicValue, ChainIdAlreadyExists, ChainIdMismatch, ChainIdCantBeCurrentChain, EmptyAssetId, AssetIdNotSupported, IncorrectBridgeHubAddress} from \"../common/L1ContractErrors.sol\";\n\nimport {AssetHandlerModifiers} from \"../bridge/interfaces/AssetHandlerModifiers.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev The Bridgehub contract serves as the primary entry point for L1->L2 communication,\n/// facilitating interactions between end user and bridges.\n/// It also manages state transition managers, base tokens, and chain registrations.\n/// Bridgehub is also an IL1AssetHandler for the chains themselves, which is used to migrate the chains\n/// between different settlement layers (for example from L1 to Gateway).\ncontract Bridgehub is IBridgehub, ReentrancyGuard, Ownable2StepUpgradeable, PausableUpgradeable, AssetHandlerModifiers {\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n\n    /// @notice the asset id of Eth. This is only used on L1.\n    bytes32 internal immutable ETH_TOKEN_ASSET_ID;\n\n    /// @notice The chain id of L1. This contract can be deployed on multiple layers, but this value is still equal to the\n    /// L1 that is at the most base layer.\n    uint256 public immutable L1_CHAIN_ID;\n\n    /// @notice The total number of ZK chains can be created/connected to this CTM.\n    /// This is the temporary security measure.\n    uint256 public immutable MAX_NUMBER_OF_ZK_CHAINS;\n\n    /// @notice all the ether and ERC20 tokens are held by NativeVaultToken managed by the asset router.\n    address public assetRouter;\n\n    /// @notice ChainTypeManagers that are registered, and ZKchains that use these CTMs can use this bridgehub as settlement layer.\n    mapping(address chainTypeManager => bool) public chainTypeManagerIsRegistered;\n\n    /// @notice we store registered tokens (for arbitrary base token)\n    mapping(address baseToken => bool) public __DEPRECATED_tokenIsRegistered;\n\n    /// @notice chainID => ChainTypeManager contract address, CTM that is managing rules for a given ZKchain.\n    mapping(uint256 chainId => address) public chainTypeManager;\n\n    /// @notice chainID => baseToken contract address, token that is used as 'base token' by a given child chain.\n    // slither-disable-next-line uninitialized-state\n    mapping(uint256 chainId => address) public __DEPRECATED_baseToken;\n\n    /// @dev used to manage non critical updates\n    address public admin;\n\n    /// @dev used to accept the admin role\n    address private pendingAdmin;\n\n    /// @notice The map from chainId => zkChain contract\n    EnumerableMap.UintToAddressMap internal zkChainMap;\n\n    /// @notice The contract that stores the cross-chain message root for each chain and the aggregated root.\n    /// @dev Note that the message root does not contain messages from the chain it is deployed on. It may\n    /// be added later on if needed.\n    IMessageRoot public override messageRoot;\n\n    /// @notice Mapping from chain id to encoding of the base token used for deposits / withdrawals\n    mapping(uint256 chainId => bytes32) public baseTokenAssetId;\n\n    /// @notice The deployment tracker for the state transition managers.\n    /// @dev The L1 address of the ctm deployer is provided.\n    ICTMDeploymentTracker public l1CtmDeployer;\n\n    /// @dev asset info used to identify chains in the Shared Bridge\n    mapping(bytes32 ctmAssetId => address ctmAddress) public ctmAssetIdToAddress;\n\n    /// @dev ctmAddress to ctmAssetId\n    mapping(address ctmAddress => bytes32 ctmAssetId) public ctmAssetIdFromAddress;\n\n    /// @dev used to indicate the currently active settlement layer for a given chainId\n    mapping(uint256 chainId => uint256 activeSettlementLayerChainId) public settlementLayer;\n\n    /// @notice shows whether the given chain can be used as a settlement layer.\n    /// @dev the Gateway will be one of the possible settlement layers. The L1 is also a settlement layer.\n    /// @dev Sync layer chain is expected to have .. as the base token.\n    mapping(uint256 chainId => bool isWhitelistedSettlementLayer) public whitelistedSettlementLayers;\n\n    /// @notice we store registered assetIds (for arbitrary base token)\n    mapping(bytes32 baseTokenAssetId => bool) public assetIdIsRegistered;\n\n    /// @notice used to pause the migrations of chains. Used for upgrades.\n    bool public migrationPaused;\n\n    modifier onlyOwnerOrAdmin() {\n        if (msg.sender != admin && msg.sender != owner()) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    modifier onlyL1() {\n        if (L1_CHAIN_ID != block.chainid) {\n            revert NotL1(L1_CHAIN_ID, block.chainid);\n        }\n        _;\n    }\n\n    modifier onlySettlementLayerRelayedSender() {\n        /// There is no sender for the wrapping, we use a virtual address.\n        if (msg.sender != SETTLEMENT_LAYER_RELAY_SENDER) {\n            revert NotRelayedSender(msg.sender, SETTLEMENT_LAYER_RELAY_SENDER);\n        }\n        _;\n    }\n\n    modifier onlyAssetRouter() {\n        if (msg.sender != assetRouter) {\n            revert NotAssetRouter(msg.sender, assetRouter);\n        }\n        _;\n    }\n\n    modifier whenMigrationsNotPaused() {\n        if (migrationPaused) {\n            revert MigrationPaused();\n        }\n        _;\n    }\n\n    /// @notice to avoid parity hack\n    constructor(uint256 _l1ChainId, address _owner, uint256 _maxNumberOfZKChains) reentrancyGuardInitializer {\n        _disableInitializers();\n        L1_CHAIN_ID = _l1ChainId;\n        MAX_NUMBER_OF_ZK_CHAINS = _maxNumberOfZKChains;\n\n        // Note that this assumes that the bridgehub only accepts transactions on chains with ETH base token only.\n        // This is indeed true, since the only methods where this immutable is used are the ones with `onlyL1` modifier.\n        // We will change this with interop.\n        ETH_TOKEN_ASSET_ID = DataEncoding.encodeNTVAssetId(L1_CHAIN_ID, ETH_TOKEN_ADDRESS);\n        _transferOwnership(_owner);\n        _initializeInner();\n    }\n\n    /// @notice used to initialize the contract\n    /// @notice this contract is also deployed on L2 as a system contract there the owner and the related functions will not be used\n    /// @param _owner the owner of the contract\n    function initialize(address _owner) external reentrancyGuardInitializer onlyL1 {\n        _transferOwnership(_owner);\n        _initializeInner();\n    }\n\n    /// @notice Used to initialize the contract on L1\n    function initializeV2() external initializer onlyL1 {\n        _initializeInner();\n    }\n\n    /// @notice Initializes the contract\n    function _initializeInner() internal {\n        assetIdIsRegistered[ETH_TOKEN_ASSET_ID] = true;\n        whitelistedSettlementLayers[L1_CHAIN_ID] = true;\n    }\n\n    //// Initialization and registration\n\n    /// @inheritdoc IBridgehub\n    /// @dev Please note, if the owner wants to enforce the admin change it must execute both `setPendingAdmin` and\n    /// `acceptAdmin` atomically. Otherwise `admin` can set different pending admin and so fail to accept the admin rights.\n    function setPendingAdmin(address _newPendingAdmin) external onlyOwnerOrAdmin {\n        if (_newPendingAdmin == address(0)) {\n            revert ZeroAddress();\n        }\n        // Save previous value into the stack to put it into the event later\n        address oldPendingAdmin = pendingAdmin;\n        // Change pending admin\n        pendingAdmin = _newPendingAdmin;\n        emit NewPendingAdmin(oldPendingAdmin, _newPendingAdmin);\n    }\n\n    /// @inheritdoc IBridgehub\n    function acceptAdmin() external {\n        address currentPendingAdmin = pendingAdmin;\n        // Only proposed by current admin address can claim the admin rights\n        if (msg.sender != currentPendingAdmin) {\n            revert Unauthorized(msg.sender);\n        }\n\n        address previousAdmin = admin;\n        admin = currentPendingAdmin;\n        delete pendingAdmin;\n\n        emit NewPendingAdmin(currentPendingAdmin, address(0));\n        emit NewAdmin(previousAdmin, currentPendingAdmin);\n    }\n\n    /// @notice To set the addresses of some of the ecosystem contracts, only Owner. Not done in initialize, as\n    /// the order of deployment is Bridgehub, other contracts, and then we call this.\n    /// @param _assetRouter the shared bridge address\n    /// @param _l1CtmDeployer the ctm deployment tracker address. Note, that the address of the L1 CTM deployer is provided.\n    /// @param _messageRoot the message root address\n    function setAddresses(\n        address _assetRouter,\n        ICTMDeploymentTracker _l1CtmDeployer,\n        IMessageRoot _messageRoot\n    ) external onlyOwner {\n        assetRouter = _assetRouter;\n        l1CtmDeployer = _l1CtmDeployer;\n        messageRoot = _messageRoot;\n    }\n\n    /// @notice Used to set the legacy chain data for the upgrade.\n    /// @param _chainId The chainId of the legacy chain we are migrating.\n    function registerLegacyChain(uint256 _chainId) external override {\n        address ctm = chainTypeManager[_chainId];\n        if (ctm == address(0)) {\n            revert ChainNotLegacy();\n        }\n        if (zkChainMap.contains(_chainId)) {\n            revert ChainIdAlreadyPresent();\n        }\n\n        // From now on, since `zkChainMap` did not contain the chain, we assume\n        // that the chain is a legacy chain in the process of migration, i.e.\n        // its stored `baseTokenAssetId`, etc.\n\n        address token = __DEPRECATED_baseToken[_chainId];\n        if (token == address(0)) {\n            revert ChainNotLegacy();\n        }\n\n        bytes32 assetId = DataEncoding.encodeNTVAssetId(block.chainid, token);\n\n        baseTokenAssetId[_chainId] = assetId;\n        assetIdIsRegistered[assetId] = true;\n\n        address chainAddress = IChainTypeManager(ctm).getZKChainLegacy(_chainId);\n        if (chainAddress == address(0)) {\n            revert ChainNotPresentInCTM();\n        }\n        _registerNewZKChain(_chainId, chainAddress, false);\n        messageRoot.addNewChain(_chainId);\n        settlementLayer[_chainId] = block.chainid;\n    }\n\n    //// Registry\n\n    /// @notice Chain Type Manager can be any contract with the appropriate interface/functionality\n    /// @param _chainTypeManager the state transition manager address to be added\n    function addChainTypeManager(address _chainTypeManager) external onlyOwner {\n        if (_chainTypeManager == address(0)) {\n            revert ZeroAddress();\n        }\n        if (chainTypeManagerIsRegistered[_chainTypeManager]) {\n            revert CTMAlreadyRegistered();\n        }\n        chainTypeManagerIsRegistered[_chainTypeManager] = true;\n\n        emit ChainTypeManagerAdded(_chainTypeManager);\n    }\n\n    /// @notice Chain Type Manager can be any contract with the appropriate interface/functionality\n    /// @notice this stops new Chains from using the CTM, old chains are not affected\n    /// @param _chainTypeManager the state transition manager address to be removed\n    function removeChainTypeManager(address _chainTypeManager) external onlyOwner {\n        if (_chainTypeManager == address(0)) {\n            revert ZeroAddress();\n        }\n        if (!chainTypeManagerIsRegistered[_chainTypeManager]) {\n            revert CTMNotRegistered();\n        }\n        chainTypeManagerIsRegistered[_chainTypeManager] = false;\n\n        emit ChainTypeManagerRemoved(_chainTypeManager);\n    }\n\n    /// @notice asset id can represent any token contract with the appropriate interface/functionality\n    /// @param _baseTokenAssetId asset id of base token to be registered\n    function addTokenAssetId(bytes32 _baseTokenAssetId) external onlyOwnerOrAdmin {\n        if (assetIdIsRegistered[_baseTokenAssetId]) {\n            revert AssetIdAlreadyRegistered();\n        }\n        assetIdIsRegistered[_baseTokenAssetId] = true;\n\n        emit BaseTokenAssetIdRegistered(_baseTokenAssetId);\n    }\n\n    /// @notice Used to register a chain as a settlement layer.\n    /// @param _newSettlementLayerChainId the chainId of the chain\n    /// @param _isWhitelisted whether the chain is a whitelisted settlement layer\n    function registerSettlementLayer(\n        uint256 _newSettlementLayerChainId,\n        bool _isWhitelisted\n    ) external onlyOwner onlyL1 {\n        if (settlementLayer[_newSettlementLayerChainId] != block.chainid) {\n            revert SettlementLayersMustSettleOnL1();\n        }\n        whitelistedSettlementLayers[_newSettlementLayerChainId] = _isWhitelisted;\n        emit SettlementLayerRegistered(_newSettlementLayerChainId, _isWhitelisted);\n    }\n\n    /// @dev Used to set the assetAddress for a given assetInfo.\n    /// @param _additionalData the additional data to identify the asset\n    /// @param _assetAddress the asset handler address\n    function setCTMAssetAddress(bytes32 _additionalData, address _assetAddress) external {\n        // It is a simplified version of the logic used by the AssetRouter to manage asset handlers.\n        // CTM's assetId is `keccak256(abi.encode(L1_CHAIN_ID, l1CtmDeployer, ctmAddress))`.\n        // And the l1CtmDeployer is considered the deployment tracker for the CTM asset.\n        //\n        // The l1CtmDeployer will call this method to set the asset handler address for the assetId.\n        // If the chain is not the same as L1, we assume that it is done via L1->L2 communication and so we unalias the sender.\n        //\n        // For simpler handling we allow anyone to call this method. It is okay, since during bridging operations\n        // it is double checked that `assetId` is indeed derived from the `l1CtmDeployer`.\n        // TODO(EVM-703): This logic should be revised once interchain communication is implemented.\n\n        address sender = L1_CHAIN_ID == block.chainid ? msg.sender : AddressAliasHelper.undoL1ToL2Alias(msg.sender);\n        // This method can be accessed by l1CtmDeployer only\n        if (sender != address(l1CtmDeployer)) {\n            revert Unauthorized(sender);\n        }\n        if (!chainTypeManagerIsRegistered[_assetAddress]) {\n            revert CTMNotRegistered();\n        }\n\n        bytes32 ctmAssetId = DataEncoding.encodeAssetId(L1_CHAIN_ID, _additionalData, sender);\n        ctmAssetIdToAddress[ctmAssetId] = _assetAddress;\n        ctmAssetIdFromAddress[_assetAddress] = ctmAssetId;\n        emit AssetRegistered(ctmAssetId, _assetAddress, _additionalData, msg.sender);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          Chain Registration\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice register new chain. New chains can be only registered on Bridgehub deployed on L1. Later they can be moved to any other layer.\n    /// @notice for Eth the baseToken address is 1\n    /// @param _chainId the chainId of the chain\n    /// @param _chainTypeManager the state transition manager address\n    /// @param _baseTokenAssetId the base token asset id of the chain\n    /// @param _salt the salt for the chainId, currently not used\n    /// @param _admin the admin of the chain\n    /// @param _initData the fixed initialization data for the chain\n    /// @param _factoryDeps the factory dependencies for the chain's deployment\n    function createNewChain(\n        uint256 _chainId,\n        address _chainTypeManager,\n        bytes32 _baseTokenAssetId,\n        // solhint-disable-next-line no-unused-vars\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData,\n        bytes[] calldata _factoryDeps\n    ) external onlyOwnerOrAdmin nonReentrant whenNotPaused onlyL1 returns (uint256) {\n        _validateChainParams({_chainId: _chainId, _assetId: _baseTokenAssetId, _chainTypeManager: _chainTypeManager});\n\n        chainTypeManager[_chainId] = _chainTypeManager;\n\n        baseTokenAssetId[_chainId] = _baseTokenAssetId;\n        settlementLayer[_chainId] = block.chainid;\n\n        address chainAddress = IChainTypeManager(_chainTypeManager).createNewChain({\n            _chainId: _chainId,\n            _baseTokenAssetId: _baseTokenAssetId,\n            _admin: _admin,\n            _initData: _initData,\n            _factoryDeps: _factoryDeps\n        });\n        _registerNewZKChain(_chainId, chainAddress, true);\n        messageRoot.addNewChain(_chainId);\n\n        emit NewChain(_chainId, _chainTypeManager, _admin);\n        return _chainId;\n    }\n\n    /// @notice This internal function is used to register a new zkChain in the system.\n    /// @param _chainId The chain ID of the ZK chain\n    /// @param _zkChain The address of the ZK chain's DiamondProxy contract.\n    /// @param _checkMaxNumberOfZKChains Whether to check that the limit for the number\n    /// of chains has not been crossed.\n    /// @dev Providing `_checkMaxNumberOfZKChains = false` may be preferable in cases\n    /// where we want to guarantee that a chain can be added. These include:\n    /// - Migration of a chain from the mapping in the old CTM\n    /// - Migration of a chain to a new settlement layer\n    function _registerNewZKChain(uint256 _chainId, address _zkChain, bool _checkMaxNumberOfZKChains) internal {\n        // slither-disable-next-line unused-return\n        zkChainMap.set(_chainId, _zkChain);\n        if (_checkMaxNumberOfZKChains && zkChainMap.length() > MAX_NUMBER_OF_ZK_CHAINS) {\n            revert ZKChainLimitReached();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             Getters\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice baseToken function, which takes chainId as input, reads assetHandler from AR, and tokenAddress from AH\n    function baseToken(uint256 _chainId) public view returns (address) {\n        bytes32 baseTokenAssetId = baseTokenAssetId[_chainId];\n        address assetHandlerAddress = IAssetRouterBase(assetRouter).assetHandlerAddress(baseTokenAssetId);\n\n        // It is possible that the asset handler is not deployed for a chain on the current layer.\n        // In this case we throw an error.\n        if (assetHandlerAddress == address(0)) {\n            revert AssetHandlerNotRegistered(baseTokenAssetId);\n        }\n        return IL1BaseTokenAssetHandler(assetHandlerAddress).tokenAddress(baseTokenAssetId);\n    }\n\n    /// @notice Returns all the registered zkChain addresses\n    function getAllZKChains() public view override returns (address[] memory chainAddresses) {\n        uint256[] memory keys = zkChainMap.keys();\n        chainAddresses = new address[](keys.length);\n        uint256 keysLength = keys.length;\n        for (uint256 i = 0; i < keysLength; ++i) {\n            chainAddresses[i] = zkChainMap.get(keys[i]);\n        }\n    }\n\n    /// @notice Returns all the registered zkChain chainIDs\n    function getAllZKChainChainIDs() public view override returns (uint256[] memory) {\n        return zkChainMap.keys();\n    }\n\n    /// @notice Returns the address of the ZK chain with the corresponding chainID\n    /// @param _chainId the chainId of the chain\n    /// @return chainAddress the address of the ZK chain\n    function getZKChain(uint256 _chainId) public view override returns (address chainAddress) {\n        // slither-disable-next-line unused-return\n        (, chainAddress) = zkChainMap.tryGet(_chainId);\n    }\n\n    function ctmAssetIdFromChainId(uint256 _chainId) public view override returns (bytes32) {\n        address ctmAddress = chainTypeManager[_chainId];\n        if (ctmAddress == address(0)) {\n            revert ChainIdNotRegistered(_chainId);\n        }\n        return ctmAssetIdFromAddress[ctmAddress];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        Mailbox forwarder\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice the mailbox is called directly after the assetRouter received the deposit\n    /// this assumes that either ether is the base token or\n    /// the msg.sender has approved mintValue allowance for the nativeTokenVault.\n    /// This means this is not ideal for contract calls, as the contract would have to handle token allowance of the base Token.\n    /// In case allowance is provided to the Asset Router, then it will be transferred to NTV.\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable override nonReentrant whenNotPaused onlyL1 returns (bytes32 canonicalTxHash) {\n        // Note: If the ZK chain with corresponding `chainId` is not yet created,\n        // the transaction will revert on `bridgehubRequestL2Transaction` as call to zero address.\n        {\n            bytes32 tokenAssetId = baseTokenAssetId[_request.chainId];\n            if (tokenAssetId == ETH_TOKEN_ASSET_ID) {\n                if (msg.value != _request.mintValue) {\n                    revert MsgValueMismatch(_request.mintValue, msg.value);\n                }\n            } else {\n                if (msg.value != 0) {\n                    revert MsgValueMismatch(0, msg.value);\n                }\n            }\n\n            // slither-disable-next-line arbitrary-send-eth\n            IL1AssetRouter(assetRouter).bridgehubDepositBaseToken{value: msg.value}(\n                _request.chainId,\n                tokenAssetId,\n                msg.sender,\n                _request.mintValue\n            );\n        }\n\n        canonicalTxHash = _sendRequest(\n            _request.chainId,\n            _request.refundRecipient,\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _request.l2Contract,\n                mintValue: _request.mintValue,\n                l2Value: _request.l2Value,\n                l2Calldata: _request.l2Calldata,\n                l2GasLimit: _request.l2GasLimit,\n                l2GasPerPubdataByteLimit: _request.l2GasPerPubdataByteLimit,\n                factoryDeps: _request.factoryDeps,\n                refundRecipient: address(0)\n            })\n        );\n    }\n\n    /// @notice After depositing funds to the assetRouter, the secondBridge is called\n    ///  to return the actual L2 message which is sent to the Mailbox.\n    ///  This assumes that either ether is the base token or\n    ///  the msg.sender has approved the nativeTokenVault with the mintValue,\n    ///  and also the necessary approvals are given for the second bridge.\n    ///  In case allowance is provided to the Shared Bridge, then it will be transferred to NTV.\n    /// @notice The logic of this bridge is to allow easy depositing for bridges.\n    /// Each contract that handles the users ERC20 tokens needs approvals from the user, this contract allows\n    /// the user to approve for each token only its respective bridge\n    /// @notice This function is great for contract calls to L2, the secondBridge can be any contract.\n    /// @param _request the request for the L2 transaction\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable override nonReentrant whenNotPaused onlyL1 returns (bytes32 canonicalTxHash) {\n        if (_request.secondBridgeAddress <= BRIDGEHUB_MIN_SECOND_BRIDGE_ADDRESS) {\n            revert SecondBridgeAddressTooLow(_request.secondBridgeAddress, BRIDGEHUB_MIN_SECOND_BRIDGE_ADDRESS);\n        }\n\n        {\n            bytes32 tokenAssetId = baseTokenAssetId[_request.chainId];\n            uint256 baseTokenMsgValue;\n            if (tokenAssetId == ETH_TOKEN_ASSET_ID) {\n                if (msg.value != _request.mintValue + _request.secondBridgeValue) {\n                    revert MsgValueMismatch(_request.mintValue + _request.secondBridgeValue, msg.value);\n                }\n                baseTokenMsgValue = _request.mintValue;\n            } else {\n                if (msg.value != _request.secondBridgeValue) {\n                    revert MsgValueMismatch(_request.secondBridgeValue, msg.value);\n                }\n                baseTokenMsgValue = 0;\n            }\n\n            // slither-disable-next-line arbitrary-send-eth\n            IL1AssetRouter(assetRouter).bridgehubDepositBaseToken{value: baseTokenMsgValue}(\n                _request.chainId,\n                tokenAssetId,\n                msg.sender,\n                _request.mintValue\n            );\n        }\n\n        // slither-disable-next-line arbitrary-send-eth\n        L2TransactionRequestTwoBridgesInner memory outputRequest = IL1AssetRouter(_request.secondBridgeAddress)\n            .bridgehubDeposit{value: _request.secondBridgeValue}(\n            _request.chainId,\n            msg.sender,\n            _request.l2Value,\n            _request.secondBridgeCalldata\n        );\n\n        if (outputRequest.magicValue != TWO_BRIDGES_MAGIC_VALUE) {\n            revert WrongMagicValue(uint256(TWO_BRIDGES_MAGIC_VALUE), uint256(outputRequest.magicValue));\n        }\n\n        canonicalTxHash = _sendRequest(\n            _request.chainId,\n            _request.refundRecipient,\n            BridgehubL2TransactionRequest({\n                sender: _request.secondBridgeAddress,\n                contractL2: outputRequest.l2Contract,\n                mintValue: _request.mintValue,\n                l2Value: _request.l2Value,\n                l2Calldata: outputRequest.l2Calldata,\n                l2GasLimit: _request.l2GasLimit,\n                l2GasPerPubdataByteLimit: _request.l2GasPerPubdataByteLimit,\n                factoryDeps: outputRequest.factoryDeps,\n                refundRecipient: address(0)\n            })\n        );\n\n        IL1AssetRouter(_request.secondBridgeAddress).bridgehubConfirmL2Transaction(\n            _request.chainId,\n            outputRequest.txDataHash,\n            canonicalTxHash\n        );\n    }\n\n    /// @notice This function is used to send a request to the ZK chain.\n    /// @param _chainId the chainId of the chain\n    /// @param _refundRecipient the refund recipient\n    /// @param _request the request\n    /// @return canonicalTxHash the canonical transaction hash\n    function _sendRequest(\n        uint256 _chainId,\n        address _refundRecipient,\n        BridgehubL2TransactionRequest memory _request\n    ) internal returns (bytes32 canonicalTxHash) {\n        address refundRecipient = AddressAliasHelper.actualRefundRecipient(_refundRecipient, msg.sender);\n        _request.refundRecipient = refundRecipient;\n        address zkChain = zkChainMap.get(_chainId);\n\n        canonicalTxHash = IZKChain(zkChain).bridgehubRequestL2Transaction(_request);\n    }\n\n    /// @notice Used to forward a transaction on the gateway to the chains mailbox (from L1).\n    /// @param _chainId the chainId of the chain\n    /// @param _canonicalTxHash the canonical transaction hash\n    /// @param _expirationTimestamp the expiration timestamp for the transaction\n    function forwardTransactionOnGateway(\n        uint256 _chainId,\n        bytes32 _canonicalTxHash,\n        uint64 _expirationTimestamp\n    ) external override onlySettlementLayerRelayedSender {\n        if (L1_CHAIN_ID == block.chainid) {\n            revert NotInGatewayMode();\n        }\n        address zkChain = zkChainMap.get(_chainId);\n        IZKChain(zkChain).bridgehubRequestL2TransactionOnGateway(_canonicalTxHash, _expirationTimestamp);\n    }\n\n    /// @notice forwards function call to Mailbox based on ChainId\n    /// @param _chainId The chain ID of the ZK chain where to prove L2 message inclusion.\n    /// @param _batchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view override returns (bool) {\n        address zkChain = zkChainMap.get(_chainId);\n        return IZKChain(zkChain).proveL2MessageInclusion(_batchNumber, _index, _message, _proof);\n    }\n\n    /// @notice forwards function call to Mailbox based on ChainId\n    /// @param _chainId The chain ID of the ZK chain where to prove L2 log inclusion.\n    /// @param _batchNumber The executed L2 batch number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    /// @return Whether the proof is correct and L2 log is included in batch\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log calldata _log,\n        bytes32[] calldata _proof\n    ) external view override returns (bool) {\n        address zkChain = zkChainMap.get(_chainId);\n        return IZKChain(zkChain).proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @notice forwards function call to Mailbox based on ChainId\n    /// @param _chainId The chain ID of the ZK chain where to prove L1->L2 tx status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn't mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view override returns (bool) {\n        address zkChain = zkChainMap.get(_chainId);\n        return\n            IZKChain(zkChain).proveL1ToL2TransactionStatus({\n                _l2TxHash: _l2TxHash,\n                _l2BatchNumber: _l2BatchNumber,\n                _l2MessageIndex: _l2MessageIndex,\n                _l2TxNumberInBatch: _l2TxNumberInBatch,\n                _merkleProof: _merkleProof,\n                _status: _status\n            });\n    }\n\n    /// @notice forwards function call to Mailbox based on ChainId\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256) {\n        address zkChain = zkChainMap.get(_chainId);\n        return IZKChain(zkChain).l2TransactionBaseCost(_gasPrice, _l2GasLimit, _l2GasPerPubdataByteLimit);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        Chain migration\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice IL1AssetHandler interface, used to migrate (transfer) a chain to the settlement layer.\n    /// @param _settlementChainId the chainId of the settlement chain, i.e. where the message and the migrating chain is sent.\n    /// @param _assetId the assetId of the migrating chain's CTM\n    /// @param _originalCaller the message sender initiated a set of calls that leads to bridge burn\n    /// @param _data the data for the migration\n    function bridgeBurn(\n        uint256 _settlementChainId,\n        uint256 _l2MsgValue,\n        bytes32 _assetId,\n        address _originalCaller,\n        bytes calldata _data\n    )\n        external\n        payable\n        override\n        requireZeroValue(_l2MsgValue + msg.value)\n        onlyAssetRouter\n        whenMigrationsNotPaused\n        returns (bytes memory bridgehubMintData)\n    {\n        if (!whitelistedSettlementLayers[_settlementChainId]) {\n            revert SLNotWhitelisted();\n        }\n\n        BridgehubBurnCTMAssetData memory bridgehubBurnData = abi.decode(_data, (BridgehubBurnCTMAssetData));\n        if (_assetId != ctmAssetIdFromChainId(bridgehubBurnData.chainId)) {\n            revert IncorrectChainAssetId(_assetId, ctmAssetIdFromChainId(bridgehubBurnData.chainId));\n        }\n        if (settlementLayer[bridgehubBurnData.chainId] != block.chainid) {\n            revert NotCurrentSL(settlementLayer[bridgehubBurnData.chainId], block.chainid);\n        }\n        settlementLayer[bridgehubBurnData.chainId] = _settlementChainId;\n\n        if (whitelistedSettlementLayers[bridgehubBurnData.chainId]) {\n            revert SettlementLayersMustSettleOnL1();\n        }\n\n        address zkChain = zkChainMap.get(bridgehubBurnData.chainId);\n        if (zkChain == address(0)) {\n            revert HyperchainNotRegistered();\n        }\n        if (_originalCaller != IZKChain(zkChain).getAdmin()) {\n            revert IncorrectSender(_originalCaller, IZKChain(zkChain).getAdmin());\n        }\n\n        bytes memory ctmMintData = IChainTypeManager(chainTypeManager[bridgehubBurnData.chainId]).forwardedBridgeBurn(\n            bridgehubBurnData.chainId,\n            bridgehubBurnData.ctmData\n        );\n        bytes memory chainMintData = IZKChain(zkChain).forwardedBridgeBurn(\n            _settlementChainId == L1_CHAIN_ID\n                ? L1_SETTLEMENT_LAYER_VIRTUAL_ADDRESS\n                : zkChainMap.get(_settlementChainId),\n            _originalCaller,\n            bridgehubBurnData.chainData\n        );\n        BridgehubMintCTMAssetData memory bridgeMintStruct = BridgehubMintCTMAssetData({\n            chainId: bridgehubBurnData.chainId,\n            baseTokenAssetId: baseTokenAssetId[bridgehubBurnData.chainId],\n            ctmData: ctmMintData,\n            chainData: chainMintData\n        });\n        bridgehubMintData = abi.encode(bridgeMintStruct);\n\n        emit MigrationStarted(bridgehubBurnData.chainId, _assetId, _settlementChainId);\n    }\n\n    /// @dev IL1AssetHandler interface, used to receive a chain on the settlement layer.\n    /// @param _assetId the assetId of the chain's CTM\n    /// @param _bridgehubMintData the data for the mint\n    function bridgeMint(\n        uint256, // originChainId\n        bytes32 _assetId,\n        bytes calldata _bridgehubMintData\n    ) external payable override requireZeroValue(msg.value) onlyAssetRouter whenMigrationsNotPaused {\n        BridgehubMintCTMAssetData memory bridgehubMintData = abi.decode(\n            _bridgehubMintData,\n            (BridgehubMintCTMAssetData)\n        );\n\n        address ctm = ctmAssetIdToAddress[_assetId];\n        if (ctm == address(0)) {\n            revert NoCTMForAssetId(_assetId);\n        }\n        if (settlementLayer[bridgehubMintData.chainId] == block.chainid) {\n            revert AlreadyCurrentSL(block.chainid);\n        }\n\n        settlementLayer[bridgehubMintData.chainId] = block.chainid;\n        chainTypeManager[bridgehubMintData.chainId] = ctm;\n        baseTokenAssetId[bridgehubMintData.chainId] = bridgehubMintData.baseTokenAssetId;\n        // To keep `assetIdIsRegistered` consistent, we'll also automatically register the base token.\n        // It is assumed that if the bridging happened, the token was approved on L1 already.\n        assetIdIsRegistered[bridgehubMintData.baseTokenAssetId] = true;\n\n        address zkChain = getZKChain(bridgehubMintData.chainId);\n        bool contractAlreadyDeployed = zkChain != address(0);\n        if (!contractAlreadyDeployed) {\n            zkChain = IChainTypeManager(ctm).forwardedBridgeMint(bridgehubMintData.chainId, bridgehubMintData.ctmData);\n            if (zkChain == address(0)) {\n                revert ChainIdNotRegistered(bridgehubMintData.chainId);\n            }\n            // We want to allow any chain to be migrated,\n            _registerNewZKChain(bridgehubMintData.chainId, zkChain, false);\n            messageRoot.addNewChain(bridgehubMintData.chainId);\n        }\n\n        IZKChain(zkChain).forwardedBridgeMint(bridgehubMintData.chainData, contractAlreadyDeployed);\n\n        emit MigrationFinalized(bridgehubMintData.chainId, _assetId, zkChain);\n    }\n\n    /// @dev IL1AssetHandler interface, used to undo a failed migration of a chain.\n    // / @param _chainId the chainId of the chain\n    /// @param _assetId the assetId of the chain's CTM\n    /// @param _data the data for the recovery.\n    function bridgeRecoverFailedTransfer(\n        uint256,\n        bytes32 _assetId,\n        address _depositSender,\n        bytes calldata _data\n    ) external payable override requireZeroValue(msg.value) onlyAssetRouter onlyL1 {\n        BridgehubBurnCTMAssetData memory bridgehubBurnData = abi.decode(_data, (BridgehubBurnCTMAssetData));\n\n        settlementLayer[bridgehubBurnData.chainId] = block.chainid;\n\n        IChainTypeManager(chainTypeManager[bridgehubBurnData.chainId]).forwardedBridgeRecoverFailedTransfer({\n            _chainId: bridgehubBurnData.chainId,\n            _assetInfo: _assetId,\n            _depositSender: _depositSender,\n            _ctmData: bridgehubBurnData.ctmData\n        });\n\n        IZKChain(getZKChain(bridgehubBurnData.chainId)).forwardedBridgeRecoverFailedTransfer({\n            _chainId: bridgehubBurnData.chainId,\n            _assetInfo: _assetId,\n            _originalCaller: _depositSender,\n            _chainData: bridgehubBurnData.chainData\n        });\n    }\n\n    /// @dev Registers an already deployed chain with the bridgehub\n    /// @param _chainId The chain Id of the chain\n    /// @param _zkChain Address of the zkChain\n    function registerAlreadyDeployedZKChain(uint256 _chainId, address _zkChain) external onlyOwner onlyL1 {\n        if (_zkChain == address(0)) {\n            revert ZeroAddress();\n        }\n        if (zkChainMap.contains(_chainId)) {\n            revert ChainIdAlreadyExists();\n        }\n        if (IZKChain(_zkChain).getChainId() != _chainId) {\n            revert ChainIdMismatch();\n        }\n\n        address ctm = IZKChain(_zkChain).getChainTypeManager();\n        address chainAdmin = IZKChain(_zkChain).getAdmin();\n        bytes32 chainBaseTokenAssetId = IZKChain(_zkChain).getBaseTokenAssetId();\n        address bridgeHub = IZKChain(_zkChain).getBridgehub();\n\n        if (bridgeHub != address(this)) {\n            revert IncorrectBridgeHubAddress(bridgeHub);\n        }\n\n        _validateChainParams({_chainId: _chainId, _assetId: chainBaseTokenAssetId, _chainTypeManager: ctm});\n\n        chainTypeManager[_chainId] = ctm;\n\n        baseTokenAssetId[_chainId] = chainBaseTokenAssetId;\n        settlementLayer[_chainId] = block.chainid;\n\n        _registerNewZKChain(_chainId, _zkChain, true);\n        messageRoot.addNewChain(_chainId);\n\n        emit NewChain(_chainId, ctm, chainAdmin);\n    }\n\n    function _validateChainParams(uint256 _chainId, bytes32 _assetId, address _chainTypeManager) internal view {\n        if (_chainId == 0) {\n            revert ZeroChainId();\n        }\n\n        if (_chainId > type(uint48).max) {\n            revert ChainIdTooBig();\n        }\n\n        if (_chainId == block.chainid) {\n            revert ChainIdCantBeCurrentChain();\n        }\n\n        if (_chainTypeManager == address(0)) {\n            revert ZeroAddress();\n        }\n        if (_assetId == bytes32(0)) {\n            revert EmptyAssetId();\n        }\n\n        if (!chainTypeManagerIsRegistered[_chainTypeManager]) {\n            revert CTMNotRegistered();\n        }\n\n        if (!assetIdIsRegistered[_assetId]) {\n            revert AssetIdNotSupported(_assetId);\n        }\n\n        if (assetRouter == address(0)) {\n            revert SharedBridgeNotSet();\n        }\n        if (chainTypeManager[_chainId] != address(0)) {\n            revert BridgeHubAlreadyRegistered();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PAUSE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Pauses all functions marked with the `whenNotPaused` modifier.\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Unpauses the contract, allowing all functions marked with the `whenNotPaused` modifier to be called again.\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /// @notice Pauses migration functions.\n    function pauseMigration() external onlyOwner {\n        migrationPaused = true;\n    }\n\n    /// @notice Unpauses migration functions.\n    function unpauseMigration() external onlyOwner {\n        migrationPaused = false;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Legacy functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice return the ZK chain contract for a chainId\n    function getHyperchain(uint256 _chainId) public view returns (address) {\n        return getZKChain(_chainId);\n    }\n\n    /// @notice return the asset router\n    function sharedBridge() public view returns (address) {\n        return assetRouter;\n    }\n}\n"
      },
      "contracts/bridgehub/CTMDeploymentTracker.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Ownable2StepUpgradeable} from \"@openzeppelin/contracts-upgradeable-v4/access/Ownable2StepUpgradeable.sol\";\n\nimport {IBridgehub, L2TransactionRequestTwoBridgesInner} from \"./IBridgehub.sol\";\nimport {ICTMDeploymentTracker} from \"./ICTMDeploymentTracker.sol\";\n\nimport {IAssetRouterBase} from \"../bridge/asset-router/IAssetRouterBase.sol\";\nimport {TWO_BRIDGES_MAGIC_VALUE} from \"../common/Config.sol\";\nimport {L2_BRIDGEHUB_ADDR} from \"../common/L2ContractAddresses.sol\";\nimport {OnlyBridgehub, CTMNotRegistered, NotOwnerViaRouter, NoEthAllowed, NotOwner, WrongCounterPart} from \"./L1BridgehubErrors.sol\";\nimport {UnsupportedEncodingVersion} from \"../common/L1ContractErrors.sol\";\n\n/// @dev The encoding version of the data.\nbytes1 constant CTM_DEPLOYMENT_TRACKER_ENCODING_VERSION = 0x01;\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev Contract to be deployed on L1, can link together other contracts based on AssetInfo.\ncontract CTMDeploymentTracker is ICTMDeploymentTracker, Ownable2StepUpgradeable {\n    /// @dev Bridgehub smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication.\n    IBridgehub public immutable override BRIDGE_HUB;\n\n    /// @dev L1AssetRouter smart contract that is used to bridge assets (including chains) between L1 and L2.\n    IAssetRouterBase public immutable override L1_ASSET_ROUTER;\n\n    /// @notice Checks that the message sender is the bridgehub.\n    modifier onlyBridgehub() {\n        if (msg.sender != address(BRIDGE_HUB)) {\n            revert OnlyBridgehub(msg.sender, address(BRIDGE_HUB));\n        }\n        _;\n    }\n\n    /// @notice Checks that the message sender is the bridgehub.\n    modifier onlyOwnerViaRouter(address _originalCaller) {\n        if (msg.sender != address(L1_ASSET_ROUTER) || _originalCaller != owner()) {\n            revert NotOwnerViaRouter(msg.sender, _originalCaller);\n        }\n        _;\n    }\n\n    /// @dev Contract is expected to be used as proxy implementation on L1.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IBridgehub _bridgehub, IAssetRouterBase _l1AssetRouter) {\n        _disableInitializers();\n        BRIDGE_HUB = _bridgehub;\n        L1_ASSET_ROUTER = _l1AssetRouter;\n    }\n\n    /// @notice used to initialize the contract\n    /// @param _owner the owner of the contract\n    function initialize(address _owner) external initializer {\n        _transferOwnership(_owner);\n    }\n\n    /// @notice Used to register the ctm asset in L1 contracts, AssetRouter and Bridgehub.\n    /// @param _ctmAddress the address of the ctm asset\n    function registerCTMAssetOnL1(address _ctmAddress) external onlyOwner {\n        if (!BRIDGE_HUB.chainTypeManagerIsRegistered(_ctmAddress)) {\n            revert CTMNotRegistered();\n        }\n        L1_ASSET_ROUTER.setAssetHandlerAddressThisChain(bytes32(uint256(uint160(_ctmAddress))), address(BRIDGE_HUB));\n        BRIDGE_HUB.setCTMAssetAddress(bytes32(uint256(uint160(_ctmAddress))), _ctmAddress);\n    }\n\n    /// @notice The function responsible for registering the L2 counterpart of an CTM asset on the L2 Bridgehub.\n    /// @dev The function is called by the Bridgehub contract during the `Bridgehub.requestL2TransactionTwoBridges`.\n    /// @dev Since the L2 settlement layers `_chainId` might potentially have ERC20 tokens as native assets,\n    /// there are two ways to perform the L1->L2 transaction:\n    /// - via the `Bridgehub.requestL2TransactionDirect`. However, this would require the CTMDeploymentTracker to\n    /// handle the ERC20 balances to be used in the transaction.\n    /// - via the `Bridgehub.requestL2TransactionTwoBridges`. This way it will be the sender that provides the funds\n    /// for the L2 transaction.\n    /// The second approach is used due to its simplicity even though it gives the sender slightly more control over the call:\n    /// `gasLimit`, etc.\n    /// @param _chainId the chainId of the chain\n    /// @param _originalCaller the previous message sender\n    /// @param _data the data of the transaction\n    // slither-disable-next-line locked-ether\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _originalCaller,\n        uint256,\n        bytes calldata _data\n    ) external payable onlyBridgehub returns (L2TransactionRequestTwoBridgesInner memory request) {\n        if (msg.value != 0) {\n            revert NoEthAllowed();\n        }\n\n        if (_originalCaller != owner()) {\n            revert NotOwner(_originalCaller, owner());\n        }\n        bytes1 encodingVersion = _data[0];\n        if (encodingVersion != CTM_DEPLOYMENT_TRACKER_ENCODING_VERSION) {\n            revert UnsupportedEncodingVersion();\n        }\n        (address _ctmL1Address, address _ctmL2Address) = abi.decode(_data[1:], (address, address));\n\n        request = _registerCTMAssetOnL2Bridgehub(_chainId, _ctmL1Address, _ctmL2Address);\n    }\n\n    /// @notice The function called by the Bridgehub after the L2 transaction has been initiated.\n    /// @dev Not used in this contract. In case the transaction fails, we can just re-try it.\n    function bridgehubConfirmL2Transaction(\n        uint256 _chainId,\n        bytes32 _txDataHash,\n        bytes32 _txHash\n    ) external onlyBridgehub {}\n\n    /// @notice Used to register the ctm asset in L2 AssetRouter.\n    /// @param _originalCaller the address that called the Router\n    /// @param _assetHandlerAddressOnCounterpart the address of the asset handler on the counterpart chain.\n    function bridgeCheckCounterpartAddress(\n        uint256,\n        bytes32,\n        address _originalCaller,\n        address _assetHandlerAddressOnCounterpart\n    ) external view override onlyOwnerViaRouter(_originalCaller) {\n        if (_assetHandlerAddressOnCounterpart != L2_BRIDGEHUB_ADDR) {\n            revert WrongCounterPart(_assetHandlerAddressOnCounterpart, L2_BRIDGEHUB_ADDR);\n        }\n    }\n\n    function calculateAssetId(address _l1CTM) public view override returns (bytes32) {\n        return keccak256(abi.encode(block.chainid, address(this), bytes32(uint256(uint160(_l1CTM)))));\n    }\n\n    /// @notice Used to register the ctm asset in L2 Bridgehub.\n    /// @param _chainId the chainId of the chain\n    function _registerCTMAssetOnL2Bridgehub(\n        // solhint-disable-next-line no-unused-vars\n        uint256 _chainId,\n        address _ctmL1Address,\n        address _ctmL2Address\n    ) internal pure returns (L2TransactionRequestTwoBridgesInner memory request) {\n        bytes memory l2TxCalldata = abi.encodeCall(\n            IBridgehub.setCTMAssetAddress,\n            (bytes32(uint256(uint160(_ctmL1Address))), _ctmL2Address)\n        );\n\n        request = L2TransactionRequestTwoBridgesInner({\n            magicValue: TWO_BRIDGES_MAGIC_VALUE,\n            l2Contract: L2_BRIDGEHUB_ADDR,\n            l2Calldata: l2TxCalldata,\n            factoryDeps: new bytes[](0),\n            // The `txDataHash` is typically used in usual ERC20 bridges to commit to the transaction data\n            // so that the user can recover funds in case the bridging fails on L2.\n            // However, this contract uses the `requestL2TransactionTwoBridges` method just to perform an L1->L2 transaction.\n            // We do not need to recover anything and so `bytes32(0)` here is okay.\n            txDataHash: bytes32(0)\n        });\n    }\n}\n"
      },
      "contracts/bridgehub/IBridgehub.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {L2Message, L2Log, TxStatus} from \"../common/Messaging.sol\";\nimport {IL1AssetHandler} from \"../bridge/interfaces/IL1AssetHandler.sol\";\nimport {ICTMDeploymentTracker} from \"./ICTMDeploymentTracker.sol\";\nimport {IMessageRoot} from \"./IMessageRoot.sol\";\nimport {IAssetHandler} from \"../bridge/interfaces/IAssetHandler.sol\";\n\nstruct L2TransactionRequestDirect {\n    uint256 chainId;\n    uint256 mintValue;\n    address l2Contract;\n    uint256 l2Value;\n    bytes l2Calldata;\n    uint256 l2GasLimit;\n    uint256 l2GasPerPubdataByteLimit;\n    bytes[] factoryDeps;\n    address refundRecipient;\n}\n\nstruct L2TransactionRequestTwoBridgesOuter {\n    uint256 chainId;\n    uint256 mintValue;\n    uint256 l2Value;\n    uint256 l2GasLimit;\n    uint256 l2GasPerPubdataByteLimit;\n    address refundRecipient;\n    address secondBridgeAddress;\n    uint256 secondBridgeValue;\n    bytes secondBridgeCalldata;\n}\n\nstruct L2TransactionRequestTwoBridgesInner {\n    bytes32 magicValue;\n    address l2Contract;\n    bytes l2Calldata;\n    bytes[] factoryDeps;\n    bytes32 txDataHash;\n}\n\nstruct BridgehubMintCTMAssetData {\n    uint256 chainId;\n    bytes32 baseTokenAssetId;\n    bytes ctmData;\n    bytes chainData;\n}\n\nstruct BridgehubBurnCTMAssetData {\n    uint256 chainId;\n    bytes ctmData;\n    bytes chainData;\n}\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IBridgehub is IAssetHandler, IL1AssetHandler {\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice CTM asset registered\n    event AssetRegistered(\n        bytes32 indexed assetInfo,\n        address indexed _assetAddress,\n        bytes32 indexed additionalData,\n        address sender\n    );\n\n    event SettlementLayerRegistered(uint256 indexed chainId, bool indexed isWhitelisted);\n\n    /// @notice Emitted when the bridging to the chain is started.\n    /// @param chainId Chain ID of the ZK chain\n    /// @param assetId Asset ID of the token for the zkChain's CTM\n    /// @param settlementLayerChainId The chain id of the settlement layer the chain migrates to.\n    event MigrationStarted(uint256 indexed chainId, bytes32 indexed assetId, uint256 indexed settlementLayerChainId);\n\n    /// @notice Emitted when the bridging to the chain is complete.\n    /// @param chainId Chain ID of the ZK chain\n    /// @param assetId Asset ID of the token for the zkChain's CTM\n    /// @param zkChain The address of the ZK chain on the chain where it is migrated to.\n    event MigrationFinalized(uint256 indexed chainId, bytes32 indexed assetId, address indexed zkChain);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin or owner can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function chainTypeManagerIsRegistered(address _chainTypeManager) external view returns (bool);\n\n    function chainTypeManager(uint256 _chainId) external view returns (address);\n\n    function assetIdIsRegistered(bytes32 _baseTokenAssetId) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function baseTokenAssetId(uint256 _chainId) external view returns (bytes32);\n\n    function sharedBridge() external view returns (address);\n\n    function messageRoot() external view returns (IMessageRoot);\n\n    function getZKChain(uint256 _chainId) external view returns (address);\n\n    function getAllZKChains() external view returns (address[] memory);\n\n    function getAllZKChainChainIDs() external view returns (uint256[] memory);\n\n    function migrationPaused() external view returns (bool);\n\n    function admin() external view returns (address);\n\n    function assetRouter() external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _chainTypeManager,\n        bytes32 _baseTokenAssetId,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData,\n        bytes[] calldata _factoryDeps\n    ) external returns (uint256 chainId);\n\n    function addChainTypeManager(address _chainTypeManager) external;\n\n    function removeChainTypeManager(address _chainTypeManager) external;\n\n    function addTokenAssetId(bytes32 _baseTokenAssetId) external;\n\n    function setAddresses(\n        address _sharedBridge,\n        ICTMDeploymentTracker _l1CtmDeployer,\n        IMessageRoot _messageRoot\n    ) external;\n\n    event NewChain(uint256 indexed chainId, address chainTypeManager, address indexed chainGovernance);\n\n    event ChainTypeManagerAdded(address indexed chainTypeManager);\n\n    event ChainTypeManagerRemoved(address indexed chainTypeManager);\n\n    event BaseTokenAssetIdRegistered(bytes32 indexed assetId);\n\n    function whitelistedSettlementLayers(uint256 _chainId) external view returns (bool);\n\n    function registerSettlementLayer(uint256 _newSettlementLayerChainId, bool _isWhitelisted) external;\n\n    function settlementLayer(uint256 _chainId) external view returns (uint256);\n\n    // function finalizeMigrationToGateway(\n    //     uint256 _chainId,\n    //     address _baseToken,\n    //     address _sharedBridge,\n    //     address _admin,\n    //     uint256 _expectedProtocolVersion,\n    //     ZKChainCommitment calldata _commitment,\n    //     bytes calldata _diamondCut\n    // ) external;\n\n    function forwardTransactionOnGateway(\n        uint256 _chainId,\n        bytes32 _canonicalTxHash,\n        uint64 _expirationTimestamp\n    ) external;\n\n    function ctmAssetIdFromChainId(uint256 _chainId) external view returns (bytes32);\n\n    function ctmAssetIdFromAddress(address _ctmAddress) external view returns (bytes32);\n\n    function l1CtmDeployer() external view returns (ICTMDeploymentTracker);\n\n    function ctmAssetIdToAddress(bytes32 _assetInfo) external view returns (address);\n\n    function setCTMAssetAddress(bytes32 _additionalData, address _assetAddress) external;\n\n    function L1_CHAIN_ID() external view returns (uint256);\n\n    function registerAlreadyDeployedZKChain(uint256 _chainId, address _hyperchain) external;\n\n    /// @notice return the ZK chain contract for a chainId\n    /// @dev It is a legacy method. Do not use!\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    function registerLegacyChain(uint256 _chainId) external;\n}\n"
      },
      "contracts/bridgehub/ICTMDeploymentTracker.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {L2TransactionRequestTwoBridgesInner, IBridgehub} from \"./IBridgehub.sol\";\nimport {IAssetRouterBase} from \"../bridge/asset-router/IAssetRouterBase.sol\";\nimport {IL1AssetDeploymentTracker} from \"../bridge/interfaces/IL1AssetDeploymentTracker.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface ICTMDeploymentTracker is IL1AssetDeploymentTracker {\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _originalCaller,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function L1_ASSET_ROUTER() external view returns (IAssetRouterBase);\n\n    function registerCTMAssetOnL1(address _ctmAddress) external;\n\n    function calculateAssetId(address _l1CTM) external view returns (bytes32);\n}\n"
      },
      "contracts/bridgehub/IMessageRoot.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IBridgehub} from \"./IBridgehub.sol\";\n\n/**\n * @author Matter Labs\n * @notice MessageRoot contract is responsible for storing and aggregating the roots of the batches from different chains into the MessageRoot.\n * @custom:security-contact security@matterlabs.dev\n */\ninterface IMessageRoot {\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function addNewChain(uint256 _chainId) external;\n\n    function addChainBatchRoot(uint256 _chainId, uint256 _batchNumber, bytes32 _chainBatchRoot) external;\n}\n"
      },
      "contracts/bridgehub/L1BridgehubErrors.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.21;\n\n// 0xa2ac02a0\nerror NotRelayedSender(address msgSender, address settlementLayerRelaySender);\n\n// 0xf306a770\nerror NotAssetRouter(address msgSender, address sharedBridge);\n\n// 0xff514c10\nerror ChainIdAlreadyPresent();\n\n// 0x4bd4ae07\nerror ChainNotPresentInCTM();\n\n// 0xfe919e28\nerror AssetIdAlreadyRegistered();\n\n// 0xc630ef3c\nerror CTMNotRegistered();\n\n// 0x4c0f5001\nerror ChainIdNotRegistered();\n\n// 0xb78dbaa7\nerror SecondBridgeAddressTooLow(address secondBridgeAddress, address minSecondBridgeAddress);\n\n// 0x472477e2\nerror NotInGatewayMode();\n\n// 0x90c7cbf1\nerror SLNotWhitelisted();\n\n// 0x48857c1d\nerror IncorrectChainAssetId(bytes32 assetId, bytes32 assetIdFromChainId);\n\n// 0xc0ca9182\nerror NotCurrentSL(uint256 settlementLayerChainId, uint256 blockChainId);\n\n// 0xeab895aa\nerror HyperchainNotRegistered();\n\n// 0xf5e39c1f\nerror IncorrectSender(address prevMsgSender, address chainAdmin);\n\n// 0x587df426\nerror AlreadyCurrentSL(uint256 blockChainId);\n\n// 0x65e8a019\nerror ChainExists();\n\n// 0x913183d8\nerror MessageRootNotRegistered();\n\n// 0x7f4316f3\nerror NoEthAllowed();\n\n// 0x23295f0e\nerror NotOwner(address sender, address owner);\n\n// 0x92626457\nerror WrongCounterPart(address addressOnCounterPart, address l2BridgehubAddress);\n\n// 0xecb34449\nerror NotL1(uint256 l1ChainId, uint256 blockChainId);\n\n// 0x527b87c7\nerror OnlyBridgehub(address msgSender, address bridgehub);\n\n// 0x73fe6c1b\nerror OnlyChain(address msgSender, address zkChainAddress);\n\n// 0x693cd3dc\nerror NotOwnerViaRouter(address msgSender, address originalCaller);\n\n// 0x5de72107\nerror ChainNotLegacy();\n"
      },
      "contracts/bridgehub/MessageRoot.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {DynamicIncrementalMerkle} from \"../common/libraries/DynamicIncrementalMerkle.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-v4/proxy/utils/Initializable.sol\";\n\nimport {IBridgehub} from \"./IBridgehub.sol\";\nimport {IMessageRoot} from \"./IMessageRoot.sol\";\nimport {OnlyBridgehub, OnlyChain, ChainExists, MessageRootNotRegistered} from \"./L1BridgehubErrors.sol\";\nimport {FullMerkle} from \"../common/libraries/FullMerkle.sol\";\n\nimport {MessageHashing} from \"../common/libraries/MessageHashing.sol\";\n\n// Chain tree consists of batch commitments as their leaves. We use hash of \"new bytes(96)\" as the hash of an empty leaf.\nbytes32 constant CHAIN_TREE_EMPTY_ENTRY_HASH = bytes32(\n    0x46700b4d40ac5c35af2c22dda2787a91eb567b06c924a8fb8ae9a05b20c08c21\n);\n\n// The single shared tree consists of the roots of chain trees as its leaves. We use hash of \"new bytes(96)\" as the hash of an empty leaf.\nbytes32 constant SHARED_ROOT_TREE_EMPTY_HASH = bytes32(\n    0x46700b4d40ac5c35af2c22dda2787a91eb567b06c924a8fb8ae9a05b20c08c21\n);\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev The MessageRoot contract is responsible for storing the cross message roots of the chains and the aggregated root of all chains.\ncontract MessageRoot is IMessageRoot, Initializable {\n    using FullMerkle for FullMerkle.FullTree;\n    using DynamicIncrementalMerkle for DynamicIncrementalMerkle.Bytes32PushTree;\n\n    event AddedChain(uint256 indexed chainId, uint256 indexed chainIndex);\n\n    event AppendedChainBatchRoot(uint256 indexed chainId, uint256 indexed batchNumber, bytes32 batchRoot);\n\n    event Preimage(bytes32 one, bytes32 two);\n\n    /// @dev Bridgehub smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication.\n    IBridgehub public immutable override BRIDGE_HUB;\n\n    /// @notice The number of chains that are registered.\n    uint256 public chainCount;\n\n    /// @notice The mapping from chainId to chainIndex. Note index 0 is maintained for the chain the contract is on.\n    mapping(uint256 chainId => uint256 chainIndex) public chainIndex;\n\n    /// @notice The mapping from chainIndex to chainId.\n    mapping(uint256 chainIndex => uint256 chainId) public chainIndexToId;\n\n    /// @notice The shared full merkle tree storing the aggregate hash.\n    FullMerkle.FullTree public sharedTree;\n\n    /// @dev The incremental merkle tree storing the chain message roots.\n    mapping(uint256 chainId => DynamicIncrementalMerkle.Bytes32PushTree tree) internal chainTree;\n\n    /// @notice only the bridgehub can call\n    modifier onlyBridgehub() {\n        if (msg.sender != address(BRIDGE_HUB)) {\n            revert OnlyBridgehub(msg.sender, address(BRIDGE_HUB));\n        }\n        _;\n    }\n\n    /// @notice only the bridgehub can call\n    /// @param _chainId the chainId of the chain\n    modifier onlyChain(uint256 _chainId) {\n        if (msg.sender != BRIDGE_HUB.getZKChain(_chainId)) {\n            revert OnlyChain(msg.sender, BRIDGE_HUB.getZKChain(_chainId));\n        }\n        _;\n    }\n\n    /// @dev Contract is expected to be used as proxy implementation on L1, but as a system contract on L2.\n    /// This means we call the _initialize in both the constructor and the initialize functions.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IBridgehub _bridgehub) {\n        BRIDGE_HUB = _bridgehub;\n        _initialize();\n        _disableInitializers();\n    }\n\n    /// @dev Initializes a contract for later use. Expected to be used in the proxy on L1, on L2 it is a system contract without a proxy.\n    function initialize() external initializer {\n        _initialize();\n    }\n\n    function addNewChain(uint256 _chainId) external onlyBridgehub {\n        if (chainRegistered(_chainId)) {\n            revert ChainExists();\n        }\n        _addNewChain(_chainId);\n    }\n\n    function chainRegistered(uint256 _chainId) public view returns (bool) {\n        return (_chainId == block.chainid || chainIndex[_chainId] != 0);\n    }\n\n    /// @dev add a new chainBatchRoot to the chainTree\n    function addChainBatchRoot(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        bytes32 _chainBatchRoot\n    ) external onlyChain(_chainId) {\n        if (!chainRegistered(_chainId)) {\n            revert MessageRootNotRegistered();\n        }\n        bytes32 chainRoot;\n        // slither-disable-next-line unused-return\n        (, chainRoot) = chainTree[_chainId].push(MessageHashing.batchLeafHash(_chainBatchRoot, _batchNumber));\n\n        // slither-disable-next-line unused-return\n        sharedTree.updateLeaf(chainIndex[_chainId], MessageHashing.chainIdLeafHash(chainRoot, _chainId));\n\n        emit Preimage(chainRoot, MessageHashing.chainIdLeafHash(chainRoot, _chainId));\n\n        emit AppendedChainBatchRoot(_chainId, _batchNumber, _chainBatchRoot);\n    }\n\n    /// @dev Gets the aggregated root of all chains.\n    function getAggregatedRoot() external view returns (bytes32) {\n        if (chainCount == 0) {\n            return SHARED_ROOT_TREE_EMPTY_HASH;\n        }\n        return sharedTree.root();\n    }\n\n    /// @dev Gets the message root of a single chain.\n    /// @param _chainId the chainId of the chain\n    function getChainRoot(uint256 _chainId) external view returns (bytes32) {\n        return chainTree[_chainId].root();\n    }\n\n    function updateFullTree() public {\n        uint256 cachedChainCount = chainCount;\n        bytes32[] memory newLeaves = new bytes32[](cachedChainCount);\n        for (uint256 i = 0; i < cachedChainCount; ++i) {\n            newLeaves[i] = MessageHashing.chainIdLeafHash(chainTree[chainIndexToId[i]].root(), chainIndexToId[i]);\n        }\n        // slither-disable-next-line unused-return\n        sharedTree.updateAllLeaves(newLeaves);\n    }\n\n    function _initialize() internal {\n        // slither-disable-next-line unused-return\n        sharedTree.setup(SHARED_ROOT_TREE_EMPTY_HASH);\n        _addNewChain(block.chainid);\n    }\n\n    /// @dev Adds a single chain to the message root.\n    /// @param _chainId the chainId of the chain\n    function _addNewChain(uint256 _chainId) internal {\n        uint256 cachedChainCount = chainCount;\n\n        // Since only the bridgehub can add new chains to the message root, it is expected that\n        // it will be responsible for ensuring that the number of chains does not exceed the limit.\n        ++chainCount;\n        chainIndex[_chainId] = cachedChainCount;\n        chainIndexToId[cachedChainCount] = _chainId;\n\n        // slither-disable-next-line unused-return\n        bytes32 initialHash = chainTree[_chainId].setup(CHAIN_TREE_EMPTY_ENTRY_HASH);\n\n        // slither-disable-next-line unused-return\n        sharedTree.pushNewLeaf(MessageHashing.chainIdLeafHash(initialHash, _chainId));\n\n        emit AddedChain(_chainId, cachedChainCount);\n    }\n}\n"
      },
      "contracts/common/Config.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\n/// @dev `keccak256(\"\")`\nbytes32 constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n/// @dev Bytes in raw L2 log\n/// @dev Equal to the bytes size of the tuple - (uint8 ShardId, bool isService, uint16 txNumberInBatch, address sender,\n/// bytes32 key, bytes32 value)\nuint256 constant L2_TO_L1_LOG_SERIALIZE_SIZE = 88;\n\n/// @dev The maximum length of the bytes array with L2 -> L1 logs\nuint256 constant MAX_L2_TO_L1_LOGS_COMMITMENT_BYTES = 4 + L2_TO_L1_LOG_SERIALIZE_SIZE * 512;\n\n/// @dev The value of default leaf hash for L2 -> L1 logs Merkle tree\n/// @dev An incomplete fixed-size tree is filled with this value to be a full binary tree\n/// @dev Actually equal to the `keccak256(new bytes(L2_TO_L1_LOG_SERIALIZE_SIZE))`\nbytes32 constant L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH = 0x72abee45b59e344af8a6e520241c4744aff26ed411f4c4b00f8af09adada43ba;\n\nbytes32 constant DEFAULT_L2_LOGS_TREE_ROOT_HASH = bytes32(0);\n\n/// @dev Denotes the type of the ZKsync transaction that came from L1.\nuint256 constant PRIORITY_OPERATION_L2_TX_TYPE = 255;\n\n/// @dev Denotes the type of the ZKsync transaction that is used for system upgrades.\nuint256 constant SYSTEM_UPGRADE_L2_TX_TYPE = 254;\n\n/// @dev The maximal allowed difference between protocol minor versions in an upgrade. The 100 gap is needed\n/// in case a protocol version has been tested on testnet, but then not launched on mainnet, e.g.\n/// due to a bug found.\n/// We are allowed to jump at most 100 minor versions at a time. The major version is always expected to be 0.\nuint256 constant MAX_ALLOWED_MINOR_VERSION_DELTA = 100;\n\n/// @dev The amount of time in seconds the validator has to process the priority transaction\n/// NOTE: The constant is set to zero for the Alpha release period\nuint256 constant PRIORITY_EXPIRATION = 0 days;\n\n/// @dev Timestamp - seconds since unix epoch.\nuint256 constant COMMIT_TIMESTAMP_NOT_OLDER = 3 days;\n\n/// @dev Maximum available error between real commit batch timestamp and analog used in the verifier (in seconds)\n/// @dev Must be used cause miner's `block.timestamp` value can differ on some small value (as we know - 12 seconds)\nuint256 constant COMMIT_TIMESTAMP_APPROXIMATION_DELTA = 1 hours;\n\n/// @dev Shift to apply to verify public input before verifying.\nuint256 constant PUBLIC_INPUT_SHIFT = 32;\n\n/// @dev The maximum number of L2 gas that a user can request for an L2 transaction\nuint256 constant MAX_GAS_PER_TRANSACTION = 80_000_000;\n\n/// @dev Even though the price for 1 byte of pubdata is 16 L1 gas, we have a slightly increased\n/// value.\nuint256 constant L1_GAS_PER_PUBDATA_BYTE = 17;\n\n/// @dev The intrinsic cost of the L1->l2 transaction in computational L2 gas\nuint256 constant L1_TX_INTRINSIC_L2_GAS = 167_157;\n\n/// @dev The intrinsic cost of the L1->l2 transaction in pubdata\nuint256 constant L1_TX_INTRINSIC_PUBDATA = 88;\n\n/// @dev The minimal base price for L1 transaction\nuint256 constant L1_TX_MIN_L2_GAS_BASE = 173_484;\n\n/// @dev The number of L2 gas the transaction starts costing more with each 544 bytes of encoding\nuint256 constant L1_TX_DELTA_544_ENCODING_BYTES = 1656;\n\n/// @dev The number of L2 gas an L1->L2 transaction gains with each new factory dependency\nuint256 constant L1_TX_DELTA_FACTORY_DEPS_L2_GAS = 2473;\n\n/// @dev The number of L2 gas an L1->L2 transaction gains with each new factory dependency\nuint256 constant L1_TX_DELTA_FACTORY_DEPS_PUBDATA = 64;\n\n/// @dev The number of pubdata an L1->L2 transaction requires with each new factory dependency\nuint256 constant MAX_NEW_FACTORY_DEPS = 64;\n\n/// @dev The L2 gasPricePerPubdata required to be used in bridges.\nuint256 constant REQUIRED_L2_GAS_PRICE_PER_PUBDATA = 800;\n\n/// @dev The mask which should be applied to the packed batch and L2 block timestamp in order\n/// to obtain the L2 block timestamp. Applying this mask is equivalent to calculating modulo 2**128\nuint256 constant PACKED_L2_BLOCK_TIMESTAMP_MASK = 0xffffffffffffffffffffffffffffffff;\n\n/// @dev Address of the point evaluation precompile used for EIP-4844 blob verification.\naddress constant POINT_EVALUATION_PRECOMPILE_ADDR = address(0x0A);\n\n/// @dev The overhead for a transaction slot in L2 gas.\n/// It is roughly equal to 80kk/MAX_TRANSACTIONS_IN_BATCH, i.e. how many gas would an L1->L2 transaction\n/// need to pay to compensate for the batch being closed.\n/// @dev It is expected that the L1 contracts will enforce that the L2 gas price will be high enough to compensate\n/// the operator in case the batch is closed because of tx slots filling up.\nuint256 constant TX_SLOT_OVERHEAD_L2_GAS = 10000;\n\n/// @dev The overhead for each byte of the bootloader memory that the encoding of the transaction.\n/// It is roughly equal to 80kk/BOOTLOADER_MEMORY_FOR_TXS, i.e. how many gas would an L1->L2 transaction\n/// need to pay to compensate for the batch being closed.\n/// @dev It is expected that the L1 contracts will enforce that the L2 gas price will be high enough to compensate\n/// the operator in case the batch is closed because of the memory for transactions being filled up.\nuint256 constant MEMORY_OVERHEAD_GAS = 10;\n\n/// @dev The maximum gas limit for a priority transaction in L2.\nuint256 constant PRIORITY_TX_MAX_GAS_LIMIT = 72_000_000;\n\n/// @dev the address used to identify eth as the base token for chains.\naddress constant ETH_TOKEN_ADDRESS = address(1);\n\n/// @dev the value returned in bridgehubDeposit in the TwoBridges function.\nbytes32 constant TWO_BRIDGES_MAGIC_VALUE = bytes32(uint256(keccak256(\"TWO_BRIDGES_MAGIC_VALUE\")) - 1);\n\n/// @dev https://eips.ethereum.org/EIPS/eip-1352\naddress constant BRIDGEHUB_MIN_SECOND_BRIDGE_ADDRESS = address(uint160(type(uint16).max));\n\n/// @dev the maximum number of supported chains, this is an arbitrary limit.\n/// @dev Note, that in case of a malicious Bridgehub admin, the total number of chains\n/// can be up to 2 times higher. This may be possible, in case the old ChainTypeManager\n/// had `100` chains and these were migrated to the Bridgehub only after `MAX_NUMBER_OF_ZK_CHAINS`\n/// were added to the bridgehub via creation of new chains.\nuint256 constant MAX_NUMBER_OF_ZK_CHAINS = 100;\n\n/// @dev Used as the `msg.sender` for transactions that relayed via a settlement layer.\naddress constant SETTLEMENT_LAYER_RELAY_SENDER = address(uint160(0x1111111111111111111111111111111111111111));\n\n/// @dev The metadata version that is supported by the ZK Chains to prove that an L2->L1 log was included in a batch.\nuint256 constant SUPPORTED_PROOF_METADATA_VERSION = 1;\n\n/// @dev The virtual address of the L1 settlement layer.\naddress constant L1_SETTLEMENT_LAYER_VIRTUAL_ADDRESS = address(\n    uint160(uint256(keccak256(\"L1_SETTLEMENT_LAYER_VIRTUAL_ADDRESS\")) - 1)\n);\n\nstruct PriorityTreeCommitment {\n    uint256 nextLeafIndex;\n    uint256 startIndex;\n    uint256 unprocessedIndex;\n    bytes32[] sides;\n}\n\n// Info that allows to restore a chain.\nstruct ZKChainCommitment {\n    /// @notice Total number of executed batches i.e. batches[totalBatchesExecuted] points at the latest executed batch\n    /// (batch 0 is genesis)\n    uint256 totalBatchesExecuted;\n    /// @notice Total number of proved batches i.e. batches[totalBatchesProved] points at the latest proved batch\n    uint256 totalBatchesVerified;\n    /// @notice Total number of committed batches i.e. batches[totalBatchesCommitted] points at the latest committed\n    /// batch\n    uint256 totalBatchesCommitted;\n    /// @notice The hash of the L2 system contracts ugpgrade transaction.\n    /// @dev It is non zero if the migration happens while the upgrade is not yet finalized.\n    bytes32 l2SystemContractsUpgradeTxHash;\n    /// @notice The batch when the system contracts upgrade transaction was executed.\n    /// @dev It is non-zero if the migration happens while the batch where the upgrade tx was present\n    /// has not been finalized (executed) yet.\n    uint256 l2SystemContractsUpgradeBatchNumber;\n    /// @notice The hashes of the batches that are needed to keep the blockchain working.\n    /// @dev The length of the array is equal to the `totalBatchesCommitted - totalBatchesExecuted + 1`, i.e. we need\n    /// to store all the unexecuted batches' hashes + 1 latest executed one.\n    bytes32[] batchHashes;\n    /// @notice Commitment to the priority merkle tree.\n    PriorityTreeCommitment priorityTree;\n    /// @notice Whether a chain is a permanent rollup.\n    bool isPermanentRollup;\n}\n"
      },
      "contracts/common/L1ContractErrors.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\n// 0x5ecf2d7a\nerror AccessToFallbackDenied(address target, address invoker);\n// 0x3995f750\nerror AccessToFunctionDenied(address target, bytes4 selector, address invoker);\n// 0x6c167909\nerror OnlySelfAllowed();\n// 0x52e22c98\nerror RestrictionWasNotPresent(address restriction);\n// 0xf126e113\nerror RestrictionWasAlreadyPresent(address restriction);\n// 0x3331e9c0\nerror CallNotAllowed(bytes call);\n// 0xf6fd7071\nerror RemovingPermanentRestriction();\n// 0xfcb9b2e1\nerror UnallowedImplementation(bytes32 implementationHash);\n// 0x1ff9d522\nerror AddressAlreadyUsed(address addr);\n// 0x0dfb42bf\nerror AddressAlreadySet(address addr);\n// 0x86bb51b8\nerror AddressHasNoCode(address);\n// 0x1f73225f\nerror AddressMismatch(address expected, address supplied);\n// 0x5e85ae73\nerror AmountMustBeGreaterThanZero();\n// 0xfde974f4\nerror AssetHandlerDoesNotExist(bytes32 assetId);\n// 0x1294e9e1\nerror AssetIdMismatch(bytes32 expected, bytes32 supplied);\n// 0xfe919e28\nerror AssetIdAlreadyRegistered();\n// 0x0bfcef28\nerror AlreadyWhitelisted(address);\n// 0x04a0b7e9\nerror AssetIdNotSupported(bytes32 assetId);\n// 0x6ef9a972\nerror BaseTokenGasPriceDenominatorNotSet();\n// 0x55ad3fd3\nerror BatchHashMismatch(bytes32 expected, bytes32 actual);\n// 0x2078a6a0\nerror BatchNotExecuted(uint256 batchNumber);\n// 0xbd4455ff\nerror BatchNumberMismatch(uint256 expectedBatchNumber, uint256 providedBatchNumber);\n// 0x6cf12312\nerror BridgeHubAlreadyRegistered();\n// 0xdb538614\nerror BridgeMintNotImplemented();\n// 0xe85392f9\nerror CanOnlyProcessOneBatch();\n// 0x00c6ead2\nerror CantExecuteUnprovenBatches();\n// 0xe18cb383\nerror CantRevertExecutedBatch();\n// 0x24591d89\nerror ChainIdAlreadyExists();\n// 0x717a1656\nerror ChainIdCantBeCurrentChain();\n// 0xa179f8c9\nerror ChainIdMismatch();\n// 0x23f3c357\nerror ChainIdNotRegistered(uint256 chainId);\n// 0x8f620a06\nerror ChainIdTooBig();\n// 0xf7a01e4d\nerror DelegateCallFailed(bytes returnData);\n// 0x0a8ed92c\nerror DenominatorIsZero();\n// 0xb4f54111\nerror DeployFailed();\n// 0x138ee1a3\nerror DeployingBridgedTokenForNativeToken();\n// 0xc7c9660f\nerror DepositDoesNotExist();\n// 0xad2fa98e\nerror DepositExists();\n// 0x0e7ee319\nerror DiamondAlreadyFrozen();\n// 0xa7151b9a\nerror DiamondNotFrozen();\n// 0x7138356f\nerror EmptyAddress();\n// 0x2d4d012f\nerror EmptyAssetId();\n// 0x1c25715b\nerror EmptyBytes32();\n// 0x95b66fe9\nerror EmptyDeposit();\n// 0x627e0872\nerror ETHDepositNotSupported();\n// 0xac4a3f98\nerror FacetExists(bytes4 selector, address);\n// 0xc91cf3b1\nerror GasPerPubdataMismatch();\n// 0x6d4a7df8\nerror GenesisBatchCommitmentZero();\n// 0x7940c83f\nerror GenesisBatchHashZero();\n// 0xb4fc6835\nerror GenesisIndexStorageZero();\n// 0x3a1a8589\nerror GenesisUpgradeZero();\n// 0xd356e6ba\nerror HashedLogIsDefault();\n// 0x0b08d5be\nerror HashMismatch(bytes32 expected, bytes32 actual);\n// 0x601b6882\nerror ZKChainLimitReached();\n// 0xdd381a4c\nerror IncorrectBridgeHubAddress(address bridgehub);\n// 0x826fb11e\nerror InsufficientChainBalance();\n// 0xcbd9d2e0\nerror InvalidCaller(address);\n// 0x4fbe5dba\nerror InvalidDelay();\n// 0xc1780bd6\nerror InvalidLogSender(address sender, uint256 logKey);\n// 0xd8e9405c\nerror InvalidNumberOfBlobs(uint256 expected, uint256 numCommitments, uint256 numHashes);\n// 0x09bde339\nerror InvalidProof();\n// 0x5428eae7\nerror InvalidProtocolVersion();\n// 0x5513177c\nerror InvalidPubdataHash(bytes32 expectedHash, bytes32 provided);\n// 0x6f1cf752\nerror InvalidPubdataPricingMode();\n// 0x12ba286f\nerror InvalidSelector(bytes4 func);\n// 0x5cb29523\nerror InvalidTxType(uint256 txType);\n// 0x0214acb6\nerror InvalidUpgradeTxn(UpgradeTxVerifyParam);\n// 0xfb5c22e6\nerror L2TimestampTooBig();\n// 0xd2c011d6\nerror L2UpgradeNonceNotEqualToNewProtocolVersion(uint256 nonce, uint256 protocolVersion);\n// 0x97e1359e\nerror L2WithdrawalMessageWrongLength(uint256 messageLen);\n// 0xe37d2c02\nerror LengthIsNotDivisibleBy32(uint256 length);\n// 0x1b6825bb\nerror LogAlreadyProcessed(uint8);\n// 0xcea34703\nerror MalformedBytecode(BytecodeError);\n// 0x9bb54c35\nerror MerkleIndexOutOfBounds();\n// 0x8e23ac1a\nerror MerklePathEmpty();\n// 0x1c500385\nerror MerklePathOutOfBounds();\n// 0x3312a450\nerror MigrationPaused();\n// 0xfa44b527\nerror MissingSystemLogs(uint256 expected, uint256 actual);\n// 0x4a094431\nerror MsgValueMismatch(uint256 expectedMsgValue, uint256 providedMsgValue);\n// 0xb385a3da\nerror MsgValueTooLow(uint256 required, uint256 provided);\n// 0x72ea85ad\nerror NewProtocolMajorVersionNotZero();\n// 0x79cc2d22\nerror NoCallsProvided();\n// 0xa6fef710\nerror NoFunctionsForDiamondCut();\n// 0xcab098d8\nerror NoFundsTransferred();\n// 0xc21b1ab7\nerror NonEmptyCalldata();\n// 0x536ec84b\nerror NonEmptyMsgValue();\n// 0xd018e08e\nerror NonIncreasingTimestamp();\n// 0x0105f9c0\nerror NonSequentialBatch();\n// 0x0ac76f01\nerror NonSequentialVersion();\n// 0xdd629f86\nerror NotEnoughGas();\n// 0xdd7e3621\nerror NotInitializedReentrancyGuard();\n// 0xdf17e316\nerror NotWhitelisted(address);\n// 0xf3ed9dfa\nerror OnlyEraSupported();\n// 0x1a21feed\nerror OperationExists();\n// 0xeda2fbb1\nerror OperationMustBePending();\n// 0xe1c1ff37\nerror OperationMustBeReady();\n// 0xb926450e\nerror OriginChainIdNotFound();\n// 0xd7f50a9d\nerror PatchCantSetUpgradeTxn();\n// 0x962fd7d0\nerror PatchUpgradeCantSetBootloader();\n// 0x559cc34e\nerror PatchUpgradeCantSetDefaultAccount();\n// 0x9b48e060\nerror PreviousOperationNotExecuted();\n// 0x5c598b60\nerror PreviousProtocolMajorVersionNotZero();\n// 0xa0f47245\nerror PreviousUpgradeNotCleaned();\n// 0x101ba748\nerror PreviousUpgradeNotFinalized(bytes32 txHash);\n// 0xd5a99014\nerror PriorityOperationsRollingHashMismatch();\n// 0x1a4d284a\nerror PriorityTxPubdataExceedsMaxPubDataPerBatch();\n// 0xa461f651\nerror ProtocolIdMismatch(uint256 expectedProtocolVersion, uint256 providedProtocolId);\n// 0x64f94ec2\nerror ProtocolIdNotGreater();\n// 0xd328c12a\nerror ProtocolVersionMinorDeltaTooBig(uint256 limit, uint256 proposed);\n// 0x88d7b498\nerror ProtocolVersionTooSmall();\n// 0x53dee67b\nerror PubdataCommitmentsEmpty();\n// 0x959f26fb\nerror PubdataGreaterThanLimit(uint256 limit, uint256 length);\n// 0x63c36549\nerror QueueIsEmpty();\n// 0xab143c06\nerror Reentrancy();\n// 0x667d17de\nerror RemoveFunctionFacetAddressNotZero(address facet);\n// 0xa2d4b16c\nerror RemoveFunctionFacetAddressZero();\n// 0x3580370c\nerror ReplaceFunctionFacetAddressZero();\n// 0x9a67c1cb\nerror RevertedBatchNotAfterNewLastBatch();\n// 0xd3b6535b\nerror SelectorsMustAllHaveSameFreezability();\n// 0xd7a6b5e6\nerror SharedBridgeValueNotSet(SharedBridgeKey);\n// 0x856d5b77\nerror SharedBridgeNotSet();\n// 0xdf3a8fdd\nerror SlotOccupied();\n// 0xec273439\nerror CTMAlreadyRegistered();\n// 0xc630ef3c\nerror CTMNotRegistered();\n// 0xae43b424\nerror SystemLogsSizeTooBig();\n// 0x08753982\nerror TimeNotReached(uint256 expectedTimestamp, uint256 actualTimestamp);\n// 0x2d50c33b\nerror TimestampError();\n// 0x06439c6b\nerror TokenNotSupported(address token);\n// 0x23830e28\nerror TokensWithFeesNotSupported();\n// 0x76da24b9\nerror TooManyFactoryDeps();\n// 0xf0b4e88f\nerror TooMuchGas();\n// 0x00c5a6a9\nerror TransactionNotAllowed();\n// 0x4c991078\nerror TxHashMismatch();\n// 0x2e311df8\nerror TxnBodyGasLimitNotEnoughGas();\n// 0x8e4a23d6\nerror Unauthorized(address caller);\n// 0xe52478c7\nerror UndefinedDiamondCutAction();\n// 0x6aa39880\nerror UnexpectedSystemLog(uint256 logKey);\n// 0xf093c2e5\nerror UpgradeBatchNumberIsNotZero();\n// 0x084a1449\nerror UnsupportedEncodingVersion();\n// 0x47b3b145\nerror ValidateTxnNotEnoughGas();\n// 0x626ade30\nerror ValueMismatch(uint256 expected, uint256 actual);\n// 0xe1022469\nerror VerifiedBatchesExceedsCommittedBatches();\n// 0xae899454\nerror WithdrawalAlreadyFinalized();\n// 0x750b219c\nerror WithdrawFailed();\n// 0x15e8e429\nerror WrongMagicValue(uint256 expectedMagicValue, uint256 providedMagicValue);\n// 0xd92e233d\nerror ZeroAddress();\n// 0xc84885d4\nerror ZeroChainId();\n// 0x99d8fec9\nerror EmptyData();\n// 0xf3dd1b9c\nerror UnsupportedCommitBatchEncoding(uint8 version);\n// 0xf338f830\nerror UnsupportedProofBatchEncoding(uint8 version);\n// 0x14d2ed8a\nerror UnsupportedExecuteBatchEncoding(uint8 version);\n// 0xd7d93e1f\nerror IncorrectBatchBounds(\n    uint256 processFromExpected,\n    uint256 processToExpected,\n    uint256 processFromProvided,\n    uint256 processToProvided\n);\n// 0x64107968\nerror AssetHandlerNotRegistered(bytes32 assetId);\n// 0x64846fe4\nerror NotARestriction(address addr);\n// 0xfa5cd00f\nerror NotAllowed(address addr);\n// 0xccdd18d2\nerror BytecodeAlreadyPublished(bytes32 bytecodeHash);\n// 0x25d8333c\nerror CallerNotTimerAdmin();\n// 0x907f8e51\nerror DeadlineNotYetPassed();\n// 0x6eef58d1\nerror NewDeadlineNotGreaterThanCurrent();\n// 0x8b7e144a\nerror NewDeadlineExceedsMaxDeadline();\n// 0x2a5989a0\nerror AlreadyPermanentRollup();\n// 0x92daded2\nerror InvalidDAForPermanentRollup();\n// 0xd0266e26\nerror NotSettlementLayer();\n// 0x7a4902ad\nerror TimerAlreadyStarted();\n\n// 0x09aa9830\nerror MerklePathLengthMismatch(uint256 pathLength, uint256 expectedLength);\n\n// 0xc33e6128\nerror MerkleNothingToProve();\n\n// 0xafbb7a4e\nerror MerkleIndexOrHeightMismatch();\n\n// 0x1b582fcf\nerror MerkleWrongIndex(uint256 index, uint256 maxNodeNumber);\n\n// 0x485cfcaa\nerror MerkleWrongLength(uint256 newLeavesLength, uint256 leafNumber);\n\n// 0xce63ce17\nerror NoCTMForAssetId(bytes32 assetId);\n// 0x02181a13\nerror SettlementLayersMustSettleOnL1();\n// 0x1850b46b\nerror TokenNotLegacy();\n// 0x1929b7de\nerror IncorrectTokenAddressFromNTV(bytes32 assetId, address tokenAddress);\n// 0x48c5fa28\nerror InvalidProofLengthForFinalNode();\n// 0x7acd7817\nerror TokenIsNotLegacy();\n// 0xfade089a\nerror LegacyEncodingUsedForNonL1Token();\n// 0xa51fa558\nerror TokenIsLegacy();\n// 0x29963361\nerror LegacyBridgeUsesNonNativeToken();\n// 0x11832de8\nerror AssetRouterAllowanceNotZero();\n// 0xaa5f6180\nerror BurningNativeWETHNotSupported();\n// 0xb20b58ce\nerror NoLegacySharedBridge();\n// 0x8e3ce3cb\nerror TooHighDeploymentNonce();\n// 0x78d2ed02\nerror ChainAlreadyLive();\n// 0x4e98b356\nerror MigrationsNotPaused();\n// 0xf20c5c2a\nerror WrappedBaseTokenAlreadyRegistered();\n\n// 0xde4c0b96\nerror InvalidNTVBurnData();\n// 0xbe7193d4\nerror InvalidSystemLogsLength();\n// 0x8efef97a\nerror LegacyBridgeNotSet();\n// 0x767eed08\nerror LegacyMethodForNonL1Token();\n\nenum SharedBridgeKey {\n    PostUpgradeFirstBatch,\n    LegacyBridgeFirstBatch,\n    LegacyBridgeLastDepositBatch,\n    LegacyBridgeLastDepositTxn\n}\n\nenum BytecodeError {\n    Version,\n    NumberOfWords,\n    Length,\n    WordsMustBeOdd\n}\n\nenum UpgradeTxVerifyParam {\n    From,\n    To,\n    Paymaster,\n    Value,\n    MaxFeePerGas,\n    MaxPriorityFeePerGas,\n    Reserved0,\n    Reserved1,\n    Reserved2,\n    Reserved3,\n    Signature,\n    PaymasterInput,\n    ReservedDynamic\n}\n"
      },
      "contracts/common/L2ContractAddresses.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\n/// @dev The formal address of the initial program of the system: the bootloader\naddress constant L2_BOOTLOADER_ADDRESS = address(0x8001);\n\n/// @dev The address of the known code storage system contract\naddress constant L2_KNOWN_CODE_STORAGE_SYSTEM_CONTRACT_ADDR = address(0x8004);\n\n/// @dev The address of the L2 deployer system contract.\naddress constant L2_DEPLOYER_SYSTEM_CONTRACT_ADDR = address(0x8006);\n\n/// @dev The special reserved L2 address. It is located in the system contracts space but doesn't have deployed\n/// bytecode.\n/// @dev The L2 deployer system contract allows changing bytecodes on any address if the `msg.sender` is this address.\n/// @dev So, whenever the governor wants to redeploy system contracts, it just initiates the L1 upgrade call deployer\n/// system contract\n/// via the L1 -> L2 transaction with `sender == L2_FORCE_DEPLOYER_ADDR`. For more details see the\n/// `diamond-initializers` contracts.\naddress constant L2_FORCE_DEPLOYER_ADDR = address(0x8007);\n\n/// @dev The address of the special smart contract that can send arbitrary length message as an L2 log\naddress constant L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR = address(0x8008);\n\n/// @dev The address of the eth token system contract\naddress constant L2_BASE_TOKEN_SYSTEM_CONTRACT_ADDR = address(0x800a);\n\n/// @dev The address of the context system contract\naddress constant L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR = address(0x800b);\n\n/// @dev The address of the pubdata chunk publisher contract\naddress constant L2_PUBDATA_CHUNK_PUBLISHER_ADDR = address(0x8011);\n\n/// @dev The address used to execute complex upgragedes, also used for the genesis upgrade\naddress constant L2_COMPLEX_UPGRADER_ADDR = address(0x800f);\n\n/// @dev The address used to execute the genesis upgrade\naddress constant L2_GENESIS_UPGRADE_ADDR = address(0x10001);\n\n/// @dev The address of the L2 bridge hub system contract, used to start L1->L2 transactions\naddress constant L2_BRIDGEHUB_ADDR = address(0x10002);\n\n/// @dev the address of the l2 asset router.\naddress constant L2_ASSET_ROUTER_ADDR = address(0x10003);\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Smart contract for sending arbitrary length messages to L1\n * @dev by default ZkSync can send fixed-length messages on L1.\n * A fixed length message has 4 parameters `senderAddress`, `isService`, `key`, `value`,\n * the first one is taken from the context, the other three are chosen by the sender.\n * @dev To send a variable-length message we use this trick:\n * - This system contract accepts an arbitrary length message and sends a fixed length message with\n * parameters `senderAddress == this`, `isService == true`, `key == msg.sender`, `value == keccak256(message)`.\n * - The contract on L1 accepts all sent messages and if the message came from this system contract\n * it requires that the preimage of `value` be provided.\n */\ninterface IL2Messenger {\n    /// @notice Sends an arbitrary length message to L1.\n    /// @param _message The variable length message to be sent to L1.\n    /// @return Returns the keccak256 hashed value of the message.\n    function sendToL1(bytes calldata _message) external returns (bytes32);\n}\n\n/// @dev An l2 system contract address, used in the assetId calculation for native assets.\n/// This is needed for automatic bridging, i.e. without deploying the AssetHandler contract,\n/// if the assetId can be calculated with this address then it is in fact an NTV asset\naddress constant L2_NATIVE_TOKEN_VAULT_ADDR = address(0x10004);\n\n/// @dev the address of the l2 asset router.\naddress constant L2_MESSAGE_ROOT_ADDR = address(0x10005);\n\n/// @dev the offset for the system contracts\nuint160 constant SYSTEM_CONTRACTS_OFFSET = 0x8000; // 2^15\n\n/// @dev the address of the l2 messenger system contract\nIL2Messenger constant L2_MESSENGER = IL2Messenger(address(SYSTEM_CONTRACTS_OFFSET + 0x08));\n\n/// @dev the address of the msg value system contract\naddress constant MSG_VALUE_SYSTEM_CONTRACT = address(SYSTEM_CONTRACTS_OFFSET + 0x09);\n"
      },
      "contracts/common/Messaging.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\n/// @dev The enum that represents the transaction execution status\n/// @param Failure The transaction execution failed\n/// @param Success The transaction execution succeeded\nenum TxStatus {\n    Failure,\n    Success\n}\n\n/// @dev The log passed from L2\n/// @param l2ShardId The shard identifier, 0 - rollup, 1 - porter\n/// All other values are not used but are reserved for the future\n/// @param isService A boolean flag that is part of the log along with `key`, `value`, and `sender` address.\n/// This field is required formally but does not have any special meaning\n/// @param txNumberInBatch The L2 transaction number in a Batch, in which the log was sent\n/// @param sender The L2 address which sent the log\n/// @param key The 32 bytes of information that was sent in the log\n/// @param value The 32 bytes of information that was sent in the log\n// Both `key` and `value` are arbitrary 32-bytes selected by the log sender\nstruct L2Log {\n    uint8 l2ShardId;\n    bool isService;\n    uint16 txNumberInBatch;\n    address sender;\n    bytes32 key;\n    bytes32 value;\n}\n\n/// @dev An arbitrary length message passed from L2\n/// @notice Under the hood it is `L2Log` sent from the special system L2 contract\n/// @param txNumberInBatch The L2 transaction number in a Batch, in which the message was sent\n/// @param sender The address of the L2 account from which the message was passed\n/// @param data An arbitrary length message\nstruct L2Message {\n    uint16 txNumberInBatch;\n    address sender;\n    bytes data;\n}\n\n/// @dev Internal structure that contains the parameters for the writePriorityOp\n/// internal function.\n/// @param txId The id of the priority transaction.\n/// @param l2GasPrice The gas price for the l2 priority operation.\n/// @param expirationTimestamp The timestamp by which the priority operation must be processed by the operator.\n/// @param request The external calldata request for the priority operation.\nstruct WritePriorityOpParams {\n    uint256 txId;\n    uint256 l2GasPrice;\n    uint64 expirationTimestamp;\n    BridgehubL2TransactionRequest request;\n}\n\n/// @dev Structure that includes all fields of the L2 transaction\n/// @dev The hash of this structure is the \"canonical L2 transaction hash\" and can\n/// be used as a unique identifier of a tx\n/// @param txType The tx type number, depending on which the L2 transaction can be\n/// interpreted differently\n/// @param from The sender's address. `uint256` type for possible address format changes\n/// and maintaining backward compatibility\n/// @param to The recipient's address. `uint256` type for possible address format changes\n/// and maintaining backward compatibility\n/// @param gasLimit The L2 gas limit for L2 transaction. Analog to the `gasLimit` on an\n/// L1 transactions\n/// @param gasPerPubdataByteLimit Maximum number of L2 gas that will cost one byte of pubdata\n/// (every piece of data that will be stored on L1 as calldata)\n/// @param maxFeePerGas The absolute maximum sender willing to pay per unit of L2 gas to get\n/// the transaction included in a Batch. Analog to the EIP-1559 `maxFeePerGas` on an L1 transactions\n/// @param maxPriorityFeePerGas The additional fee that is paid directly to the validator\n/// to incentivize them to include the transaction in a Batch. Analog to the EIP-1559\n/// `maxPriorityFeePerGas` on an L1 transactions\n/// @param paymaster The address of the EIP-4337 paymaster, that will pay fees for the\n/// transaction. `uint256` type for possible address format changes and maintaining backward compatibility\n/// @param nonce The nonce of the transaction. For L1->L2 transactions it is the priority\n/// operation Id\n/// @param value The value to pass with the transaction\n/// @param reserved The fixed-length fields for usage in a future extension of transaction\n/// formats\n/// @param data The calldata that is transmitted for the transaction call\n/// @param signature An abstract set of bytes that are used for transaction authorization\n/// @param factoryDeps The set of L2 bytecode hashes whose preimages were shown on L1\n/// @param paymasterInput The arbitrary-length data that is used as a calldata to the paymaster pre-call\n/// @param reservedDynamic The arbitrary-length field for usage in a future extension of transaction formats\nstruct L2CanonicalTransaction {\n    uint256 txType;\n    uint256 from;\n    uint256 to;\n    uint256 gasLimit;\n    uint256 gasPerPubdataByteLimit;\n    uint256 maxFeePerGas;\n    uint256 maxPriorityFeePerGas;\n    uint256 paymaster;\n    uint256 nonce;\n    uint256 value;\n    // In the future, we might want to add some\n    // new fields to the struct. The `txData` struct\n    // is to be passed to account and any changes to its structure\n    // would mean a breaking change to these accounts. To prevent this,\n    // we should keep some fields as \"reserved\"\n    // It is also recommended that their length is fixed, since\n    // it would allow easier proof integration (in case we will need\n    // some special circuit for preprocessing transactions)\n    uint256[4] reserved;\n    bytes data;\n    bytes signature;\n    uint256[] factoryDeps;\n    bytes paymasterInput;\n    // Reserved dynamic type for the future use-case. Using it should be avoided,\n    // But it is still here, just in case we want to enable some additional functionality\n    bytes reservedDynamic;\n}\n\n/// @param sender The sender's address.\n/// @param contractAddressL2 The address of the contract on L2 to call.\n/// @param valueToMint The amount of base token that should be minted on L2 as the result of this transaction.\n/// @param l2Value The msg.value of the L2 transaction.\n/// @param l2Calldata The calldata for the L2 transaction.\n/// @param l2GasLimit The limit of the L2 gas for the L2 transaction\n/// @param l2GasPerPubdataByteLimit The price for a single pubdata byte in L2 gas.\n/// @param factoryDeps The array of L2 bytecodes that the tx depends on.\n/// @param refundRecipient The recipient of the refund for the transaction on L2. If the transaction fails, then\n/// this address will receive the `l2Value`.\n// solhint-disable-next-line gas-struct-packing\nstruct BridgehubL2TransactionRequest {\n    address sender;\n    address contractL2;\n    uint256 mintValue;\n    uint256 l2Value;\n    bytes l2Calldata;\n    uint256 l2GasLimit;\n    uint256 l2GasPerPubdataByteLimit;\n    bytes[] factoryDeps;\n    address refundRecipient;\n}\n"
      },
      "contracts/common/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {SlotOccupied, NotInitializedReentrancyGuard, Reentrancy} from \"./L1ContractErrors.sol\";\n\n/**\n * @custom:security-contact security@matterlabs.dev\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\n * metering changes introduced in the Istanbul hardfork.\n */\nabstract contract ReentrancyGuard {\n    /// @dev Address of lock flag variable.\n    /// @dev Flag is placed at random memory location to not interfere with Storage contract.\n    // keccak256(\"ReentrancyGuard\") - 1;\n    uint256 private constant LOCK_FLAG_ADDRESS = 0x8e94fed44239eb2314ab7a406345e6c5a8f0ccedf3b600de3d004e672c33abf4;\n\n    // solhint-disable-next-line max-line-length\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/security/ReentrancyGuard.sol\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    modifier reentrancyGuardInitializer() {\n        _initializeReentrancyGuard();\n        _;\n    }\n\n    function _initializeReentrancyGuard() private {\n        uint256 lockSlotOldValue;\n\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive but in exchange every call to nonReentrant\n        // will be cheaper.\n        assembly {\n            lockSlotOldValue := sload(LOCK_FLAG_ADDRESS)\n            sstore(LOCK_FLAG_ADDRESS, _NOT_ENTERED)\n        }\n\n        // Check that storage slot for reentrancy guard is empty to rule out possibility of slot conflict\n        if (lockSlotOldValue != 0) {\n            revert SlotOccupied();\n        }\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        uint256 _status;\n        assembly {\n            _status := sload(LOCK_FLAG_ADDRESS)\n        }\n\n        if (_status == 0) {\n            revert NotInitializedReentrancyGuard();\n        }\n        // On the first call to nonReentrant, _NOT_ENTERED will be true\n        if (_status != _NOT_ENTERED) {\n            revert Reentrancy();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        assembly {\n            sstore(LOCK_FLAG_ADDRESS, _ENTERED)\n        }\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        assembly {\n            sstore(LOCK_FLAG_ADDRESS, _NOT_ENTERED)\n        }\n    }\n}\n"
      },
      "contracts/common/interfaces/IL1Messenger.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice The interface of the L1 Messenger contract, responsible for sending messages to L1.\n */\ninterface IL1Messenger {\n    function sendToL1(bytes calldata _message) external returns (bytes32);\n}\n"
      },
      "contracts/common/interfaces/IL2ContractDeployer.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\n/**\n * @author Matter Labs\n * @notice System smart contract that is responsible for deploying other smart contracts on a ZK chain.\n */\ninterface IL2ContractDeployer {\n    /// @notice A struct that describes a forced deployment on an address.\n    /// @param bytecodeHash The bytecode hash to put on an address.\n    /// @param newAddress The address on which to deploy the bytecodehash to.\n    /// @param callConstructor Whether to run the constructor on the force deployment.\n    /// @param value The `msg.value` with which to initialize a contract.\n    /// @param input The constructor calldata.\n    struct ForceDeployment {\n        bytes32 bytecodeHash;\n        address newAddress;\n        bool callConstructor;\n        uint256 value;\n        bytes input;\n    }\n\n    /// @notice This method is to be used only during an upgrade to set bytecodes on specific addresses.\n    function forceDeployOnAddresses(ForceDeployment[] calldata _deployParams) external;\n\n    /// @notice Deploys a contract with similar address derivation rules to the EVM's `CREATE2` opcode.\n    /// @param _salt The create2 salt.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata.\n    function create2(bytes32 _salt, bytes32 _bytecodeHash, bytes calldata _input) external;\n}\n"
      },
      "contracts/common/libraries/DataEncoding.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {L2_NATIVE_TOKEN_VAULT_ADDR} from \"../L2ContractAddresses.sol\";\nimport {LEGACY_ENCODING_VERSION, NEW_ENCODING_VERSION} from \"../../bridge/asset-router/IAssetRouterBase.sol\";\nimport {INativeTokenVault} from \"../../bridge/ntv/INativeTokenVault.sol\";\nimport {IncorrectTokenAddressFromNTV, UnsupportedEncodingVersion, InvalidNTVBurnData} from \"../L1ContractErrors.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Helper library for transfer data encoding and decoding to reduce possibility of errors.\n */\nlibrary DataEncoding {\n    /// @notice Abi.encodes the data required for bridgeBurn for NativeTokenVault.\n    /// @param _amount The amount of token to be transferred.\n    /// @param _remoteReceiver The address which to receive tokens on remote chain.\n    /// @param _maybeTokenAddress The helper field that should be either equal to 0 (in this case\n    /// it is assumed that the token has been registered within NativeTokenVault already) or it\n    /// can be equal to the address of the token on the current chain. Providing non-zero address\n    /// allows it to be automatically registered in case it is not yet a part of NativeTokenVault.\n    /// @return The encoded bridgeBurn data\n    function encodeBridgeBurnData(\n        uint256 _amount,\n        address _remoteReceiver,\n        address _maybeTokenAddress\n    ) internal pure returns (bytes memory) {\n        return abi.encode(_amount, _remoteReceiver, _maybeTokenAddress);\n    }\n\n    /// @notice Function decoding bridgeBurn data previously encoded with this library.\n    /// @param _data The encoded data for bridgeBurn\n    /// @return amount The amount of token to be transferred.\n    /// @return receiver The address which to receive tokens on remote chain.\n    /// @return maybeTokenAddress The helper field that should be either equal to 0 (in this case\n    /// it is assumed that the token has been registered within NativeTokenVault already) or it\n    /// can be equal to the address of the token on the current chain. Providing non-zero address\n    /// allows it to be automatically registered in case it is not yet a part of NativeTokenVault.\n    function decodeBridgeBurnData(\n        bytes memory _data\n    ) internal pure returns (uint256 amount, address receiver, address maybeTokenAddress) {\n        if (_data.length != 96) {\n            // For better error handling\n            revert InvalidNTVBurnData();\n        }\n\n        (amount, receiver, maybeTokenAddress) = abi.decode(_data, (uint256, address, address));\n    }\n\n    /// @notice Abi.encodes the data required for bridgeMint on remote chain.\n    /// @param _originalCaller The address which initiated the transfer.\n    /// @param _remoteReceiver The address which to receive tokens on remote chain.\n    /// @param _originToken The transferred token address.\n    /// @param _amount The amount of token to be transferred.\n    /// @param _erc20Metadata The transferred token metadata.\n    /// @return The encoded bridgeMint data\n    function encodeBridgeMintData(\n        address _originalCaller,\n        address _remoteReceiver,\n        address _originToken,\n        uint256 _amount,\n        bytes memory _erc20Metadata\n    ) internal pure returns (bytes memory) {\n        // solhint-disable-next-line func-named-parameters\n        return abi.encode(_originalCaller, _remoteReceiver, _originToken, _amount, _erc20Metadata);\n    }\n\n    /// @notice Function decoding transfer data previously encoded with this library.\n    /// @param _bridgeMintData The encoded bridgeMint data\n    /// @return _originalCaller The address which initiated the transfer.\n    /// @return _remoteReceiver The address which to receive tokens on remote chain.\n    /// @return _parsedOriginToken The transferred token address.\n    /// @return _amount The amount of token to be transferred.\n    /// @return _erc20Metadata The transferred token metadata.\n    function decodeBridgeMintData(\n        bytes memory _bridgeMintData\n    )\n        internal\n        pure\n        returns (\n            address _originalCaller,\n            address _remoteReceiver,\n            address _parsedOriginToken,\n            uint256 _amount,\n            bytes memory _erc20Metadata\n        )\n    {\n        (_originalCaller, _remoteReceiver, _parsedOriginToken, _amount, _erc20Metadata) = abi.decode(\n            _bridgeMintData,\n            (address, address, address, uint256, bytes)\n        );\n    }\n\n    /// @notice Encodes the asset data by combining chain id, asset deployment tracker and asset data.\n    /// @param _chainId The id of the chain token is native to.\n    /// @param _assetData The asset data that has to be encoded.\n    /// @param _sender The asset deployment tracker address.\n    /// @return The encoded asset data.\n    function encodeAssetId(uint256 _chainId, bytes32 _assetData, address _sender) internal pure returns (bytes32) {\n        return keccak256(abi.encode(_chainId, _sender, _assetData));\n    }\n\n    /// @notice Encodes the asset data by combining chain id, asset deployment tracker and asset data.\n    /// @param _chainId The id of the chain token is native to.\n    /// @param _tokenAddress The address of token that has to be encoded (asset data is the address itself).\n    /// @param _sender The asset deployment tracker address.\n    /// @return The encoded asset data.\n    function encodeAssetId(uint256 _chainId, address _tokenAddress, address _sender) internal pure returns (bytes32) {\n        return keccak256(abi.encode(_chainId, _sender, _tokenAddress));\n    }\n\n    /// @notice Encodes the asset data by combining chain id, NTV as asset deployment tracker and asset data.\n    /// @param _chainId The id of the chain token is native to.\n    /// @param _assetData The asset data that has to be encoded.\n    /// @return The encoded asset data.\n    function encodeNTVAssetId(uint256 _chainId, bytes32 _assetData) internal pure returns (bytes32) {\n        return keccak256(abi.encode(_chainId, L2_NATIVE_TOKEN_VAULT_ADDR, _assetData));\n    }\n\n    /// @notice Encodes the asset data by combining chain id, NTV as asset deployment tracker and token address.\n    /// @param _chainId The id of the chain token is native to.\n    /// @param _tokenAddress The address of token that has to be encoded (asset data is the address itself).\n    /// @return The encoded asset data.\n    function encodeNTVAssetId(uint256 _chainId, address _tokenAddress) internal pure returns (bytes32) {\n        return keccak256(abi.encode(_chainId, L2_NATIVE_TOKEN_VAULT_ADDR, _tokenAddress));\n    }\n\n    /// @dev Encodes the transaction data hash using either the latest encoding standard or the legacy standard.\n    /// @param _encodingVersion EncodingVersion.\n    /// @param _originalCaller The address of the entity that initiated the deposit.\n    /// @param _assetId The unique identifier of the deposited L1 token.\n    /// @param _nativeTokenVault The address of the token, only used if the encoding version is legacy.\n    /// @param _transferData The encoded transfer data, which includes both the deposit amount and the address of the L2 receiver.\n    /// @return txDataHash The resulting encoded transaction data hash.\n    function encodeTxDataHash(\n        bytes1 _encodingVersion,\n        address _originalCaller,\n        bytes32 _assetId,\n        address _nativeTokenVault,\n        bytes memory _transferData\n    ) internal view returns (bytes32 txDataHash) {\n        if (_encodingVersion == LEGACY_ENCODING_VERSION) {\n            address tokenAddress = INativeTokenVault(_nativeTokenVault).tokenAddress(_assetId);\n\n            // This is a double check to ensure that the used token for the legacy encoding is correct.\n            // This revert should never be emitted and in real life and should only serve as a guard in\n            // case of inconsistent state of Native Token Vault.\n            bytes32 expectedAssetId = encodeNTVAssetId(block.chainid, tokenAddress);\n            if (_assetId != expectedAssetId) {\n                revert IncorrectTokenAddressFromNTV(_assetId, tokenAddress);\n            }\n\n            (uint256 depositAmount, , ) = decodeBridgeBurnData(_transferData);\n            txDataHash = keccak256(abi.encode(_originalCaller, tokenAddress, depositAmount));\n        } else if (_encodingVersion == NEW_ENCODING_VERSION) {\n            // Similarly to calldata, the txDataHash is collision-resistant.\n            // In the legacy data hash, the first encoded variable was the address, which is padded with zeros during `abi.encode`.\n            txDataHash = keccak256(\n                bytes.concat(_encodingVersion, abi.encode(_originalCaller, _assetId, _transferData))\n            );\n        } else {\n            revert UnsupportedEncodingVersion();\n        }\n    }\n\n    /// @notice Decodes the token data by combining chain id, asset deployment tracker and asset data.\n    function decodeTokenData(\n        bytes calldata _tokenData\n    ) internal pure returns (uint256 chainId, bytes memory name, bytes memory symbol, bytes memory decimals) {\n        bytes1 encodingVersion = _tokenData[0];\n        if (encodingVersion == LEGACY_ENCODING_VERSION) {\n            (name, symbol, decimals) = abi.decode(_tokenData, (bytes, bytes, bytes));\n        } else if (encodingVersion == NEW_ENCODING_VERSION) {\n            return abi.decode(_tokenData[1:], (uint256, bytes, bytes, bytes));\n        } else {\n            revert UnsupportedEncodingVersion();\n        }\n    }\n\n    /// @notice Encodes the token data by combining chain id, and its metadata.\n    /// @dev Note that all the metadata of the token is expected to be ABI encoded.\n    /// @param _chainId The id of the chain token is native to.\n    /// @param _name The name of the token.\n    /// @param _symbol The symbol of the token.\n    /// @param _decimals The decimals of the token.\n    /// @return The encoded token data.\n    function encodeTokenData(\n        uint256 _chainId,\n        bytes memory _name,\n        bytes memory _symbol,\n        bytes memory _decimals\n    ) internal pure returns (bytes memory) {\n        return bytes.concat(NEW_ENCODING_VERSION, abi.encode(_chainId, _name, _symbol, _decimals));\n    }\n}\n"
      },
      "contracts/common/libraries/DynamicIncrementalMerkle.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Merkle} from \"./Merkle.sol\";\nimport {Arrays} from \"@openzeppelin/contracts-v4/utils/Arrays.sol\";\n\n/**\n * @dev Library for managing https://wikipedia.org/wiki/Merkle_Tree[Merkle Tree] data structures.\n *\n * Each tree is a complete binary tree with the ability to sequentially insert leaves, changing them from a zero to a\n * non-zero value and updating its root. This structure allows inserting commitments (or other entries) that are not\n * stored, but can be proven to be part of the tree at a later time if the root is kept. See {MerkleProof}.\n *\n * A tree is defined by the following parameters:\n *\n * * Depth: The number of levels in the tree, it also defines the maximum number of leaves as 2**depth.\n * * Zero value: The value that represents an empty leaf. Used to avoid regular zero values to be part of the tree.\n * * Hashing function: A cryptographic hash function used to produce internal nodes.\n *\n * This is a fork of OpenZeppelin's [`MerkleTree`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/9af280dc4b45ee5bda96ba47ff829b407eaab67e/contracts/utils/structs/MerkleTree.sol)\n * library, with the changes to support dynamic tree growth (doubling the size when full).\n */\nlibrary DynamicIncrementalMerkle {\n    /**\n     * @dev A complete `bytes32` Merkle tree.\n     *\n     * The `sides` and `zero` arrays are set to have a length equal to the depth of the tree during setup.\n     *\n     * Struct members have an underscore prefix indicating that they are \"private\" and should not be read or written to\n     * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\n     * lead to unexpected behavior.\n     *\n     * NOTE: The `root` and the updates history is not stored within the tree. Consider using a secondary structure to\n     * store a list of historical roots from the values returned from {setup} and {push} (e.g. a mapping, {BitMaps} or\n     * {Checkpoints}).\n     *\n     * WARNING: Updating any of the tree's parameters after the first insertion will result in a corrupted tree.\n     */\n    struct Bytes32PushTree {\n        uint256 _nextLeafIndex;\n        bytes32[] _sides;\n        bytes32[] _zeros;\n    }\n\n    /**\n     * @dev Initialize a {Bytes32PushTree} using {Hashes-Keccak256} to hash internal nodes.\n     * The capacity of the tree (i.e. number of leaves) is set to `2**levels`.\n     *\n     * IMPORTANT: The zero value should be carefully chosen since it will be stored in the tree representing\n     * empty leaves. It should be a value that is not expected to be part of the tree.\n     */\n    function setup(Bytes32PushTree storage self, bytes32 zero) internal returns (bytes32 initialRoot) {\n        self._nextLeafIndex = 0;\n        self._zeros.push(zero);\n        self._sides.push(bytes32(0));\n        return bytes32(0);\n    }\n\n    /**\n     * @dev Resets the tree to a blank state.\n     * Calling this function on MerkleTree that was already setup and used will reset it to a blank state.\n     * @param zero The value that represents an empty leaf.\n     * @return initialRoot The initial root of the tree.\n     */\n    function reset(Bytes32PushTree storage self, bytes32 zero) internal returns (bytes32 initialRoot) {\n        self._nextLeafIndex = 0;\n        uint256 length = self._zeros.length;\n        for (uint256 i = length; 0 < i; --i) {\n            self._zeros.pop();\n        }\n        length = self._sides.length;\n        for (uint256 i = length; 0 < i; --i) {\n            self._sides.pop();\n        }\n        self._zeros.push(zero);\n        self._sides.push(bytes32(0));\n        return bytes32(0);\n    }\n\n    /**\n     * @dev Insert a new leaf in the tree, and compute the new root. Returns the position of the inserted leaf in the\n     * tree, and the resulting root.\n     *\n     * Hashing the leaf before calling this function is recommended as a protection against\n     * second pre-image attacks.\n     */\n    function push(Bytes32PushTree storage self, bytes32 leaf) internal returns (uint256 index, bytes32 newRoot) {\n        // Cache read\n        uint256 levels = self._zeros.length - 1;\n\n        // Get leaf index\n        // solhint-disable-next-line gas-increment-by-one\n        index = self._nextLeafIndex++;\n\n        // Check if tree is full.\n        if (index == 1 << levels) {\n            bytes32 zero = self._zeros[levels];\n            bytes32 newZero = Merkle.efficientHash(zero, zero);\n            self._zeros.push(newZero);\n            self._sides.push(bytes32(0));\n            ++levels;\n        }\n\n        // Rebuild branch from leaf to root\n        uint256 currentIndex = index;\n        bytes32 currentLevelHash = leaf;\n        bool updatedSides = false;\n        for (uint32 i = 0; i < levels; ++i) {\n            // Reaching the parent node, is currentLevelHash the left child?\n            bool isLeft = currentIndex % 2 == 0;\n\n            // If so, next time we will come from the right, so we need to save it\n            if (isLeft && !updatedSides) {\n                Arrays.unsafeAccess(self._sides, i).value = currentLevelHash;\n                updatedSides = true;\n            }\n\n            // Compute the current node hash by using the hash function\n            // with either its sibling (side) or the zero value for that level.\n            currentLevelHash = Merkle.efficientHash(\n                isLeft ? currentLevelHash : Arrays.unsafeAccess(self._sides, i).value,\n                isLeft ? Arrays.unsafeAccess(self._zeros, i).value : currentLevelHash\n            );\n\n            // Update node index\n            currentIndex >>= 1;\n        }\n\n        Arrays.unsafeAccess(self._sides, levels).value = currentLevelHash;\n        return (index, currentLevelHash);\n    }\n\n    /**\n     * @dev Tree's root.\n     */\n    function root(Bytes32PushTree storage self) internal view returns (bytes32) {\n        return Arrays.unsafeAccess(self._sides, self._sides.length - 1).value;\n    }\n\n    /**\n     * @dev Tree's height (does not include the root node).\n     */\n    function height(Bytes32PushTree storage self) internal view returns (uint256) {\n        return self._sides.length - 1;\n    }\n}\n"
      },
      "contracts/common/libraries/FullMerkle.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {UncheckedMath} from \"../../common/libraries/UncheckedMath.sol\";\nimport {Merkle} from \"./Merkle.sol\";\nimport {MerkleWrongIndex, MerkleWrongLength} from \"../L1ContractErrors.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\nlibrary FullMerkle {\n    using UncheckedMath for uint256;\n\n    struct FullTree {\n        uint256 _height;\n        uint256 _leafNumber;\n        bytes32[][] _nodes;\n        bytes32[] _zeros;\n    }\n\n    /**\n     * @dev Initialize a {FullTree} using {Merkle.efficientHash} to hash internal nodes.\n     * The capacity of the tree (i.e. number of leaves) is set to `2**levels`.\n     *\n     * IMPORTANT: The zero value should be carefully chosen since it will be stored in the tree representing\n     * empty leaves. It should be a value that is not expected to be part of the tree.\n     * @param zero The zero value to be used in the tree.\n     */\n    function setup(FullTree storage self, bytes32 zero) internal returns (bytes32 initialRoot) {\n        // Store depth in the dynamic array\n        self._zeros.push(zero);\n        self._nodes.push([zero]);\n\n        return zero;\n    }\n\n    /**\n     * @dev Push a new leaf to the tree.\n     * @param _leaf The leaf to be added to the tree.\n     */\n    function pushNewLeaf(FullTree storage self, bytes32 _leaf) internal returns (bytes32 newRoot) {\n        // solhint-disable-next-line gas-increment-by-one\n        uint256 index = self._leafNumber++;\n\n        if (index == 1 << self._height) {\n            uint256 newHeight = self._height.uncheckedInc();\n            self._height = newHeight;\n            bytes32 topZero = self._zeros[newHeight - 1];\n            bytes32 newZero = Merkle.efficientHash(topZero, topZero);\n            self._zeros.push(newZero);\n            self._nodes.push([newZero]);\n        }\n        if (index != 0) {\n            uint256 oldMaxNodeNumber = index - 1;\n            uint256 maxNodeNumber = index;\n            for (uint256 i; i < self._height; i = i.uncheckedInc()) {\n                if (oldMaxNodeNumber == maxNodeNumber) {\n                    break;\n                }\n                self._nodes[i].push(self._zeros[i]);\n                maxNodeNumber /= 2;\n                oldMaxNodeNumber /= 2;\n            }\n        }\n        return updateLeaf(self, index, _leaf);\n    }\n\n    /**\n     * @dev Update a leaf at index in the tree.\n     * @param _index The index of the leaf to be updated.\n     * @param _itemHash The new hash of the leaf.\n     */\n    function updateLeaf(FullTree storage self, uint256 _index, bytes32 _itemHash) internal returns (bytes32) {\n        uint256 maxNodeNumber = self._leafNumber - 1;\n        if (_index > maxNodeNumber) {\n            revert MerkleWrongIndex(_index, maxNodeNumber);\n        }\n        self._nodes[0][_index] = _itemHash;\n        bytes32 currentHash = _itemHash;\n        for (uint256 i; i < self._height; i = i.uncheckedInc()) {\n            if (_index % 2 == 0) {\n                currentHash = Merkle.efficientHash(\n                    currentHash,\n                    maxNodeNumber == _index ? self._zeros[i] : self._nodes[i][_index + 1]\n                );\n            } else {\n                currentHash = Merkle.efficientHash(self._nodes[i][_index - 1], currentHash);\n            }\n            _index /= 2;\n            maxNodeNumber /= 2;\n            self._nodes[i + 1][_index] = currentHash;\n        }\n        return currentHash;\n    }\n\n    /**\n     * @dev Updated all leaves in the tree.\n     * @param _newLeaves The new leaves to be added to the tree.\n     */\n    function updateAllLeaves(FullTree storage self, bytes32[] memory _newLeaves) internal returns (bytes32) {\n        if (_newLeaves.length != self._leafNumber) {\n            revert MerkleWrongLength(_newLeaves.length, self._leafNumber);\n        }\n        return updateAllNodesAtHeight(self, 0, _newLeaves);\n    }\n\n    /**\n     * @dev Update all nodes at a certain height in the tree.\n     * @param _height The height of the nodes to be updated.\n     * @param _newNodes The new nodes to be added to the tree.\n     */\n    function updateAllNodesAtHeight(\n        FullTree storage self,\n        uint256 _height,\n        bytes32[] memory _newNodes\n    ) internal returns (bytes32) {\n        if (_height == self._height) {\n            self._nodes[_height][0] = _newNodes[0];\n            return _newNodes[0];\n        }\n\n        uint256 newRowLength = (_newNodes.length + 1) / 2;\n        bytes32[] memory _newRow = new bytes32[](newRowLength);\n\n        uint256 length = _newNodes.length;\n        for (uint256 i; i < length; i = i.uncheckedAdd(2)) {\n            self._nodes[_height][i] = _newNodes[i];\n            if (i + 1 < length) {\n                self._nodes[_height][i + 1] = _newNodes[i + 1];\n                _newRow[i / 2] = Merkle.efficientHash(_newNodes[i], _newNodes[i + 1]);\n            } else {\n                // Handle odd number of nodes by hashing the last node with zero\n                _newRow[i / 2] = Merkle.efficientHash(_newNodes[i], self._zeros[_height]);\n            }\n        }\n        return updateAllNodesAtHeight(self, _height + 1, _newRow);\n    }\n\n    /**\n     * @dev Returns the root of the tree.\n     */\n    function root(FullTree storage self) internal view returns (bytes32) {\n        return self._nodes[self._height][0];\n    }\n}\n"
      },
      "contracts/common/libraries/L2ContractHelper.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {BytecodeError, MalformedBytecode, LengthIsNotDivisibleBy32} from \"../L1ContractErrors.sol\";\n\nimport {UncheckedMath} from \"./UncheckedMath.sol\";\nimport {L2_MESSENGER} from \"../L2ContractAddresses.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Interface for the contract that is used to deploy contracts on L2.\n */\ninterface IContractDeployer {\n    /// @notice A struct that describes a forced deployment on an address.\n    /// @param bytecodeHash The bytecode hash to put on an address.\n    /// @param newAddress The address on which to deploy the bytecodehash to.\n    /// @param callConstructor Whether to run the constructor on the force deployment.\n    /// @param value The `msg.value` with which to initialize a contract.\n    /// @param input The constructor calldata.\n    struct ForceDeployment {\n        bytes32 bytecodeHash;\n        address newAddress;\n        bool callConstructor;\n        uint256 value;\n        bytes input;\n    }\n\n    /// @notice This method is to be used only during an upgrade to set bytecodes on specific addresses.\n    /// @param _deployParams A set of parameters describing force deployment.\n    function forceDeployOnAddresses(ForceDeployment[] calldata _deployParams) external payable;\n\n    /// @notice Creates a new contract at a determined address using the `CREATE2` salt on L2\n    /// @param _salt a unique value to create the deterministic address of the new contract\n    /// @param _bytecodeHash the bytecodehash of the new contract to be deployed\n    /// @param _input the calldata to be sent to the constructor of the new contract\n    function create2(bytes32 _salt, bytes32 _bytecodeHash, bytes calldata _input) external returns (address);\n}\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Helper library for working with L2 contracts on L1.\n */\nlibrary L2ContractHelper {\n    using UncheckedMath for uint256;\n\n    /// @dev The prefix used to create CREATE2 addresses.\n    bytes32 private constant CREATE2_PREFIX = keccak256(\"zksyncCreate2\");\n\n    /// @dev Prefix used during derivation of account addresses using CREATE\n    bytes32 private constant CREATE_PREFIX = 0x63bae3a9951d38e8a3fbb7b70909afc1200610fc5bc55ade242f815974674f23;\n\n    /// @notice Sends L2 -> L1 arbitrary-long message through the system contract messenger.\n    /// @param _message Data to be sent to L1.\n    /// @return keccak256 hash of the sent message.\n    function sendMessageToL1(bytes memory _message) internal returns (bytes32) {\n        return L2_MESSENGER.sendToL1(_message);\n    }\n\n    /// @notice Validate the bytecode format and calculate its hash.\n    /// @param _bytecode The bytecode to hash.\n    /// @return hashedBytecode The 32-byte hash of the bytecode.\n    /// Note: The function reverts the execution if the bytecode has non expected format:\n    /// - Bytecode bytes length is not a multiple of 32\n    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)\n    /// - Bytecode words length is not odd\n    function hashL2Bytecode(bytes memory _bytecode) internal pure returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        if (_bytecode.length % 32 != 0) {\n            revert LengthIsNotDivisibleBy32(_bytecode.length);\n        }\n\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n        // bytecode length must be less than 2^16 words\n        if (bytecodeLenInWords >= 2 ** 16) {\n            revert MalformedBytecode(BytecodeError.NumberOfWords);\n        }\n        // bytecode length in words must be odd\n        if (bytecodeLenInWords % 2 == 0) {\n            revert MalformedBytecode(BytecodeError.WordsMustBeOdd);\n        }\n        hashedBytecode = sha256(_bytecode) & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n\n    /// @notice Validate the bytecode format and calculate its hash.\n    /// @param _bytecode The bytecode to hash.\n    /// @return hashedBytecode The 32-byte hash of the bytecode.\n    /// Note: The function reverts the execution if the bytecode has non expected format:\n    /// - Bytecode bytes length is not a multiple of 32\n    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)\n    /// - Bytecode words length is not odd\n    function hashL2BytecodeCalldata(bytes calldata _bytecode) internal pure returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        if (_bytecode.length % 32 != 0) {\n            revert LengthIsNotDivisibleBy32(_bytecode.length);\n        }\n\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n        // bytecode length must be less than 2^16 words\n        if (bytecodeLenInWords >= 2 ** 16) {\n            revert MalformedBytecode(BytecodeError.NumberOfWords);\n        }\n        // bytecode length in words must be odd\n        if (bytecodeLenInWords % 2 == 0) {\n            revert MalformedBytecode(BytecodeError.WordsMustBeOdd);\n        }\n        hashedBytecode = sha256(_bytecode) & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n\n    /// @notice Validates the format of the given bytecode hash.\n    /// @dev Due to the specification of the L2 bytecode hash, not every 32 bytes could be a legit bytecode hash.\n    /// @dev The function reverts on invalid bytecode hash format.\n    /// @param _bytecodeHash The hash of the bytecode to validate.\n    function validateBytecodeHash(bytes32 _bytecodeHash) internal pure {\n        uint8 version = uint8(_bytecodeHash[0]);\n        // Incorrectly formatted bytecodeHash\n        if (version != 1 || _bytecodeHash[1] != bytes1(0)) {\n            revert MalformedBytecode(BytecodeError.Version);\n        }\n\n        // Code length in words must be odd\n        if (bytecodeLen(_bytecodeHash) % 2 == 0) {\n            revert MalformedBytecode(BytecodeError.WordsMustBeOdd);\n        }\n    }\n\n    /// @notice Returns the length of the bytecode associated with the given hash.\n    /// @param _bytecodeHash The hash of the bytecode.\n    /// @return codeLengthInWords The length of the bytecode in words.\n    function bytecodeLen(bytes32 _bytecodeHash) internal pure returns (uint256 codeLengthInWords) {\n        codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n    }\n\n    /// @notice Computes the create2 address for a Layer 2 contract.\n    /// @param _sender The address of the sender.\n    /// @param _salt The salt value to use in the create2 address computation.\n    /// @param _bytecodeHash The contract bytecode hash.\n    /// @param _constructorInputHash The hash of the constructor input data.\n    /// @return The create2 address of the contract.\n    /// NOTE: L2 create2 derivation is different from L1 derivation!\n    function computeCreate2Address(\n        address _sender,\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes32 _constructorInputHash\n    ) internal pure returns (address) {\n        bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n        bytes32 data = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n        );\n\n        return address(uint160(uint256(data)));\n    }\n\n    /// @notice Calculates the address of a deployed contract via create\n    /// @param _sender The account that deploys the contract.\n    /// @param _senderNonce The deploy nonce of the sender's account.\n    /// NOTE: L2 create derivation is different from L1 derivation!\n    function computeCreateAddress(address _sender, uint256 _senderNonce) internal pure returns (address) {\n        // No collision is possible with the Ethereum's CREATE, since\n        // the prefix begins with 0x63....\n        bytes32 hash = keccak256(\n            bytes.concat(CREATE_PREFIX, bytes32(uint256(uint160(_sender))), bytes32(_senderNonce))\n        );\n\n        return address(uint160(uint256(hash)));\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}\n"
      },
      "contracts/common/libraries/Merkle.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {UncheckedMath} from \"../../common/libraries/UncheckedMath.sol\";\nimport {MerklePathEmpty, MerklePathOutOfBounds, MerkleIndexOutOfBounds, MerklePathLengthMismatch, MerkleNothingToProve, MerkleIndexOrHeightMismatch} from \"../../common/L1ContractErrors.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\nlibrary Merkle {\n    using UncheckedMath for uint256;\n\n    /// @dev Calculate Merkle root by the provided Merkle proof.\n    /// NOTE: When using this function, check that the _path length is equal to the tree height to prevent shorter/longer paths attack\n    /// however, for chains settling on GW the proof includes the GW proof, so the path increases. See Mailbox for more details.\n    /// @param _path Merkle path from the leaf to the root\n    /// @param _index Leaf index in the tree\n    /// @param _itemHash Hash of leaf content\n    /// @return The Merkle root\n    function calculateRoot(\n        bytes32[] calldata _path,\n        uint256 _index,\n        bytes32 _itemHash\n    ) internal pure returns (bytes32) {\n        uint256 pathLength = _path.length;\n        _validatePathLengthForSingleProof(_index, pathLength);\n\n        bytes32 currentHash = _itemHash;\n        for (uint256 i; i < pathLength; i = i.uncheckedInc()) {\n            currentHash = (_index % 2 == 0)\n                ? efficientHash(currentHash, _path[i])\n                : efficientHash(_path[i], currentHash);\n            _index /= 2;\n        }\n\n        return currentHash;\n    }\n\n    /// @dev Calculate Merkle root by the provided Merkle proof.\n    /// NOTE: When using this function, check that the _path length is equal to the tree height to prevent shorter/longer paths attack\n    /// @param _path Merkle path from the leaf to the root\n    /// @param _index Leaf index in the tree\n    /// @param _itemHash Hash of leaf content\n    /// @return The Merkle root\n    function calculateRootMemory(\n        bytes32[] memory _path,\n        uint256 _index,\n        bytes32 _itemHash\n    ) internal pure returns (bytes32) {\n        uint256 pathLength = _path.length;\n        _validatePathLengthForSingleProof(_index, pathLength);\n\n        bytes32 currentHash = _itemHash;\n        for (uint256 i; i < pathLength; i = i.uncheckedInc()) {\n            currentHash = (_index % 2 == 0)\n                ? efficientHash(currentHash, _path[i])\n                : efficientHash(_path[i], currentHash);\n            _index /= 2;\n        }\n\n        return currentHash;\n    }\n\n    /// @dev Calculate Merkle root by the provided Merkle proof for a range of elements\n    /// NOTE: When using this function, check that the _startPath and _endPath lengths are equal to the tree height to prevent shorter/longer paths attack\n    /// @param _startPath Merkle path from the first element of the range to the root\n    /// @param _endPath Merkle path from the last element of the range to the root\n    /// @param _startIndex Index of the first element of the range in the tree\n    /// @param _itemHashes Hashes of the elements in the range\n    /// @return The Merkle root\n    function calculateRootPaths(\n        bytes32[] memory _startPath,\n        bytes32[] memory _endPath,\n        uint256 _startIndex,\n        bytes32[] memory _itemHashes\n    ) internal pure returns (bytes32) {\n        uint256 pathLength = _startPath.length;\n        if (pathLength != _endPath.length) {\n            revert MerklePathLengthMismatch(pathLength, _endPath.length);\n        }\n        if (pathLength >= 256) {\n            revert MerklePathOutOfBounds();\n        }\n        uint256 levelLen = _itemHashes.length;\n        // Edge case: we want to be able to prove an element in a single-node tree.\n        if (pathLength == 0 && (_startIndex != 0 || levelLen != 1)) {\n            revert MerklePathEmpty();\n        }\n        if (levelLen == 0) {\n            revert MerkleNothingToProve();\n        }\n        if (_startIndex + levelLen > (1 << pathLength)) {\n            revert MerkleIndexOrHeightMismatch();\n        }\n        bytes32[] memory itemHashes = _itemHashes;\n\n        for (uint256 level; level < pathLength; level = level.uncheckedInc()) {\n            uint256 parity = _startIndex % 2;\n            // We get an extra element on the next level if on the current level elements either\n            // start on an odd index (`parity == 1`) or end on an even index (`levelLen % 2 == 1`)\n            uint256 nextLevelLen = levelLen / 2 + (parity | (levelLen % 2));\n            for (uint256 i; i < nextLevelLen; i = i.uncheckedInc()) {\n                bytes32 lhs = (i == 0 && parity == 1) ? _startPath[level] : itemHashes[2 * i - parity];\n                bytes32 rhs = (i == nextLevelLen - 1 && (levelLen - parity) % 2 == 1)\n                    ? _endPath[level]\n                    : itemHashes[2 * i + 1 - parity];\n                itemHashes[i] = efficientHash(lhs, rhs);\n            }\n            levelLen = nextLevelLen;\n            _startIndex /= 2;\n        }\n\n        return itemHashes[0];\n    }\n\n    /// @dev Keccak hash of the concatenation of two 32-byte words\n    function efficientHash(bytes32 _lhs, bytes32 _rhs) internal pure returns (bytes32 result) {\n        assembly {\n            mstore(0x00, _lhs)\n            mstore(0x20, _rhs)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    function _validatePathLengthForSingleProof(uint256 _index, uint256 _pathLength) private pure {\n        if (_pathLength >= 256) {\n            revert MerklePathOutOfBounds();\n        }\n        if (_index >= (1 << _pathLength)) {\n            revert MerkleIndexOutOfBounds();\n        }\n    }\n}\n"
      },
      "contracts/common/libraries/MessageHashing.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nbytes32 constant BATCH_LEAF_PADDING = keccak256(\"zkSync:BatchLeaf\");\nbytes32 constant CHAIN_ID_LEAF_PADDING = keccak256(\"zkSync:ChainIdLeaf\");\n\nlibrary MessageHashing {\n    /// @dev Returns the leaf hash for a chain with batch number and batch root.\n    /// @param batchRoot The root hash of the batch.\n    /// @param batchNumber The number of the batch.\n    function batchLeafHash(bytes32 batchRoot, uint256 batchNumber) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(BATCH_LEAF_PADDING, batchRoot, batchNumber));\n    }\n\n    /// @dev Returns the leaf hash for a chain with chain root and chain id.\n    /// @param chainIdRoot The root hash of the chain.\n    /// @param chainId The id of the chain.\n    function chainIdLeafHash(bytes32 chainIdRoot, uint256 chainId) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(CHAIN_ID_LEAF_PADDING, chainIdRoot, chainId));\n    }\n}\n"
      },
      "contracts/common/libraries/SemVer.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\n/// @dev The number of bits dedicated to the \"patch\" portion of the protocol version.\n/// This also defines the bit starting from which the \"minor\" part is located.\nuint256 constant SEMVER_MINOR_OFFSET = 32;\n\n/// @dev The number of bits dedicated to the \"patch\" and \"minor\" portions of the protocol version.\n/// This also defines the bit starting from which the \"major\" part is located.\n/// Note, that currently, only major version of \"0\" is supported.\nuint256 constant SEMVER_MAJOR_OFFSET = 64;\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice The library for managing SemVer for the protocol version.\n */\nlibrary SemVer {\n    /// @notice Unpacks the SemVer version from a single uint256 into major, minor and patch components.\n    /// @param _packedProtocolVersion The packed protocol version.\n    /// @return major The major version.\n    /// @return minor The minor version.\n    /// @return patch The patch version.\n    function unpackSemVer(\n        uint96 _packedProtocolVersion\n    ) internal pure returns (uint32 major, uint32 minor, uint32 patch) {\n        patch = uint32(_packedProtocolVersion);\n        minor = uint32(_packedProtocolVersion >> SEMVER_MINOR_OFFSET);\n        major = uint32(_packedProtocolVersion >> SEMVER_MAJOR_OFFSET);\n    }\n\n    /// @notice Packs the SemVer version from the major, minor and patch components into a single uint96.\n    /// @param _major The major version.\n    /// @param _minor The minor version.\n    /// @param _patch The patch version.\n    /// @return packedProtocolVersion The packed protocol version.\n    function packSemVer(\n        uint32 _major,\n        uint32 _minor,\n        uint32 _patch\n    ) internal pure returns (uint96 packedProtocolVersion) {\n        packedProtocolVersion =\n            uint96(_patch) |\n            (uint96(_minor) << SEMVER_MINOR_OFFSET) |\n            (uint96(_major) << SEMVER_MAJOR_OFFSET);\n    }\n}\n"
      },
      "contracts/common/libraries/SystemContractsCaller.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable one-contract-per-file\n\npragma solidity 0.8.24;\n\nimport {MSG_VALUE_SYSTEM_CONTRACT} from \"../L2ContractAddresses.sol\";\n\naddress constant SYSTEM_CALL_CALL_ADDRESS = address((1 << 16) - 11);\n/// @dev If the bitwise AND of the extraAbi[2] param when calling the MSG_VALUE_SIMULATOR\n/// is non-zero, the call will be assumed to be a system one.\nuint256 constant MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT = 1;\n\n/// @notice The way to forward the calldata:\n/// - Use the current heap (i.e. the same as on EVM).\n/// - Use the auxiliary heap.\n/// - Forward via a pointer\n/// @dev Note, that currently, users do not have access to the auxiliary\n/// heap and so the only type of forwarding that will be used by the users\n/// are UseHeap and ForwardFatPointer for forwarding a slice of the current calldata\n/// to the next call.\nenum CalldataForwardingMode {\n    UseHeap,\n    ForwardFatPointer,\n    UseAuxHeap\n}\n\n/// @notice Error thrown a cast from uint256 to u32 is not possible.\nerror U32CastOverflow();\n\nlibrary Utils {\n    function safeCastToU32(uint256 _x) internal pure returns (uint32) {\n        if (_x > type(uint32).max) {\n            revert U32CastOverflow();\n        }\n\n        return uint32(_x);\n    }\n}\n\n/// @notice The library contains the functions to make system calls.\n/// @dev A more detailed description of the library and its methods can be found in the `system-contracts` repo.\nlibrary SystemContractsCaller {\n    function systemCall(uint32 gasLimit, address to, uint256 value, bytes memory data) internal returns (bool success) {\n        address callAddr = SYSTEM_CALL_CALL_ADDRESS;\n\n        uint32 dataStart;\n        assembly {\n            dataStart := add(data, 0x20)\n        }\n        uint32 dataLength = Utils.safeCastToU32(data.length);\n\n        uint256 farCallAbi = getFarCallABI({\n            dataOffset: 0,\n            memoryPage: 0,\n            dataStart: dataStart,\n            dataLength: dataLength,\n            gasPassed: gasLimit,\n            // Only rollup is supported for now\n            shardId: 0,\n            forwardingMode: CalldataForwardingMode.UseHeap,\n            isConstructorCall: false,\n            isSystemCall: true\n        });\n\n        if (value == 0) {\n            // Doing the system call directly\n            assembly {\n                success := call(to, callAddr, 0, 0, farCallAbi, 0, 0)\n            }\n        } else {\n            address msgValueSimulator = MSG_VALUE_SYSTEM_CONTRACT;\n            // We need to supply the mask to the MsgValueSimulator to denote\n            // that the call should be a system one.\n            uint256 forwardMask = MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT;\n\n            assembly {\n                success := call(msgValueSimulator, callAddr, value, to, farCallAbi, forwardMask, 0)\n            }\n        }\n    }\n\n    function systemCallWithReturndata(\n        uint32 gasLimit,\n        address to,\n        uint128 value,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        success = systemCall(gasLimit, to, value, data);\n\n        uint256 size;\n        assembly {\n            size := returndatasize()\n        }\n\n        returnData = new bytes(size);\n        assembly {\n            returndatacopy(add(returnData, 0x20), 0, size)\n        }\n    }\n\n    function getFarCallABI(\n        uint32 dataOffset,\n        uint32 memoryPage,\n        uint32 dataStart,\n        uint32 dataLength,\n        uint32 gasPassed,\n        uint8 shardId,\n        CalldataForwardingMode forwardingMode,\n        bool isConstructorCall,\n        bool isSystemCall\n    ) internal pure returns (uint256 farCallAbi) {\n        // Fill in the call parameter fields\n        farCallAbi = getFarCallABIWithEmptyFatPointer({\n            gasPassed: gasPassed,\n            shardId: shardId,\n            forwardingMode: forwardingMode,\n            isConstructorCall: isConstructorCall,\n            isSystemCall: isSystemCall\n        });\n        // Fill in the fat pointer fields\n        farCallAbi |= dataOffset;\n        farCallAbi |= (uint256(memoryPage) << 32);\n        farCallAbi |= (uint256(dataStart) << 64);\n        farCallAbi |= (uint256(dataLength) << 96);\n    }\n\n    function getFarCallABIWithEmptyFatPointer(\n        uint32 gasPassed,\n        uint8 shardId,\n        CalldataForwardingMode forwardingMode,\n        bool isConstructorCall,\n        bool isSystemCall\n    ) internal pure returns (uint256 farCallAbiWithEmptyFatPtr) {\n        farCallAbiWithEmptyFatPtr |= (uint256(gasPassed) << 192);\n        farCallAbiWithEmptyFatPtr |= (uint256(forwardingMode) << 224);\n        farCallAbiWithEmptyFatPtr |= (uint256(shardId) << 232);\n        if (isConstructorCall) {\n            farCallAbiWithEmptyFatPtr |= (1 << 240);\n        }\n        if (isSystemCall) {\n            farCallAbiWithEmptyFatPtr |= (1 << 248);\n        }\n    }\n}\n"
      },
      "contracts/common/libraries/UncheckedMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice The library for unchecked math.\n */\nlibrary UncheckedMath {\n    function uncheckedInc(uint256 _number) internal pure returns (uint256) {\n        unchecked {\n            return _number + 1;\n        }\n    }\n\n    function uncheckedAdd(uint256 _lhs, uint256 _rhs) internal pure returns (uint256) {\n        unchecked {\n            return _lhs + _rhs;\n        }\n    }\n}\n"
      },
      "contracts/common/libraries/UnsafeBytes.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @dev The library provides a set of functions that help read data from an \"abi.encodePacked\" byte array.\n * @dev Each of the functions accepts the `bytes memory` and the offset where data should be read and returns a value of a certain type.\n *\n * @dev WARNING!\n * 1) Functions don't check the length of the bytes array, so it can go out of bounds.\n * The user of the library must check for bytes length before using any functions from the library!\n *\n * 2) Read variables are not cleaned up - https://docs.soliditylang.org/en/v0.8.16/internals/variable_cleanup.html.\n * Using data in inline assembly can lead to unexpected behavior!\n */\nlibrary UnsafeBytes {\n    function readUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 4)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readAddress(bytes memory _bytes, uint256 _start) internal pure returns (address result, uint256 offset) {\n        assembly {\n            offset := add(_start, 20)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 32)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 32)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readRemainingBytes(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory result) {\n        uint256 arrayLen = _bytes.length - _start;\n        result = new bytes(arrayLen);\n\n        assembly {\n            mcopy(add(result, 0x20), add(_bytes, add(0x20, _start)), arrayLen)\n        }\n    }\n}\n"
      },
      "contracts/dev-contracts/ConstructorForwarder.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\ncontract ConstructorForwarder {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    constructor(address to, bytes memory data) payable {\n        (bool success, ) = payable(to).call{value: msg.value}(data);\n        require(success);\n    }\n}\n"
      },
      "contracts/dev-contracts/DummyL1ERC20Bridge.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {L1ERC20Bridge} from \"../bridge/L1ERC20Bridge.sol\";\nimport {IL1AssetRouter} from \"../bridge/asset-router/IL1AssetRouter.sol\";\nimport {IL1NativeTokenVault} from \"../bridge/ntv/IL1NativeTokenVault.sol\";\nimport {IL1Nullifier} from \"../bridge/interfaces/IL1Nullifier.sol\";\n\ncontract DummyL1ERC20Bridge is L1ERC20Bridge {\n    constructor(\n        IL1Nullifier _l1Nullifier,\n        IL1AssetRouter _l1SharedBridge,\n        IL1NativeTokenVault _l1NativeTokenVault,\n        uint256 _eraChainId\n    ) L1ERC20Bridge(_l1Nullifier, _l1SharedBridge, _l1NativeTokenVault, _eraChainId) {}\n\n    function setValues(address _l2SharedBridge, address _l2TokenBeacon, bytes32 _l2TokenProxyBytecodeHash) external {\n        l2Bridge = _l2SharedBridge;\n        l2TokenBeacon = _l2TokenBeacon;\n        l2TokenProxyBytecodeHash = _l2TokenProxyBytecodeHash;\n    }\n\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n}\n"
      },
      "contracts/dev-contracts/DummyRestriction.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Call} from \"../governance/Common.sol\";\nimport {IRestriction, RESTRICTION_MAGIC} from \"../governance/restriction/IRestriction.sol\";\n\n/// @title Restriction contract interface\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract DummyRestriction is IRestriction {\n    bool immutable correctMagic;\n\n    constructor(bool useCorrectMagic) {\n        correctMagic = useCorrectMagic;\n    }\n\n    /// @notice A method used to check that the contract supports this interface.\n    /// @return Returns the `RESTRICTION_MAGIC`\n    function getSupportsRestrictionMagic() external view returns (bytes32) {\n        if (correctMagic) {\n            return RESTRICTION_MAGIC;\n        } else {\n            // Invalid magic\n            return bytes32(0);\n        }\n    }\n\n    /// @notice Ensures that the invoker has the required role to call the function.\n    /// @param _call The call data.\n    /// @param _invoker The address of the invoker.\n    function validateCall(Call calldata _call, address _invoker) external view virtual {\n        // nothing\n    }\n}\n"
      },
      "contracts/dev-contracts/EventOnFallback.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\ncontract EventOnFallback {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    event Called(address msgSender, uint256 value, bytes data);\n\n    fallback() external payable {\n        emit Called(msg.sender, msg.value, msg.data);\n    }\n}\n"
      },
      "contracts/dev-contracts/FeeOnTransferToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {TestnetERC20Token} from \"./TestnetERC20Token.sol\";\n\ncontract FeeOnTransferToken is TestnetERC20Token {\n    // add this to be excluded from coverage report\n    function test() internal override {}\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) TestnetERC20Token(name_, symbol_, decimals_) {}\n\n    function _transfer(address from, address to, uint256 amount) internal override {\n        super._transfer(from, to, amount - 1);\n        super._transfer(from, address(1), 1);\n    }\n}\n"
      },
      "contracts/dev-contracts/Forwarder.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\ncontract Forwarder {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    function forward(address to, bytes calldata data) external payable returns (bytes memory returnValue) {\n        bool success;\n        (success, returnValue) = payable(to).call{value: msg.value}(data);\n        require(success);\n    }\n}\n"
      },
      "contracts/dev-contracts/L1NullifierDev.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {L1Nullifier, IBridgehub} from \"../bridge/L1Nullifier.sol\";\n\ncontract L1NullifierDev is L1Nullifier {\n    constructor(\n        IBridgehub _bridgehub,\n        uint256 _eraChainId,\n        address _eraDiamondProxy\n    ) L1Nullifier(_bridgehub, _eraChainId, _eraDiamondProxy) {}\n\n    function setL2LegacySharedBridge(uint256 _chainId, address _l2Bridge) external {\n        __DEPRECATED_l2BridgeAddress[_chainId] = _l2Bridge;\n    }\n\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n}\n"
      },
      "contracts/dev-contracts/L2SharedBridgeLegacyDev.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts-v4/proxy/beacon/UpgradeableBeacon.sol\";\n\nimport {BridgedStandardERC20} from \"../bridge/BridgedStandardERC20.sol\";\n\nimport {L2SharedBridgeLegacy} from \"../bridge/L2SharedBridgeLegacy.sol\";\nimport {InvalidCaller, ZeroAddress, EmptyBytes32, Unauthorized, AmountMustBeGreaterThanZero, DeployFailed} from \"../common/L1ContractErrors.sol\";\n\ncontract L2SharedBridgeLegacyDev is L2SharedBridgeLegacy {\n    constructor() L2SharedBridgeLegacy() {}\n\n    /// @notice Initializes the bridge contract for later use. Expected to be used in the proxy.\n    /// @param _legacyBridge The address of the L1 Bridge contract.\n    /// @param _l1SharedBridge The address of the L1 Bridge contract.\n    /// @param _l2TokenProxyBytecodeHash The bytecode hash of the proxy for tokens deployed by the bridge.\n    /// @param _aliasedOwner The address of the governor contract.\n    function initializeDevBridge(\n        address _legacyBridge,\n        address _l1SharedBridge,\n        bytes32 _l2TokenProxyBytecodeHash,\n        address _aliasedOwner\n    ) external reinitializer(2) {\n        if (_l1SharedBridge == address(0)) {\n            revert ZeroAddress();\n        }\n\n        if (_l2TokenProxyBytecodeHash == bytes32(0)) {\n            revert EmptyBytes32();\n        }\n\n        if (_aliasedOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        l1SharedBridge = _l1SharedBridge;\n        l1Bridge = _legacyBridge;\n\n        // The following statement is true only in freshly deployed environments. However,\n        // for those environments we do not need to deploy this contract at all.\n        // This check is primarily for local testing purposes.\n        if (l2TokenProxyBytecodeHash == bytes32(0) && address(l2TokenBeacon) == address(0)) {\n            address l2StandardToken = address(new BridgedStandardERC20{salt: bytes32(0)}());\n            l2TokenBeacon = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n            l2TokenProxyBytecodeHash = _l2TokenProxyBytecodeHash;\n            l2TokenBeacon.transferOwnership(_aliasedOwner);\n        }\n    }\n}\n"
      },
      "contracts/dev-contracts/Multicall.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\n/*\n\nMIT License\n\nCopyright (c) 2018 Maker Foundation\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\n*/\n\npragma solidity 0.8.24;\n\n/// @title Multicall - Aggregate results from multiple read-only function calls\ncontract Multicall {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    function aggregate(Call[] memory calls) public returns (uint256 blockNumber, bytes[] memory returnData) {\n        blockNumber = block.number;\n        returnData = new bytes[](calls.length);\n        uint256 callsLength = calls.length;\n        for (uint256 i = 0; i < callsLength; ++i) {\n            (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\n            require(success, \"multicall 1\");\n            returnData[i] = ret;\n        }\n    }\n\n    // Helper functions\n    function getEthBalance(address addr) public view returns (uint256 balance) {\n        balance = addr.balance;\n    }\n\n    function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\n        blockHash = blockhash(blockNumber);\n    }\n\n    function getLastBlockHash() public view returns (bytes32 blockHash) {\n        blockHash = blockhash(block.number - 1);\n    }\n\n    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\n        timestamp = block.timestamp;\n    }\n\n    function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\n        difficulty = block.prevrandao;\n    }\n\n    function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n        gaslimit = block.gaslimit;\n    }\n\n    function getCurrentBlockCoinbase() public view returns (address coinbase) {\n        coinbase = block.coinbase;\n    }\n}\n"
      },
      "contracts/dev-contracts/Multicall3.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/// @title Multicall3\n/// @notice Aggregate results from multiple function calls\n/// @dev Multicall & Multicall2 backwards-compatible\n/// @dev Aggregate methods are marked `payable` to save 24 gas per call\n/// @author Michael Elliot <mike@makerdao.com>\n/// @author Joshua Levine <joshua@makerdao.com>\n/// @author Nick Johnson <arachnid@notdot.net>\n/// @author Andreas Bigger <andreas@nascent.xyz>\n/// @author Matt Solomon <matt@mattsolomon.dev>\ncontract Multicall3 {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    /// @notice Backwards-compatible call aggregation with Multicall\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return returnData An array of bytes containing the responses\n    function aggregate(Call[] calldata calls) public payable returns (uint256 blockNumber, bytes[] memory returnData) {\n        blockNumber = block.number;\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n        Call calldata call;\n        for (uint256 i = 0; i < length; ) {\n            bool success;\n            call = calls[i];\n            (success, returnData[i]) = call.target.call(call.callData);\n            require(success, \"Multicall3: call failed\");\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls without requiring success\n    /// @param requireSuccess If true, require all calls to succeed\n    /// @param calls An array of Call structs\n    /// @return returnData An array of Result structs\n    function tryAggregate(\n        bool requireSuccess,\n        Call[] calldata calls\n    ) public payable returns (Result[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call calldata call;\n        for (uint256 i = 0; i < length; ) {\n            Result memory result = returnData[i];\n            call = calls[i];\n            (result.success, result.returnData) = call.target.call(call.callData);\n            if (requireSuccess) require(result.success, \"Multicall3: call failed\");\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls and allow failures using tryAggregate\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return blockHash The hash of the block where the calls were executed\n    /// @return returnData An array of Result structs\n    function tryBlockAndAggregate(\n        bool requireSuccess,\n        Call[] calldata calls\n    ) public payable returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {\n        blockNumber = block.number;\n        blockHash = blockhash(block.number);\n        returnData = tryAggregate(requireSuccess, calls);\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls and allow failures using tryAggregate\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return blockHash The hash of the block where the calls were executed\n    /// @return returnData An array of Result structs\n    function blockAndAggregate(\n        Call[] calldata calls\n    ) public payable returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {\n        (blockNumber, blockHash, returnData) = tryBlockAndAggregate(true, calls);\n    }\n\n    /// @notice Aggregate calls, ensuring each returns success if required\n    /// @param calls An array of Call3 structs\n    /// @return returnData An array of Result structs\n    function aggregate3(Call3[] calldata calls) public payable returns (Result[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call3 calldata calli;\n        for (uint256 i = 0; i < length; ) {\n            Result memory result = returnData[i];\n            calli = calls[i];\n            (result.success, result.returnData) = calli.target.call(calli.callData);\n            assembly {\n                // Revert if the call fails and failure is not allowed\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                    // set data offset\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n                    // set length of revert string\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\n                    revert(0x00, 0x64)\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Aggregate calls with a msg value\n    /// @notice Reverts if msg.value is less than the sum of the call values\n    /// @param calls An array of Call3Value structs\n    /// @return returnData An array of Result structs\n    function aggregate3Value(Call3Value[] calldata calls) public payable returns (Result[] memory returnData) {\n        uint256 valAccumulator;\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call3Value calldata calli;\n        for (uint256 i = 0; i < length; ) {\n            Result memory result = returnData[i];\n            calli = calls[i];\n            uint256 val = calli.value;\n            // Humanity will be a Type V Kardashev Civilization before this overflows - andreas\n            // ~ 10^25 Wei in existence << ~ 10^76 size uint fits in a uint256\n            unchecked {\n                valAccumulator += val;\n            }\n            (result.success, result.returnData) = calli.target.call{value: val}(calli.callData);\n            assembly {\n                // Revert if the call fails and failure is not allowed\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                    // set data offset\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n                    // set length of revert string\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\n                    revert(0x00, 0x84)\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        // Finally, make sure the msg.value = SUM(call[0...i].value)\n        require(msg.value == valAccumulator, \"Multicall3: value mismatch\");\n    }\n\n    /// @notice Returns the block hash for the given block number\n    /// @param blockNumber The block number\n    function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\n        blockHash = blockhash(blockNumber);\n    }\n\n    /// @notice Returns the block number\n    function getBlockNumber() public view returns (uint256 blockNumber) {\n        blockNumber = block.number;\n    }\n\n    /// @notice Returns the block coinbase\n    function getCurrentBlockCoinbase() public view returns (address coinbase) {\n        coinbase = block.coinbase;\n    }\n\n    /// @notice Returns the block difficulty\n    function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\n        difficulty = block.prevrandao;\n    }\n\n    /// @notice Returns the block gas limit\n    function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n        gaslimit = block.gaslimit;\n    }\n\n    /// @notice Returns the block timestamp\n    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\n        timestamp = block.timestamp;\n    }\n\n    /// @notice Returns the (ETH) balance of a given address\n    function getEthBalance(address addr) public view returns (uint256 balance) {\n        balance = addr.balance;\n    }\n\n    /// @notice Returns the block hash of the last block\n    function getLastBlockHash() public view returns (bytes32 blockHash) {\n        unchecked {\n            blockHash = blockhash(block.number - 1);\n        }\n    }\n\n    /// @notice Gets the base fee of the given block\n    /// @notice Can revert if the BASEFEE opcode is not implemented by the given chain\n    function getBasefee() public view returns (uint256 basefee) {\n        basefee = block.basefee;\n    }\n\n    /// @notice Returns the chain id\n    function getChainId() public view returns (uint256 chainid) {\n        chainid = block.chainid;\n    }\n}\n"
      },
      "contracts/dev-contracts/ReturnSomething.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\ncontract ReturnSomething {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    fallback() external payable {\n        assembly {\n            return(0, 0x20)\n        }\n    }\n}\n"
      },
      "contracts/dev-contracts/RevertFallback.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\ncontract RevertFallback {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    fallback() external payable {\n        revert();\n    }\n}\n"
      },
      "contracts/dev-contracts/RevertReceiveAccount.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\n/// @title RevertReceiveAccount - An account which reverts receiving funds depending on the flag\n/// @dev Used for testing failed withdrawals from the ZKsync smart contract\ncontract RevertReceiveAccount {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    bool public revertReceive;\n\n    constructor() {\n        revertReceive = false;\n    }\n\n    function setRevertReceive(bool newValue) public {\n        revertReceive = newValue;\n    }\n\n    receive() external payable {\n        // Assert is used here to also simulate the out-of-gas error, since failed assertion\n        // consumes up all the remaining gas\n        assert(!revertReceive);\n    }\n}\n"
      },
      "contracts/dev-contracts/RevertTransferERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {TestnetERC20Token} from \"./TestnetERC20Token.sol\";\n\n/// @title RevertTransferERC20Token - A ERC20 token contract which can revert transfers depending on a flag\n/// @dev Used for testing failed ERC-20 withdrawals from the ZKsync smart contract\ncontract RevertTransferERC20 is TestnetERC20Token {\n    // add this to be excluded from coverage report\n    function test() internal override {}\n\n    bool public revertTransfer;\n\n    constructor(string memory name, string memory symbol, uint8 decimals) TestnetERC20Token(name, symbol, decimals) {\n        revertTransfer = false;\n    }\n\n    function setRevertTransfer(bool newValue) public {\n        revertTransfer = newValue;\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        // Assert is used here to also simulate the out-of-gas error, since failed assertion\n        // consumes up all the remaining gas\n        assert(!revertTransfer);\n\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n}\n"
      },
      "contracts/dev-contracts/SingletonFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/**\n * @title Singleton Factory (EIP-2470)\n * @notice Exposes CREATE2 (EIP-1014) to deploy bytecode on deterministic addresses based on initialization code\n * and salt.\n * @author Ricardo Guilherme Schmidt (Status Research & Development GmbH)\n */\ncontract SingletonFactory {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    /**\n     * @notice Deploys `_initCode` using `_salt` for defining the deterministic address.\n     * @param _initCode Initialization code.\n     * @param _salt Arbitrary value to modify resulting address.\n     * @return createdContract Created contract address.\n     */\n    function deploy(bytes memory _initCode, bytes32 _salt) public returns (address payable createdContract) {\n        assembly {\n            createdContract := create2(0, add(_initCode, 0x20), mload(_initCode), _salt)\n        }\n    }\n}\n"
      },
      "contracts/dev-contracts/TestnetERC20Token.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {ERC20} from \"@openzeppelin/contracts-v4/token/ERC20/ERC20.sol\";\n\ncontract TestnetERC20Token is ERC20 {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    uint8 private _decimals;\n\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n    }\n\n    function mint(address _to, uint256 _amount) public returns (bool) {\n        _mint(_to, _amount);\n        return true;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n}\n"
      },
      "contracts/dev-contracts/WETH9.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.8.24;\n\ncontract WETH9 {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    receive() external payable {\n        deposit();\n    }\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        require(balanceOf[msg.sender] >= wad, \"weth9, 1\");\n        balanceOf[msg.sender] -= wad;\n        // this is a hack so that zkfoundry works, but we are deploying WETH9 on L2 as well.\n        // payable(msg.sender).transfer(wad);\n        bool callSuccess;\n        address sender = msg.sender;\n        // Low-level assembly call, to avoid any memory copying (save gas)\n        assembly {\n            callSuccess := call(gas(), sender, wad, 0, 0, 0, 0)\n        }\n        if (!callSuccess) {\n            require(false, \"Withdraw failed\");\n        }\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {\n        require(balanceOf[src] >= wad, \"weth9, 2\");\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\n            require(allowance[src][msg.sender] >= wad, \"weth9, 3\");\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
      },
      "contracts/dev-contracts/interfaces/ITestnetERC20Token.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\ninterface ITestnetERC20Token {\n    function mint(address _to, uint256 _amount) external returns (bool);\n\n    function decimals() external returns (uint8);\n}\n"
      },
      "contracts/dev-contracts/test/AddressAliasHelperTest.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {AddressAliasHelper} from \"../../vendor/AddressAliasHelper.sol\";\n\ncontract AddressAliasHelperTest {\n    function applyL1ToL2Alias(address _l1Address) external pure returns (address) {\n        return AddressAliasHelper.applyL1ToL2Alias(_l1Address);\n    }\n\n    function undoL1ToL2Alias(address _l2Address) external pure returns (address) {\n        return AddressAliasHelper.undoL1ToL2Alias(_l2Address);\n    }\n}\n"
      },
      "contracts/dev-contracts/test/AdminFacetTest.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {AdminFacet} from \"../../state-transition/chain-deps/facets/Admin.sol\";\nimport {RollupDAManager} from \"../../state-transition/data-availability/RollupDAManager.sol\";\n\ncontract AdminFacetTest is AdminFacet {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    constructor(uint256 _l1ChainId) AdminFacet(_l1ChainId, RollupDAManager(address(0))) {\n        s.admin = msg.sender;\n        s.chainTypeManager = msg.sender;\n    }\n\n    function getPorterAvailability() external view returns (bool) {\n        return s.zkPorterIsAvailable;\n    }\n\n    function isValidator(address _validator) external view returns (bool) {\n        return s.validators[_validator];\n    }\n\n    function getPriorityTxMaxGasLimit() external view returns (uint256) {\n        return s.priorityTxMaxGasLimit;\n    }\n\n    function getAdmin() external view returns (address) {\n        return s.admin;\n    }\n\n    function getPendingAdmin() external view returns (address) {\n        return s.pendingAdmin;\n    }\n}\n"
      },
      "contracts/dev-contracts/test/CustomUpgradeTest.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Diamond} from \"../../state-transition/libraries/Diamond.sol\";\nimport {BaseZkSyncUpgrade, ProposedUpgrade} from \"../../upgrades/BaseZkSyncUpgrade.sol\";\n\ncontract CustomUpgradeTest is BaseZkSyncUpgrade {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    event Test();\n\n    /// @notice Placeholder function for custom logic for upgrading L1 contract.\n    /// Typically this function will never be used.\n    /// @param _customCallDataForUpgrade Custom data for upgrade, which may be interpreted differently for each upgrade.\n    function _upgradeL1Contract(bytes calldata _customCallDataForUpgrade) internal override {\n        keccak256(_customCallDataForUpgrade); // called to suppress compilation warning\n        emit Test();\n    }\n\n    /// @notice placeholder function for custom logic for post-upgrade logic.\n    /// Typically this function will never be used.\n    /// @param _customCallDataForUpgrade Custom data for an upgrade, which may be interpreted differently for each\n    /// upgrade.\n    function _postUpgrade(bytes calldata _customCallDataForUpgrade) internal override {}\n\n    /// @notice The main function that will be delegate-called by the chain.\n    /// @param _proposedUpgrade The upgrade to be executed.\n    function upgrade(ProposedUpgrade calldata _proposedUpgrade) public override returns (bytes32) {\n        (uint32 newMinorVersion, bool isPatchOnly) = _setNewProtocolVersion(_proposedUpgrade.newProtocolVersion);\n        _upgradeL1Contract(_proposedUpgrade.l1ContractsUpgradeCalldata);\n        _upgradeVerifier(_proposedUpgrade.verifier, _proposedUpgrade.verifierParams);\n        _setBaseSystemContracts(_proposedUpgrade.bootloaderHash, _proposedUpgrade.defaultAccountHash, isPatchOnly);\n\n        bytes32 txHash;\n        txHash = _setL2SystemContractUpgrade(_proposedUpgrade.l2ProtocolUpgradeTx, newMinorVersion, isPatchOnly);\n\n        _postUpgrade(_proposedUpgrade.postUpgradeCalldata);\n\n        emit UpgradeComplete(_proposedUpgrade.newProtocolVersion, txHash, _proposedUpgrade);\n\n        return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE;\n    }\n}\n"
      },
      "contracts/dev-contracts/test/DiamondCutTestContract.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Diamond} from \"../../state-transition/libraries/Diamond.sol\";\nimport {GettersFacet} from \"../../state-transition/chain-deps/facets/Getters.sol\";\n\ncontract DiamondCutTestContract is GettersFacet {\n    function diamondCut(Diamond.DiamondCutData memory _diamondCut) external {\n        Diamond.diamondCut(_diamondCut);\n    }\n}\n"
      },
      "contracts/dev-contracts/test/DiamondProxyTest.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Diamond} from \"../../state-transition/libraries/Diamond.sol\";\nimport {ZKChainBase} from \"../../state-transition/chain-deps/facets/ZKChainBase.sol\";\n\ncontract DiamondProxyTest is ZKChainBase {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    function setFreezability(bool _freeze) external returns (bytes32) {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n        diamondStorage.isFrozen = _freeze;\n        return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE;\n    }\n}\n"
      },
      "contracts/dev-contracts/test/DummyAdminFacet.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {ZKChainBase} from \"../../state-transition/chain-deps/facets/ZKChainBase.sol\";\n\ncontract DummyAdminFacet is ZKChainBase {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    function getName() external pure returns (string memory) {\n        return \"DummyAdminFacet\";\n    }\n\n    function dummySetValidator(address _validator) external {\n        s.validators[_validator] = true;\n    }\n}\n"
      },
      "contracts/dev-contracts/test/DummyAdminFacetNoOverlap.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Diamond} from \"../../state-transition/libraries/Diamond.sol\";\nimport {ZKChainBase} from \"../../state-transition/chain-deps/facets/ZKChainBase.sol\";\nimport {IL1AssetRouter} from \"../../bridge/asset-router/IL1AssetRouter.sol\";\nimport {DataEncoding} from \"../../common/libraries/DataEncoding.sol\";\n\n/// selectors do not overlap with normal facet selectors (getName does not count)\ncontract DummyAdminFacetNoOverlap is ZKChainBase {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    function getName() external pure returns (string memory) {\n        return \"DummyAdminFacetNoOverlap\";\n    }\n\n    function executeUpgradeNoOverlap(Diamond.DiamondCutData calldata _diamondCut) external {\n        Diamond.diamondCut(_diamondCut);\n    }\n\n    function receiveEther() external payable {}\n}\n"
      },
      "contracts/dev-contracts/test/DummyBridgehub.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {ETH_TOKEN_ADDRESS} from \"../../common/Config.sol\";\nimport {L2_NATIVE_TOKEN_VAULT_ADDR} from \"../../common/L2ContractAddresses.sol\";\nimport {IMessageRoot} from \"../../bridgehub/IMessageRoot.sol\";\n\nimport {IGetters} from \"../../state-transition/chain-interfaces/IGetters.sol\";\n\n/// @title DummyBridgehub\n/// @notice A test smart contract that allows to set State Transition Manager for a given chain\ncontract DummyBridgehub {\n    IMessageRoot public messageRoot;\n\n    address public zkChain;\n\n    address public sharedBridge;\n\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    function baseTokenAssetId(uint256) external view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    block.chainid,\n                    L2_NATIVE_TOKEN_VAULT_ADDR,\n                    ETH_TOKEN_ADDRESS\n                    // bytes32(uint256(uint160(IGetters(msg.sender).getBaseToken())))\n                )\n            );\n    }\n\n    function setMessageRoot(address _messageRoot) public {\n        messageRoot = IMessageRoot(_messageRoot);\n    }\n\n    function setZKChain(uint256, address _zkChain) external {\n        zkChain = _zkChain;\n    }\n\n    function getZKChain(uint256) external view returns (address) {\n        return address(0);\n    }\n\n    function setSharedBridge(address addr) external {\n        sharedBridge = addr;\n    }\n}\n"
      },
      "contracts/dev-contracts/test/DummyBridgehubSetter.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Bridgehub} from \"../../bridgehub/Bridgehub.sol\";\n\ncontract DummyBridgehubSetter is Bridgehub {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    /// @notice Constructor\n    constructor(\n        uint256 _l1ChainId,\n        address _owner,\n        uint256 _maxNumberOfZKChains\n    ) Bridgehub(_l1ChainId, _owner, _maxNumberOfZKChains) {}\n\n    function setZKChain(uint256 _chainId, address _zkChain) external {\n        _registerNewZKChain(_chainId, _zkChain, true);\n    }\n\n    function setCTM(uint256 _chainId, address _ctm) external {\n        chainTypeManager[_chainId] = _ctm;\n    }\n}\n"
      },
      "contracts/dev-contracts/test/DummyChainTypeManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {EnumerableMap} from \"@openzeppelin/contracts-v4/utils/structs/EnumerableMap.sol\";\n\nimport {ChainTypeManager} from \"../../state-transition/ChainTypeManager.sol\";\n\n/// @title DummyExecutor\n/// @notice A test smart contract implementing the IExecutor interface to simulate Executor behavior for testing purposes.\ncontract DummyChainTypeManager is ChainTypeManager {\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    address zkChain;\n\n    /// @notice Constructor\n    constructor() ChainTypeManager(address(0)) {}\n\n    function setZKChain(uint256 _chainId, address _zkChain) external {\n        zkChain = _zkChain;\n    }\n}\n"
      },
      "contracts/dev-contracts/test/DummyChainTypeManagerForValidatorTimelock.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\n/// @title DummyChainTypeManagerForValidatorTimelock\n/// @notice A test smart contract implementing the IExecutor interface to simulate Executor behavior for testing purposes.\ncontract DummyChainTypeManagerForValidatorTimelock {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    address public chainAdmin;\n    address public zkChainAddress;\n\n    constructor(address _chainAdmin, address _zkChain) {\n        chainAdmin = _chainAdmin;\n        zkChainAddress = _zkChain;\n    }\n\n    function getChainAdmin(uint256) external view returns (address) {\n        return chainAdmin;\n    }\n\n    function getZKChain(uint256) public view returns (address) {\n        return zkChainAddress;\n    }\n\n    function getHyperchain(uint256 _chainId) external view returns (address) {\n        return getZKChain(_chainId);\n    }\n\n    function setZKChain(uint256, address _zkChain) external {\n        zkChainAddress = _zkChain;\n    }\n}\n"
      },
      "contracts/dev-contracts/test/DummyChainTypeManagerWithBridgeHubAddress.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {EnumerableMap} from \"@openzeppelin/contracts-v4/utils/structs/EnumerableMap.sol\";\n\nimport {ChainTypeManager} from \"../../state-transition/ChainTypeManager.sol\";\n\n/// @title DummyExecutor\n/// @notice A test smart contract implementing the IExecutor interface to simulate Executor behavior for testing purposes.\ncontract DummyChainTypeManagerWBH is ChainTypeManager {\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n\n    address zkChain;\n    /// @notice Constructor\n    constructor(address bridgeHub) ChainTypeManager(bridgeHub) {}\n\n    function setZKChain(uint256 _chainId, address _zkChain) external {\n        zkChain = _zkChain;\n    }\n\n    // add this to be excluded from coverage report\n    function test() internal {}\n}\n"
      },
      "contracts/dev-contracts/test/DummyERC20BytesTransferReturnValue.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\ncontract DummyERC20BytesTransferReturnValue {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    bytes returnValue;\n\n    constructor(bytes memory _returnValue) {\n        returnValue = _returnValue;\n    }\n\n    function transfer(address _recipient, uint256 _amount) external view returns (bytes memory) {\n        // Hack to prevent Solidity warnings\n        _recipient;\n        _amount;\n\n        return returnValue;\n    }\n}\n"
      },
      "contracts/dev-contracts/test/DummyERC20NoTransferReturnValue.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\ncontract DummyERC20NoTransferReturnValue {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    function transfer(address recipient, uint256 amount) external {}\n}\n"
      },
      "contracts/dev-contracts/test/DummyEraBaseTokenBridge.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\ncontract DummyEraBaseTokenBridge {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _originalCaller,\n        address _l1Token,\n        uint256 _amount\n    ) external payable {}\n}\n"
      },
      "contracts/dev-contracts/test/DummySharedBridge.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IERC20} from \"@openzeppelin/contracts-v4/token/ERC20/IERC20.sol\";\n\nimport {L2TransactionRequestTwoBridgesInner} from \"../../bridgehub/IBridgehub.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable-v4/security/PausableUpgradeable.sol\";\nimport {TWO_BRIDGES_MAGIC_VALUE, ETH_TOKEN_ADDRESS} from \"../../common/Config.sol\";\nimport {IL1NativeTokenVault} from \"../../bridge/ntv/L1NativeTokenVault.sol\";\nimport {L2_NATIVE_TOKEN_VAULT_ADDR} from \"../../common/L2ContractAddresses.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts-v4/token/ERC20/utils/SafeERC20.sol\";\nimport {IL2SharedBridgeLegacy} from \"../../bridge/interfaces/IL2SharedBridgeLegacy.sol\";\nimport {IL2SharedBridgeLegacyFunctions} from \"../../bridge/interfaces/IL2SharedBridgeLegacyFunctions.sol\";\n\ncontract DummySharedBridge is PausableUpgradeable {\n    using SafeERC20 for IERC20;\n\n    IL1NativeTokenVault public nativeTokenVault;\n\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        bytes32 assetId,\n        uint256 amount\n    );\n\n    bytes32 dummyL2DepositTxHash;\n\n    /// @dev Maps token balances for each chain to prevent unauthorized spending across zkChains.\n    /// This serves as a security measure until hyperbridging is implemented.\n    mapping(uint256 chainId => mapping(address l1Token => uint256 balance)) public chainBalance;\n\n    /// @dev Indicates whether the hyperbridging is enabled for a given chain.\n\n    address l1ReceiverReturnInFinalizeWithdrawal;\n    address l1TokenReturnInFinalizeWithdrawal;\n    uint256 amountReturnInFinalizeWithdrawal;\n\n    /// @dev A mapping assetId => assetHandlerAddress\n    /// @dev Tracks the address of Asset Handler contracts, where bridged funds are locked for each asset\n    /// @dev P.S. this liquidity was locked directly in SharedBridge before\n    mapping(bytes32 assetId => address assetHandlerAddress) public assetHandlerAddress;\n\n    constructor(bytes32 _dummyL2DepositTxHash) {\n        dummyL2DepositTxHash = _dummyL2DepositTxHash;\n    }\n\n    function setDataToBeReturnedInFinalizeWithdrawal(address _l1Receiver, address _l1Token, uint256 _amount) external {\n        l1ReceiverReturnInFinalizeWithdrawal = _l1Receiver;\n        l1TokenReturnInFinalizeWithdrawal = _l1Token;\n        amountReturnInFinalizeWithdrawal = _amount;\n    }\n\n    function receiveEth(uint256 _chainId) external payable {}\n\n    function depositLegacyErc20Bridge(\n        address, //_msgSender,\n        address, //_l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256, //_l2TxGasLimit,\n        uint256, //_l2TxGasPerPubdataByte,\n        address //_refundRecipient\n    ) external payable returns (bytes32 txHash) {\n        txHash = dummyL2DepositTxHash;\n\n        // Legacy bridge requires this logic to work properly\n        IERC20(_l1Token).transferFrom(msg.sender, address(this), _amount);\n    }\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address, //_depositSender,\n        address, //_l1Token,\n        uint256, //_amount,\n        bytes32, //_l2TxHash,\n        uint256, //_l2BatchNumber,\n        uint256, //_l2MessageIndex,\n        uint16, //_l2TxNumberInBatch,\n        bytes32[] calldata // _merkleProof\n    ) external {}\n\n    function claimFailedDeposit(\n        uint256, // _chainId,\n        address, // _depositSender,\n        address, // _l1Asset,\n        uint256, // _amount,\n        bytes32, // _l2TxHash,\n        uint256, // _l2BatchNumber,\n        uint256, // _l2MessageIndex,\n        uint16, // _l2TxNumberInBatch,\n        bytes32[] calldata //_merkleProof\n    ) external {}\n\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256, //_l2BatchNumber,\n        uint256, //_l2MessageIndex,\n        uint16, //_l2TxNumberInBatch,\n        bytes calldata, //_message,\n        bytes32[] calldata //_merkleProof\n    ) external view returns (address l1Receiver, address l1Token, uint256 amount) {\n        l1Receiver = l1ReceiverReturnInFinalizeWithdrawal;\n        l1Token = l1TokenReturnInFinalizeWithdrawal;\n        amount = amountReturnInFinalizeWithdrawal;\n    }\n\n    event Debugger(uint256);\n\n    function pause() external {\n        _pause();\n    }\n\n    function unpause() external {\n        _unpause();\n    }\n\n    // This function expects abi encoded data\n    function _parseL2WithdrawalMessage(\n        bytes memory _l2ToL1message\n    ) internal view returns (address l1Receiver, address l1Token, uint256 amount) {\n        (l1Receiver, l1Token, amount) = abi.decode(_l2ToL1message, (address, address, uint256));\n    }\n\n    // simple function to just transfer the funds\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount) {\n        (l1Receiver, l1Token, amount) = _parseL2WithdrawalMessage(_message);\n\n        if (l1Token == address(1)) {\n            bool callSuccess;\n            // Low-level assembly call, to avoid any memory copying (save gas)\n            assembly {\n                callSuccess := call(gas(), l1Receiver, amount, 0, 0, 0, 0)\n            }\n            require(callSuccess, \"ShB: withdraw failed\");\n        } else {\n            // Withdraw funds\n            IERC20(l1Token).safeTransfer(l1Receiver, amount);\n        }\n    }\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        bytes32 _assetId,\n        address _originalCaller,\n        uint256 _amount\n    ) external payable whenNotPaused {\n        // Dummy bridge supports only working with ETH for simplicity.\n        require(msg.value == _amount, \"L1AR: msg.value not equal to amount\");\n\n        chainBalance[_chainId][address(1)] += _amount;\n\n        // Note that we don't save the deposited amount, as this is for the base token, which gets sent to the refundRecipient if the tx fails\n        emit BridgehubDepositBaseTokenInitiated(_chainId, _originalCaller, _assetId, _amount);\n    }\n\n    function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.transferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    function bridgehubDeposit(\n        uint256,\n        address _originalCaller,\n        uint256,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request) {\n        (address _l1Token, uint256 _depositAmount, address _l2Receiver) = abi.decode(\n            _data,\n            (address, uint256, address)\n        );\n        uint256 amount;\n\n        if (_l1Token == ETH_TOKEN_ADDRESS) {\n            amount = msg.value;\n            require(_depositAmount == 0, \"ShB wrong withdraw amount\");\n        } else {\n            require(msg.value == 0, \"ShB m.v > 0 for BH d.it 2\");\n            amount = _depositAmount;\n\n            uint256 withdrawAmount = _depositFunds(_originalCaller, IERC20(_l1Token), _depositAmount);\n            require(withdrawAmount == _depositAmount, \"5T\"); // The token has non-standard transfer logic\n        }\n\n        bytes memory l2TxCalldata = abi.encodeCall(\n            IL2SharedBridgeLegacyFunctions.finalizeDeposit,\n            (_originalCaller, _l2Receiver, _l1Token, amount, new bytes(0))\n        );\n        bytes32 txDataHash = keccak256(abi.encode(_originalCaller, _l1Token, amount));\n\n        request = L2TransactionRequestTwoBridgesInner({\n            magicValue: TWO_BRIDGES_MAGIC_VALUE,\n            l2Contract: address(0xCAFE),\n            l2Calldata: l2TxCalldata,\n            factoryDeps: new bytes[](0),\n            txDataHash: txDataHash\n        });\n    }\n\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external {}\n\n    /// @dev Sets the L1ERC20Bridge contract address. Should be called only once.\n    function setNativeTokenVault(IL1NativeTokenVault _nativeTokenVault) external {\n        require(address(nativeTokenVault) == address(0), \"L1AR: legacy bridge already set\");\n        require(address(_nativeTokenVault) != address(0), \"L1AR: legacy bridge 0\");\n        nativeTokenVault = _nativeTokenVault;\n    }\n\n    /// @dev Used to set the assedAddress for a given assetId.\n    function setAssetHandlerAddressThisChain(bytes32 _additionalData, address _assetHandlerAddress) external {\n        address sender = msg.sender == address(nativeTokenVault) ? L2_NATIVE_TOKEN_VAULT_ADDR : msg.sender;\n        bytes32 assetId = keccak256(abi.encode(uint256(block.chainid), sender, _additionalData));\n        assetHandlerAddress[assetId] = _assetHandlerAddress;\n        // assetDeploymentTracker[assetId] = sender;\n        // emit AssetDeploymentTrackerRegistered(assetId, _assetHandlerAddress, _additionalData, sender);\n    }\n\n    // add this to be excluded from coverage report\n    function test() internal {}\n}\n"
      },
      "contracts/dev-contracts/test/DummyTransactionFiltererFalse.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {ITransactionFilterer} from \"../../state-transition/chain-interfaces/ITransactionFilterer.sol\";\n\ncontract TransactionFiltererFalse is ITransactionFilterer {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    function isTransactionAllowed(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory,\n        address\n    ) external pure returns (bool) {\n        return false;\n    }\n}\n"
      },
      "contracts/dev-contracts/test/DummyTransactionFiltererTrue.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {ITransactionFilterer} from \"../../state-transition/chain-interfaces/ITransactionFilterer.sol\";\n\ncontract TransactionFiltererTrue is ITransactionFilterer {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    function isTransactionAllowed(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory,\n        address\n    ) external pure returns (bool) {\n        return true;\n    }\n}\n"
      },
      "contracts/dev-contracts/test/DummyZKChain.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {MailboxFacet} from \"../../state-transition/chain-deps/facets/Mailbox.sol\";\nimport {FeeParams, PubdataPricingMode} from \"../../state-transition/chain-deps/ZKChainStorage.sol\";\n\ncontract DummyZKChain is MailboxFacet {\n    constructor(\n        address bridgeHubAddress,\n        uint256 _eraChainId,\n        uint256 _l1ChainId\n    ) MailboxFacet(_eraChainId, _l1ChainId) {\n        s.bridgehub = bridgeHubAddress;\n    }\n\n    function getEraChainId() public view returns (uint256) {\n        return ERA_CHAIN_ID;\n    }\n\n    function setBridgeHubAddress(address bridgeHubAddress) public {\n        s.bridgehub = bridgeHubAddress;\n    }\n\n    function setBaseTokenGasMultiplierPrice(uint128 nominator, uint128 denominator) public {\n        s.baseTokenGasPriceMultiplierNominator = nominator;\n        s.baseTokenGasPriceMultiplierDenominator = denominator;\n    }\n\n    function getBridgeHubAddress() public view returns (address) {\n        return s.bridgehub;\n    }\n\n    function setFeeParams() external {\n        FeeParams memory _feeParams = _randomFeeParams();\n        s.feeParams = _feeParams;\n        s.priorityTxMaxGasLimit = type(uint256).max;\n    }\n\n    function _randomFeeParams() internal pure returns (FeeParams memory) {\n        return\n            FeeParams({\n                pubdataPricingMode: PubdataPricingMode.Rollup,\n                batchOverheadL1Gas: 1_000_000,\n                maxPubdataPerBatch: 110_000,\n                maxL2GasPerBatch: 80_000_000,\n                priorityTxMaxPubdata: 99_000,\n                minimalL2GasPrice: 250_000_000\n            });\n    }\n\n    function genesisUpgrade(\n        address _l1GenesisUpgrade,\n        bytes calldata _forceDeploymentData,\n        bytes[] calldata _factoryDeps\n    ) external {}\n\n    // add this to be excluded from coverage report\n    function test() internal {}\n}\n"
      },
      "contracts/dev-contracts/test/ExecutorProvingTest.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {ExecutorFacet} from \"../../state-transition/chain-deps/facets/Executor.sol\";\nimport {PubdataPricingMode} from \"../../state-transition/chain-deps/ZKChainStorage.sol\";\nimport {LogProcessingOutput} from \"../../state-transition/chain-interfaces/IExecutor.sol\";\nimport {LogProcessingOutput} from \"../../state-transition/chain-interfaces/IExecutor.sol\";\n\ncontract ExecutorProvingTest is ExecutorFacet {\n    constructor() ExecutorFacet(block.chainid) {}\n\n    function getBatchProofPublicInput(\n        bytes32 _prevBatchCommitment,\n        bytes32 _currentBatchCommitment\n    ) external pure returns (uint256) {\n        return _getBatchProofPublicInput(_prevBatchCommitment, _currentBatchCommitment);\n    }\n\n    function createBatchCommitment(\n        CommitBatchInfo calldata _newBatchData,\n        bytes32 _stateDiffHash,\n        bytes32[] memory _blobCommitments,\n        bytes32[] memory _blobHashes\n    ) external view returns (bytes32) {\n        return _createBatchCommitment(_newBatchData, _stateDiffHash, _blobCommitments, _blobHashes);\n    }\n\n    function processL2Logs(\n        CommitBatchInfo calldata _newBatch,\n        bytes32 _expectedSystemContractUpgradeTxHash,\n        PubdataPricingMode\n    ) external view returns (LogProcessingOutput memory logOutput) {\n        return _processL2Logs(_newBatch, _expectedSystemContractUpgradeTxHash);\n    }\n\n    /// Sets the DefaultAccount Hash and Bootloader Hash.\n    function setHashes(bytes32 l2DefaultAccountBytecodeHash, bytes32 l2BootloaderBytecodeHash) external {\n        s.l2DefaultAccountBytecodeHash = l2DefaultAccountBytecodeHash;\n        s.l2BootloaderBytecodeHash = l2BootloaderBytecodeHash;\n        s.zkPorterIsAvailable = false;\n    }\n\n    // add this to be excluded from coverage report\n    function test() internal {}\n}\n"
      },
      "contracts/dev-contracts/test/FullMerkleTest.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {FullMerkle} from \"../../common/libraries/FullMerkle.sol\";\n\ncontract FullMerkleTest {\n    using FullMerkle for FullMerkle.FullTree;\n\n    FullMerkle.FullTree internal tree;\n\n    constructor(bytes32 zero) {\n        tree.setup(zero);\n    }\n\n    function pushNewLeaf(bytes32 _item) external {\n        tree.pushNewLeaf(_item);\n    }\n\n    function updateLeaf(uint256 _index, bytes32 _item) external {\n        tree.updateLeaf(_index, _item);\n    }\n\n    function updateAllLeaves(bytes32[] memory _items) external {\n        tree.updateAllLeaves(_items);\n    }\n\n    function updateAllNodesAtHeight(uint256 _height, bytes32[] memory _items) external {\n        tree.updateAllNodesAtHeight(_height, _items);\n    }\n\n    function root() external view returns (bytes32) {\n        return tree.root();\n    }\n\n    function height() external view returns (uint256) {\n        return tree._height;\n    }\n\n    function index() external view returns (uint256) {\n        return tree._leafNumber;\n    }\n\n    function node(uint256 _height, uint256 _index) external view returns (bytes32) {\n        return tree._nodes[_height][_index];\n    }\n\n    function nodeCount(uint256 _height) external view returns (uint256) {\n        return tree._nodes[_height].length;\n    }\n\n    function zeros(uint256 _index) external view returns (bytes32) {\n        return tree._zeros[_index];\n    }\n}\n"
      },
      "contracts/dev-contracts/test/IncrementalMerkleTest.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {DynamicIncrementalMerkle} from \"../../common/libraries/DynamicIncrementalMerkle.sol\";\n\ncontract IncrementalMerkleTest {\n    using DynamicIncrementalMerkle for DynamicIncrementalMerkle.Bytes32PushTree;\n\n    DynamicIncrementalMerkle.Bytes32PushTree internal tree;\n\n    constructor(bytes32 zero) {\n        tree.setup(zero);\n    }\n\n    function push(bytes32 _item) external {\n        tree.push(_item);\n    }\n\n    function root() external view returns (bytes32) {\n        return tree.root();\n    }\n\n    function height() external view returns (uint256) {\n        return tree.height();\n    }\n\n    function index() external view returns (uint256) {\n        return tree._nextLeafIndex;\n    }\n\n    function side(uint256 _index) external view returns (bytes32) {\n        return tree._sides[_index];\n    }\n\n    function zeros(uint256 _index) external view returns (bytes32) {\n        return tree._zeros[_index];\n    }\n}\n"
      },
      "contracts/dev-contracts/test/L1ERC20BridgeTest.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {L1ERC20Bridge} from \"../../bridge/L1ERC20Bridge.sol\";\nimport {IL1NativeTokenVault} from \"../../bridge/ntv/IL1NativeTokenVault.sol\";\nimport {IBridgehub} from \"../../bridgehub/IBridgehub.sol\";\nimport {IL1AssetRouter} from \"../../bridge/asset-router/IL1AssetRouter.sol\";\nimport {IL1Nullifier} from \"../../bridge/interfaces/IL1Nullifier.sol\";\n\n/// @author Matter Labs\ncontract L1ERC20BridgeTest is L1ERC20Bridge {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    constructor(\n        IBridgehub _zkSync\n    ) L1ERC20Bridge(IL1Nullifier(address(0)), IL1AssetRouter(address(0)), IL1NativeTokenVault(address(0)), 1) {}\n}\n"
      },
      "contracts/dev-contracts/test/L2NativeTokenVaultDev.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {BeaconProxy} from \"@openzeppelin/contracts-v4/proxy/beacon/BeaconProxy.sol\";\nimport {Create2} from \"@openzeppelin/contracts-v4/utils/Create2.sol\";\nimport {IBeacon} from \"@openzeppelin/contracts-v4/proxy/beacon/IBeacon.sol\";\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts-v4/proxy/beacon/UpgradeableBeacon.sol\";\n\nimport {INativeTokenVault} from \"contracts/bridge/ntv/INativeTokenVault.sol\";\nimport {NativeTokenVault} from \"contracts/bridge/ntv/NativeTokenVault.sol\";\nimport {L2NativeTokenVault} from \"contracts/bridge/ntv/L2NativeTokenVault.sol\";\nimport {BridgedStandardERC20} from \"contracts/bridge/BridgedStandardERC20.sol\";\n\n/// @author Matter Labs\n/// @notice This is used for fast debugging of the L2NTV by running it in L1 context, i.e. normal foundry instead of foundry --zksync.\ncontract L2NativeTokenVaultDev is L2NativeTokenVault {\n    constructor(\n        uint256 _l1ChainId,\n        address _aliasedOwner,\n        bytes32 _l2TokenProxyBytecodeHash,\n        address _legacySharedBridge,\n        address _bridgedTokenBeacon,\n        bool _contractsDeployedAlready,\n        address _wethToken,\n        bytes32 _baseTokenAssetId\n    )\n        L2NativeTokenVault(\n            _l1ChainId,\n            _aliasedOwner,\n            _l2TokenProxyBytecodeHash,\n            _legacySharedBridge,\n            _bridgedTokenBeacon,\n            _contractsDeployedAlready,\n            _wethToken,\n            _baseTokenAssetId\n        )\n    {}\n\n    /// @notice copied from L1NTV for L1 compilation\n    function calculateCreate2TokenAddress(\n        uint256 _originChainId,\n        address _l1Token\n    ) public view override(L2NativeTokenVault) returns (address) {\n        bytes32 salt = _getCreate2Salt(_originChainId, _l1Token);\n        return\n            Create2.computeAddress(\n                salt,\n                keccak256(abi.encodePacked(type(BeaconProxy).creationCode, abi.encode(bridgedTokenBeacon, \"\")))\n            );\n    }\n\n    function deployBridgedStandardERC20(address _owner) external {\n        _transferOwnership(_owner);\n\n        address l2StandardToken = address(new BridgedStandardERC20{salt: bytes32(0)}());\n\n        UpgradeableBeacon tokenBeacon = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n\n        tokenBeacon.transferOwnership(owner());\n        bridgedTokenBeacon = IBeacon(address(tokenBeacon));\n        emit L2TokenBeaconUpdated(address(bridgedTokenBeacon), L2_TOKEN_PROXY_BYTECODE_HASH);\n    }\n\n    function test() external pure {\n        // test\n    }\n\n    function _deployBeaconProxy(bytes32 _salt, uint256) internal virtual override returns (BeaconProxy proxy) {\n        // Use CREATE2 to deploy the BeaconProxy\n        address proxyAddress = Create2.deploy(\n            0,\n            _salt,\n            abi.encodePacked(type(BeaconProxy).creationCode, abi.encode(bridgedTokenBeacon, \"\"))\n        );\n        return BeaconProxy(payable(proxyAddress));\n    }\n}\n"
      },
      "contracts/dev-contracts/test/MailboxFacetTest.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {FeeParams} from \"../../state-transition/chain-deps/ZKChainStorage.sol\";\nimport {MailboxFacet} from \"../../state-transition/chain-deps/facets/Mailbox.sol\";\nimport {REQUIRED_L2_GAS_PRICE_PER_PUBDATA} from \"../../common/Config.sol\";\n\ncontract MailboxFacetTest is MailboxFacet {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    constructor(uint256 _eraChainId, uint256 _l1ChainId) MailboxFacet(_eraChainId, _l1ChainId) {\n        s.admin = msg.sender;\n    }\n\n    function setFeeParams(FeeParams memory _feeParams) external {\n        s.feeParams = _feeParams;\n    }\n\n    function getL2GasPrice(uint256 _l1GasPrice) external view returns (uint256) {\n        return _deriveL2GasPrice(_l1GasPrice, REQUIRED_L2_GAS_PRICE_PER_PUBDATA);\n    }\n}\n"
      },
      "contracts/dev-contracts/test/MerkleTest.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Merkle} from \"../../common/libraries/Merkle.sol\";\n\ncontract MerkleTest {\n    function calculateRoot(\n        bytes32[] calldata _path,\n        uint256 _index,\n        bytes32 _itemHash\n    ) external pure returns (bytes32) {\n        return Merkle.calculateRoot(_path, _index, _itemHash);\n    }\n\n    function calculateRoot(\n        bytes32[] calldata _startPath,\n        bytes32[] calldata _endPath,\n        uint256 _startIndex,\n        bytes32[] calldata _itemHashes\n    ) external pure returns (bytes32) {\n        return Merkle.calculateRootPaths(_startPath, _endPath, _startIndex, _itemHashes);\n    }\n}\n"
      },
      "contracts/dev-contracts/test/MockExecutor.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {ZKChainBase} from \"../../state-transition/chain-deps/facets/ZKChainBase.sol\";\n\ncontract MockExecutorFacet is ZKChainBase {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    function saveL2LogsRootHash(uint256 _batchNumber, bytes32 _l2LogsTreeRoot) external {\n        s.totalBatchesExecuted = _batchNumber;\n        s.l2LogsRootHashes[_batchNumber] = _l2LogsTreeRoot;\n    }\n\n    function setExecutedBatches(uint256 _batchNumber) external {\n        s.totalBatchesExecuted = _batchNumber;\n        s.totalBatchesCommitted = _batchNumber;\n        s.totalBatchesVerified = _batchNumber;\n    }\n}\n"
      },
      "contracts/dev-contracts/test/PriorityQueueTest.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {PriorityQueue, PriorityOperation} from \"../../state-transition/libraries/PriorityQueue.sol\";\n\ncontract PriorityQueueTest {\n    PriorityQueue.Queue priorityQueue;\n\n    function getFirstUnprocessedPriorityTx() external view returns (uint256) {\n        return PriorityQueue.getFirstUnprocessedPriorityTx(priorityQueue);\n    }\n\n    function getTotalPriorityTxs() external view returns (uint256) {\n        return PriorityQueue.getTotalPriorityTxs(priorityQueue);\n    }\n\n    function getSize() external view returns (uint256) {\n        return PriorityQueue.getSize(priorityQueue);\n    }\n\n    function isEmpty() external view returns (bool) {\n        return PriorityQueue.isEmpty(priorityQueue);\n    }\n\n    function pushBack(PriorityOperation memory _operation) external {\n        return PriorityQueue.pushBack(priorityQueue, _operation);\n    }\n\n    function front() external view returns (PriorityOperation memory) {\n        return PriorityQueue.front(priorityQueue);\n    }\n\n    function popFront() external returns (PriorityOperation memory operation) {\n        return PriorityQueue.popFront(priorityQueue);\n    }\n}\n"
      },
      "contracts/dev-contracts/test/PriorityTreeTest.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {PriorityTree, PriorityOpsBatchInfo, PriorityTreeCommitment} from \"../../state-transition/libraries/PriorityTree.sol\";\n\ncontract PriorityTreeTest {\n    PriorityTree.Tree priorityTree;\n\n    constructor() {\n        PriorityTree.setup(priorityTree, 0);\n    }\n\n    function getFirstUnprocessedPriorityTx() external view returns (uint256) {\n        return PriorityTree.getFirstUnprocessedPriorityTx(priorityTree);\n    }\n\n    function getTotalPriorityTxs() external view returns (uint256) {\n        return PriorityTree.getTotalPriorityTxs(priorityTree);\n    }\n\n    function getSize() external view returns (uint256) {\n        return PriorityTree.getSize(priorityTree);\n    }\n\n    function push(bytes32 _hash) external {\n        return PriorityTree.push(priorityTree, _hash);\n    }\n\n    function getRoot() external view returns (bytes32) {\n        return PriorityTree.getRoot(priorityTree);\n    }\n\n    function processBatch(PriorityOpsBatchInfo calldata _priorityOpsData) external {\n        PriorityTree.processBatch(priorityTree, _priorityOpsData);\n    }\n\n    function getCommitment() external view returns (PriorityTreeCommitment memory) {\n        return PriorityTree.getCommitment(priorityTree);\n    }\n\n    function initFromCommitment(PriorityTreeCommitment calldata _commitment) external {\n        PriorityTree.initFromCommitment(priorityTree, _commitment);\n    }\n\n    function getZero() external view returns (bytes32) {\n        return priorityTree.tree._zeros[0];\n    }\n}\n"
      },
      "contracts/dev-contracts/test/ReenterGovernance.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IGovernance} from \"../../governance/IGovernance.sol\";\nimport {Call} from \"../../governance/Common.sol\";\n\ncontract ReenterGovernance {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    IGovernance governance;\n\n    // Store call, predecessor and salt separately,\n    // because Operation struct can't be stored on storage.\n    Call call;\n    bytes32 predecessor;\n    bytes32 salt;\n\n    // Save one value to determine whether reentrancy already happen.\n    bool alreadyReentered;\n\n    enum FunctionToCall {\n        Unset,\n        Execute,\n        ExecuteInstant,\n        Cancel\n    }\n\n    FunctionToCall functionToCall;\n\n    function initialize(\n        IGovernance _governance,\n        IGovernance.Operation memory _op,\n        FunctionToCall _functionToCall\n    ) external {\n        governance = _governance;\n        require(_op.calls.length == 1, \"Only 1 calls supported\");\n        call = _op.calls[0];\n        predecessor = _op.predecessor;\n        salt = _op.salt;\n\n        functionToCall = _functionToCall;\n    }\n\n    fallback() external payable {\n        if (!alreadyReentered) {\n            alreadyReentered = true;\n            Call[] memory calls = new Call[](1);\n            calls[0] = call;\n            IGovernance.Operation memory op = IGovernance.Operation({\n                calls: calls,\n                predecessor: predecessor,\n                salt: salt\n            });\n\n            if (functionToCall == ReenterGovernance.FunctionToCall.Execute) {\n                governance.execute(op);\n            } else if (functionToCall == ReenterGovernance.FunctionToCall.ExecuteInstant) {\n                governance.executeInstant(op);\n            } else if (functionToCall == ReenterGovernance.FunctionToCall.Cancel) {\n                bytes32 opId = governance.hashOperation(op);\n                governance.cancel(opId);\n            } else {\n                revert(\"Unset function to call\");\n            }\n        }\n    }\n}\n"
      },
      "contracts/dev-contracts/test/ReenterL1ERC20Bridge.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IL1ERC20Bridge} from \"../../bridge/interfaces/IL1ERC20Bridge.sol\";\n\ncontract ReenterL1ERC20Bridge {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    IL1ERC20Bridge l1Erc20Bridge;\n\n    enum FunctionToCall {\n        Unset,\n        LegacyDeposit,\n        Deposit,\n        ClaimFailedDeposit,\n        FinalizeWithdrawal\n    }\n\n    FunctionToCall functionToCall;\n\n    function setBridge(IL1ERC20Bridge _l1Erc20Bridge) external {\n        l1Erc20Bridge = _l1Erc20Bridge;\n    }\n\n    function setFunctionToCall(FunctionToCall _functionToCall) external {\n        functionToCall = _functionToCall;\n    }\n\n    fallback() external payable {\n        if (functionToCall == FunctionToCall.LegacyDeposit) {\n            l1Erc20Bridge.deposit({\n                _l2Receiver: address(0),\n                _l1Token: address(0),\n                _amount: 0,\n                _l2TxGasLimit: 0,\n                _l2TxGasPerPubdataByte: 0,\n                _refundRecipient: address(0)\n            });\n        } else if (functionToCall == FunctionToCall.Deposit) {\n            l1Erc20Bridge.deposit({\n                _l2Receiver: address(0),\n                _l1Token: address(0),\n                _amount: 0,\n                _l2TxGasLimit: 0,\n                _l2TxGasPerPubdataByte: 0,\n                _refundRecipient: address(0)\n            });\n        } else if (functionToCall == FunctionToCall.ClaimFailedDeposit) {\n            bytes32[] memory merkleProof;\n            l1Erc20Bridge.claimFailedDeposit({\n                _depositSender: address(0),\n                _l1Token: address(0),\n                _l2TxHash: bytes32(0),\n                _l2BatchNumber: 0,\n                _l2MessageIndex: 0,\n                _l2TxNumberInBatch: 0,\n                _merkleProof: merkleProof\n            });\n        } else if (functionToCall == FunctionToCall.FinalizeWithdrawal) {\n            bytes32[] memory merkleProof;\n            l1Erc20Bridge.finalizeWithdrawal({\n                _l2BatchNumber: 0,\n                _l2MessageIndex: 0,\n                _l2TxNumberInBatch: 0,\n                _message: bytes(\"\"),\n                _merkleProof: merkleProof\n            });\n        } else {\n            revert(\"Unset function to call\");\n        }\n    }\n\n    receive() external payable {\n        // revert(\"Receive not allowed\");\n    }\n}\n"
      },
      "contracts/dev-contracts/test/TestCalldataDA.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {CalldataDA} from \"../../state-transition/data-availability/CalldataDA.sol\";\n\ncontract TestCalldataDA is CalldataDA {\n    function processL2RollupDAValidatorOutputHash(\n        bytes32 _l2DAValidatorOutputHash,\n        uint256 _maxBlobsSupported,\n        bytes calldata _operatorDAInput\n    )\n        external\n        pure\n        returns (\n            bytes32 stateDiffHash,\n            bytes32 fullPubdataHash,\n            bytes32[] memory blobsLinearHashes,\n            uint256 blobsProvided,\n            bytes calldata l1DaInput\n        )\n    {\n        return _processL2RollupDAValidatorOutputHash(_l2DAValidatorOutputHash, _maxBlobsSupported, _operatorDAInput);\n    }\n\n    function processCalldataDA(\n        uint256 _blobsProvided,\n        bytes32 _fullPubdataHash,\n        uint256 _maxBlobsSupported,\n        bytes calldata _pubdataInput\n    ) external pure returns (bytes32[] memory blobCommitments, bytes calldata _pubdata) {\n        return _processCalldataDA(_blobsProvided, _fullPubdataHash, _maxBlobsSupported, _pubdataInput);\n    }\n}\n"
      },
      "contracts/dev-contracts/test/TestExecutor.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\nimport {ExecutorFacet} from \"../../state-transition/chain-deps/facets/Executor.sol\";\nimport {PriorityQueue, PriorityOperation} from \"../../state-transition/libraries/PriorityQueue.sol\";\n\npragma solidity 0.8.24;\n\ncontract TestExecutor is ExecutorFacet {\n    constructor() ExecutorFacet(block.chainid) {}\n    using PriorityQueue for PriorityQueue.Queue;\n\n    function setPriorityTreeStartIndex(uint256 _startIndex) external {\n        s.priorityTree.startIndex = _startIndex;\n    }\n\n    function appendPriorityOp(bytes32 _hash) external {\n        s.priorityQueue.pushBack(\n            PriorityOperation({canonicalTxHash: _hash, expirationTimestamp: type(uint64).max, layer2Tip: 0})\n        );\n    }\n\n    // /// @dev Since we want to test the blob functionality we want mock the calls to the blobhash opcode.\n    // function _getBlobVersionedHash(uint256 _index) internal view virtual override returns (bytes32 versionedHash) {\n    //     (bool success, bytes memory data) = s.blobVersionedHashRetriever.staticcall(abi.encode(_index));\n    //     require(success, \"vc\");\n    //     versionedHash = abi.decode(data, (bytes32));\n    // }\n}\n"
      },
      "contracts/dev-contracts/test/UncheckedMathTest.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {UncheckedMath} from \"../../common/libraries/UncheckedMath.sol\";\n\ncontract UncheckedMathTest {\n    function uncheckedInc(uint256 _number) external pure returns (uint256) {\n        return UncheckedMath.uncheckedInc(_number);\n    }\n\n    function uncheckedAdd(uint256 _lhs, uint256 _rhs) external pure returns (uint256) {\n        return UncheckedMath.uncheckedAdd(_lhs, _rhs);\n    }\n}\n"
      },
      "contracts/dev-contracts/test/UnsafeBytesTest.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {UnsafeBytes} from \"../../common/libraries/UnsafeBytes.sol\";\n\ncontract UnsafeBytesTest {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    using UnsafeBytes for bytes;\n\n    function readUint32(bytes memory _bytes, uint256 _start) external pure returns (uint32 readValue, uint256 offset) {\n        return _bytes.readUint32(_start);\n    }\n\n    function readAddress(\n        bytes memory _bytes,\n        uint256 _start\n    ) external pure returns (address readValue, uint256 offset) {\n        return _bytes.readAddress(_start);\n    }\n\n    function readUint256(\n        bytes memory _bytes,\n        uint256 _start\n    ) external pure returns (uint256 readValue, uint256 offset) {\n        return _bytes.readUint256(_start);\n    }\n\n    function readBytes32(\n        bytes memory _bytes,\n        uint256 _start\n    ) external pure returns (bytes32 readValue, uint256 offset) {\n        return _bytes.readBytes32(_start);\n    }\n}\n"
      },
      "contracts/dev-contracts/test/VerifierRecursiveTest.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Verifier} from \"../../state-transition/Verifier.sol\";\n\n/// @author Matter Labs\ncontract VerifierRecursiveTest is Verifier {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    function _loadVerificationKey() internal pure override {\n        assembly {\n            // gate setup commitments\n            mstore(VK_GATE_SETUP_0_X_SLOT, 0x046e45fd137982bd0f6cf731b4650d2d520e8d675827744e1edf1308583599bb)\n            mstore(VK_GATE_SETUP_0_Y_SLOT, 0x177f14d16b716d4298be5e07b83add3fb61ff1ee08dce19f9a54fa8f04937f7e)\n            mstore(VK_GATE_SETUP_1_X_SLOT, 0x169ad5156d25b56f7b67ea6382f88b845ed5bae5b91aacfe51d8f0716afff2fb)\n            mstore(VK_GATE_SETUP_1_Y_SLOT, 0x2406e3268e4d5fa672142998ecf834034638a4a6f8b5e90205552c6aa1dde163)\n            mstore(VK_GATE_SETUP_2_X_SLOT, 0x05fd0ce0fdc590938d29c738c8dc956b32ca8e69c3babfbb49dc1c13a6d9a8d4)\n            mstore(VK_GATE_SETUP_2_Y_SLOT, 0x0a27dac323a04dd319d9805be879875c95063d0a55c96214cd45c913fba84460)\n            mstore(VK_GATE_SETUP_3_X_SLOT, 0x0d58a2a86b208a4976beb9bfd918514d448656e0ee66175eb344a4a17bba99f8)\n            mstore(VK_GATE_SETUP_3_Y_SLOT, 0x215fa609a1a425b84c9dc218c6cf999596d9eba6d35597ad7aaf2d077a6616ed)\n            mstore(VK_GATE_SETUP_4_X_SLOT, 0x1a26e6deccf91174ab13613363eb4939680828f0c6031f5039f9e6f264afa68c)\n            mstore(VK_GATE_SETUP_4_Y_SLOT, 0x1f5b2d6bffac1839edfd02cd0e41acc411f0ecbf6c5c4b1da0e12b68b99cb25d)\n            mstore(VK_GATE_SETUP_5_X_SLOT, 0x09b71be2e8a45dcbe7654cf369c4f1f2e7eab4b97869a469fb7a149d989f7226)\n            mstore(VK_GATE_SETUP_5_Y_SLOT, 0x197e1e2cefbd4f99558b89ca875e01fec0f14f05e5128bd869c87d6bf2f307fa)\n            mstore(VK_GATE_SETUP_6_X_SLOT, 0x0d7cef745da686fd44760403d452d72be504bb41b0a7f4fbe973a07558893871)\n            mstore(VK_GATE_SETUP_6_Y_SLOT, 0x1e9a863307cdfd3fdcf119f72279ddfda08b6f23c3672e8378dbb9d548734c29)\n            mstore(VK_GATE_SETUP_7_X_SLOT, 0x16af3f5d978446fdb37d84f5cf12e59f5c1088bde23f8260c0bb6792c5f78e99)\n            mstore(VK_GATE_SETUP_7_Y_SLOT, 0x167d3aeee50c0e53fd1e8a33941a806a34cfae5dc8b66578486e5d7207b5d546)\n\n            // gate selectors commitments\n            mstore(VK_GATE_SELECTORS_0_X_SLOT, 0x1addc8e154c74bed403dc19558096ce22f1ceb2c656a2a5e85e56d2be6580ed1)\n            mstore(VK_GATE_SELECTORS_0_Y_SLOT, 0x1420d38f0ef206828efc36d0f5ad2b4d85fe768097f358fc671b7b3ec0239234)\n            mstore(VK_GATE_SELECTORS_1_X_SLOT, 0x2d5c06d0c8aa6a3520b8351f82341affcbb1a0bf27bceb9bab175e3e1d38cf47)\n            mstore(VK_GATE_SELECTORS_1_Y_SLOT, 0x0ff8d923a0374308147f6dd4fc513f6d0640f5df699f4836825ef460df3f8d6a)\n\n            // permutation commitments\n            mstore(VK_PERMUTATION_0_X_SLOT, 0x1de8943a8f67d9f6fcbda10a1f37a82de9e9ffd0a0102ea5ce0ce6dd13b4031b)\n            mstore(VK_PERMUTATION_0_Y_SLOT, 0x1e04b0824853ab5d7c3412a217a1c5b88a2b4011be7e7e849485be8ed7332e41)\n            mstore(VK_PERMUTATION_1_X_SLOT, 0x2aa1817b9cc40b6cc7a7b3f832f3267580f9fb8e539666c00541e1a77e34a3da)\n            mstore(VK_PERMUTATION_1_Y_SLOT, 0x0edb3cde226205b01212fc1861303c49ef3ff66f060b5833dc9a3f661ef31dd9)\n            mstore(VK_PERMUTATION_2_X_SLOT, 0x13f5ae93c8eccc1455a0095302923442d4b0b3c8233d66ded99ffcf2ad641c27)\n            mstore(VK_PERMUTATION_2_Y_SLOT, 0x2dd42d42ccdea8b1901435ace12bc9e52c7dbbeb409d20c517ba942ed0cc7519)\n            mstore(VK_PERMUTATION_3_X_SLOT, 0x1a15a70a016be11af71e46e9c8a8d31ece32a7e657ae90356dd9535e6566645f)\n            mstore(VK_PERMUTATION_3_Y_SLOT, 0x0381d23e115521c6fc233c5346f79a6777bfa8871b7ee623d990cdcb5d8c3ce1)\n\n            // lookup tables commitments\n            mstore(VK_LOOKUP_TABLE_0_X_SLOT, 0x2c513ed74d9d57a5ec901e074032741036353a2c4513422e96e7b53b302d765b)\n            mstore(VK_LOOKUP_TABLE_0_Y_SLOT, 0x04dd964427e430f16004076d708c0cb21e225056cc1d57418cfbd3d472981468)\n            mstore(VK_LOOKUP_TABLE_1_X_SLOT, 0x1ea83e5e65c6f8068f4677e2911678cf329b28259642a32db1f14b8347828aac)\n            mstore(VK_LOOKUP_TABLE_1_Y_SLOT, 0x1d22bc884a2da4962a893ba8de13f57aaeb785ed52c5e686994839cab8f7475d)\n            mstore(VK_LOOKUP_TABLE_2_X_SLOT, 0x0b2e7212d0d9cff26d0bdf3d79b2cac029a25dfeb1cafdf49e2349d7db348d89)\n            mstore(VK_LOOKUP_TABLE_2_Y_SLOT, 0x1301f9b252419ea240eb67fda720ca0b16d92364027285f95e9b1349490fa283)\n            mstore(VK_LOOKUP_TABLE_3_X_SLOT, 0x02f7b99fdfa5b418548c2d777785820e02383cfc87e7085e280a375a358153bf)\n            mstore(VK_LOOKUP_TABLE_3_Y_SLOT, 0x09d004fe08dc4d19c382df36fad22ef676185663543703e6a4b40203e50fd8a6)\n\n            // lookup selector commitment\n            mstore(VK_LOOKUP_SELECTOR_X_SLOT, 0x1641f5d312e6f62720b1e6cd1d1be5bc0e69d10d20a12dc97ff04e2107e10ccc)\n            mstore(VK_LOOKUP_SELECTOR_Y_SLOT, 0x277f435d376acc3261ef9d5748e6705086214daf46d04edc80fbd657f8d9e73d)\n\n            // table type commitment\n            mstore(VK_LOOKUP_TABLE_TYPE_X_SLOT, 0x1b5f1cfddd6713cf25d9e6850a1b3fe80d6ef7fe2c67248f25362d5f9b31893c)\n            mstore(VK_LOOKUP_TABLE_TYPE_Y_SLOT, 0x0945076de03a0d240067e5f02b8fc11eaa589df3343542576eb59fdb3ecb57e0)\n\n            // flag for using recursive part\n            mstore(VK_RECURSIVE_FLAG_SLOT, 1)\n        }\n    }\n}\n"
      },
      "contracts/dev-contracts/test/VerifierTest.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Verifier} from \"../../state-transition/Verifier.sol\";\n\n/// @author Matter Labs\ncontract VerifierTest is Verifier {\n    // add this to be excluded from coverage report\n    function test() internal virtual {}\n\n    function _loadVerificationKey() internal pure override {\n        assembly {\n            // gate setup commitments\n            mstore(VK_GATE_SETUP_0_X_SLOT, 0x046e45fd137982bd0f6cf731b4650d2d520e8d675827744e1edf1308583599bb)\n            mstore(VK_GATE_SETUP_0_Y_SLOT, 0x177f14d16b716d4298be5e07b83add3fb61ff1ee08dce19f9a54fa8f04937f7e)\n            mstore(VK_GATE_SETUP_1_X_SLOT, 0x169ad5156d25b56f7b67ea6382f88b845ed5bae5b91aacfe51d8f0716afff2fb)\n            mstore(VK_GATE_SETUP_1_Y_SLOT, 0x2406e3268e4d5fa672142998ecf834034638a4a6f8b5e90205552c6aa1dde163)\n            mstore(VK_GATE_SETUP_2_X_SLOT, 0x05fd0ce0fdc590938d29c738c8dc956b32ca8e69c3babfbb49dc1c13a6d9a8d4)\n            mstore(VK_GATE_SETUP_2_Y_SLOT, 0x0a27dac323a04dd319d9805be879875c95063d0a55c96214cd45c913fba84460)\n            mstore(VK_GATE_SETUP_3_X_SLOT, 0x0d58a2a86b208a4976beb9bfd918514d448656e0ee66175eb344a4a17bba99f8)\n            mstore(VK_GATE_SETUP_3_Y_SLOT, 0x215fa609a1a425b84c9dc218c6cf999596d9eba6d35597ad7aaf2d077a6616ed)\n            mstore(VK_GATE_SETUP_4_X_SLOT, 0x1a26e6deccf91174ab13613363eb4939680828f0c6031f5039f9e6f264afa68c)\n            mstore(VK_GATE_SETUP_4_Y_SLOT, 0x1f5b2d6bffac1839edfd02cd0e41acc411f0ecbf6c5c4b1da0e12b68b99cb25d)\n            mstore(VK_GATE_SETUP_5_X_SLOT, 0x09b71be2e8a45dcbe7654cf369c4f1f2e7eab4b97869a469fb7a149d989f7226)\n            mstore(VK_GATE_SETUP_5_Y_SLOT, 0x197e1e2cefbd4f99558b89ca875e01fec0f14f05e5128bd869c87d6bf2f307fa)\n            mstore(VK_GATE_SETUP_6_X_SLOT, 0x0d7cef745da686fd44760403d452d72be504bb41b0a7f4fbe973a07558893871)\n            mstore(VK_GATE_SETUP_6_Y_SLOT, 0x1e9a863307cdfd3fdcf119f72279ddfda08b6f23c3672e8378dbb9d548734c29)\n            mstore(VK_GATE_SETUP_7_X_SLOT, 0x16af3f5d978446fdb37d84f5cf12e59f5c1088bde23f8260c0bb6792c5f78e99)\n            mstore(VK_GATE_SETUP_7_Y_SLOT, 0x167d3aeee50c0e53fd1e8a33941a806a34cfae5dc8b66578486e5d7207b5d546)\n\n            // gate selectors commitments\n            mstore(VK_GATE_SELECTORS_0_X_SLOT, 0x1addc8e154c74bed403dc19558096ce22f1ceb2c656a2a5e85e56d2be6580ed1)\n            mstore(VK_GATE_SELECTORS_0_Y_SLOT, 0x1420d38f0ef206828efc36d0f5ad2b4d85fe768097f358fc671b7b3ec0239234)\n            mstore(VK_GATE_SELECTORS_1_X_SLOT, 0x2d5c06d0c8aa6a3520b8351f82341affcbb1a0bf27bceb9bab175e3e1d38cf47)\n            mstore(VK_GATE_SELECTORS_1_Y_SLOT, 0x0ff8d923a0374308147f6dd4fc513f6d0640f5df699f4836825ef460df3f8d6a)\n\n            // permutation commitments\n            mstore(VK_PERMUTATION_0_X_SLOT, 0x1de8943a8f67d9f6fcbda10a1f37a82de9e9ffd0a0102ea5ce0ce6dd13b4031b)\n            mstore(VK_PERMUTATION_0_Y_SLOT, 0x1e04b0824853ab5d7c3412a217a1c5b88a2b4011be7e7e849485be8ed7332e41)\n            mstore(VK_PERMUTATION_1_X_SLOT, 0x2aa1817b9cc40b6cc7a7b3f832f3267580f9fb8e539666c00541e1a77e34a3da)\n            mstore(VK_PERMUTATION_1_Y_SLOT, 0x0edb3cde226205b01212fc1861303c49ef3ff66f060b5833dc9a3f661ef31dd9)\n            mstore(VK_PERMUTATION_2_X_SLOT, 0x13f5ae93c8eccc1455a0095302923442d4b0b3c8233d66ded99ffcf2ad641c27)\n            mstore(VK_PERMUTATION_2_Y_SLOT, 0x2dd42d42ccdea8b1901435ace12bc9e52c7dbbeb409d20c517ba942ed0cc7519)\n            mstore(VK_PERMUTATION_3_X_SLOT, 0x1a15a70a016be11af71e46e9c8a8d31ece32a7e657ae90356dd9535e6566645f)\n            mstore(VK_PERMUTATION_3_Y_SLOT, 0x0381d23e115521c6fc233c5346f79a6777bfa8871b7ee623d990cdcb5d8c3ce1)\n\n            // lookup tables commitments\n            mstore(VK_LOOKUP_TABLE_0_X_SLOT, 0x2c513ed74d9d57a5ec901e074032741036353a2c4513422e96e7b53b302d765b)\n            mstore(VK_LOOKUP_TABLE_0_Y_SLOT, 0x04dd964427e430f16004076d708c0cb21e225056cc1d57418cfbd3d472981468)\n            mstore(VK_LOOKUP_TABLE_1_X_SLOT, 0x1ea83e5e65c6f8068f4677e2911678cf329b28259642a32db1f14b8347828aac)\n            mstore(VK_LOOKUP_TABLE_1_Y_SLOT, 0x1d22bc884a2da4962a893ba8de13f57aaeb785ed52c5e686994839cab8f7475d)\n            mstore(VK_LOOKUP_TABLE_2_X_SLOT, 0x0b2e7212d0d9cff26d0bdf3d79b2cac029a25dfeb1cafdf49e2349d7db348d89)\n            mstore(VK_LOOKUP_TABLE_2_Y_SLOT, 0x1301f9b252419ea240eb67fda720ca0b16d92364027285f95e9b1349490fa283)\n            mstore(VK_LOOKUP_TABLE_3_X_SLOT, 0x02f7b99fdfa5b418548c2d777785820e02383cfc87e7085e280a375a358153bf)\n            mstore(VK_LOOKUP_TABLE_3_Y_SLOT, 0x09d004fe08dc4d19c382df36fad22ef676185663543703e6a4b40203e50fd8a6)\n\n            // lookup selector commitment\n            mstore(VK_LOOKUP_SELECTOR_X_SLOT, 0x1641f5d312e6f62720b1e6cd1d1be5bc0e69d10d20a12dc97ff04e2107e10ccc)\n            mstore(VK_LOOKUP_SELECTOR_Y_SLOT, 0x277f435d376acc3261ef9d5748e6705086214daf46d04edc80fbd657f8d9e73d)\n\n            // table type commitment\n            mstore(VK_LOOKUP_TABLE_TYPE_X_SLOT, 0x1b5f1cfddd6713cf25d9e6850a1b3fe80d6ef7fe2c67248f25362d5f9b31893c)\n            mstore(VK_LOOKUP_TABLE_TYPE_Y_SLOT, 0x0945076de03a0d240067e5f02b8fc11eaa589df3343542576eb59fdb3ecb57e0)\n\n            // flag for using recursive part\n            mstore(VK_RECURSIVE_FLAG_SLOT, 0)\n        }\n    }\n}\n"
      },
      "contracts/governance/AccessControlRestriction.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {AccessToFallbackDenied, AccessToFunctionDenied, ZeroAddress} from \"../common/L1ContractErrors.sol\";\nimport {IAccessControlRestriction} from \"./IAccessControlRestriction.sol\";\nimport {AccessControlDefaultAdminRules} from \"@openzeppelin/contracts-v4/access/AccessControlDefaultAdminRules.sol\";\nimport {Restriction} from \"./restriction/Restriction.sol\";\nimport {Call} from \"./Common.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The Restriction that is designed to provide the access control logic for the `ChainAdmin` contract.\n/// @dev It inherits from `AccessControlDefaultAdminRules` without overriding `_setRoleAdmin` functionality. In other\n/// words, the `DEFAULT_ADMIN_ROLE` is the only role that can manage roles. This is done for simplicity.\n/// @dev An instance of this restriction should be deployed separately for each `ChainAdmin` contract.\n/// @dev IMPORTANT: this function does not validate the ability of the invoker to use `msg.value`. Thus,\n/// either all callers with access to functions should be trusted to not steal ETH from the `ChainAdmin` account\n/// or no ETH should be passively stored in `ChainAdmin` account.\ncontract AccessControlRestriction is Restriction, IAccessControlRestriction, AccessControlDefaultAdminRules {\n    /// @notice Required roles to call a specific function.\n    /// @dev Note, that the role 0 means the `DEFAULT_ADMIN_ROLE` from the `AccessControlDefaultAdminRules` contract.\n    mapping(address target => mapping(bytes4 selector => bytes32 requiredRole)) public requiredRoles;\n\n    /// @notice Required roles to call a fallback function.\n    mapping(address target => bytes32 requiredRole) public requiredRolesForFallback;\n\n    constructor(\n        uint48 initialDelay,\n        address initialDefaultAdmin\n    ) AccessControlDefaultAdminRules(initialDelay, initialDefaultAdmin) {}\n\n    /// @notice Sets the required role for a specific function call.\n    /// @param _target The address of the contract.\n    /// @param _selector The selector of the function.\n    /// @param _requiredRole The required role.\n    function setRequiredRoleForCall(\n        address _target,\n        bytes4 _selector,\n        bytes32 _requiredRole\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_target == address(0)) {\n            revert ZeroAddress();\n        }\n        requiredRoles[_target][_selector] = _requiredRole;\n\n        emit RoleSet(_target, _selector, _requiredRole);\n    }\n\n    /// @notice Sets the required role for a fallback function call.\n    /// @param _target The address of the contract.\n    /// @param _requiredRole The required role.\n    function setRequiredRoleForFallback(address _target, bytes32 _requiredRole) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_target == address(0)) {\n            revert ZeroAddress();\n        }\n        requiredRolesForFallback[_target] = _requiredRole;\n\n        emit FallbackRoleSet(_target, _requiredRole);\n    }\n\n    /// @inheritdoc Restriction\n    function validateCall(Call calldata _call, address _invoker) external view override {\n        // Note, that since `DEFAULT_ADMIN_ROLE` is 0 and the default storage value for the\n        // `requiredRoles` and `requiredRolesForFallback` is 0, the default admin is by default a required\n        // role for all the functions.\n        if (_call.data.length < 4) {\n            // Note, that the following restriction protects only for targets that were compiled after\n            // Solidity v0.4.18, since before a substring of selector could still call the function.\n            if (!hasRole(requiredRolesForFallback[_call.target], _invoker)) {\n                revert AccessToFallbackDenied(_call.target, _invoker);\n            }\n        } else {\n            bytes4 selector = bytes4(_call.data[:4]);\n            if (!hasRole(requiredRoles[_call.target][selector], _invoker)) {\n                revert AccessToFunctionDenied(_call.target, selector, _invoker);\n            }\n        }\n    }\n}\n"
      },
      "contracts/governance/ChainAdmin.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\n// solhint-disable gas-length-in-loops\n\nimport {NoCallsProvided, OnlySelfAllowed, RestrictionWasNotPresent, RestrictionWasAlreadyPresent} from \"../common/L1ContractErrors.sol\";\nimport {IChainAdmin} from \"./IChainAdmin.sol\";\nimport {Restriction} from \"./restriction/Restriction.sol\";\nimport {RestrictionValidator} from \"./restriction/RestrictionValidator.sol\";\nimport {Call} from \"./Common.sol\";\n\nimport {EnumerableSet} from \"@openzeppelin/contracts-v4/utils/structs/EnumerableSet.sol\";\nimport {ReentrancyGuard} from \"../common/ReentrancyGuard.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The contract is designed to hold the `admin` role in ZKSync Chain (State Transition) contracts.\n/// @dev Note, that it does not implement any form of access control by default, but instead utilizes\n/// so called \"restrictions\": contracts that implement the `IRestriction` interface and ensure that\n/// particular restrictions are ensured for the contract, including access control, security invariants, etc.\n/// @dev This is a new EXPERIMENTAL version of the `ChainAdmin` implementation. While chains may opt into using it,\n/// using the old `ChainAdminOwnable` is recommended.\ncontract ChainAdmin is IChainAdmin, ReentrancyGuard {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Mapping of protocol versions to their expected upgrade timestamps.\n    /// @dev Needed for the offchain node administration to know when to start building batches with the new protocol version.\n    mapping(uint256 protocolVersion => uint256 upgradeTimestamp) public protocolVersionToUpgradeTimestamp;\n\n    /// @notice The set of active restrictions.\n    EnumerableSet.AddressSet internal activeRestrictions;\n\n    /// @notice Ensures that only the `ChainAdmin` contract itself can call the function.\n    /// @dev All functions that require access-control should use `onlySelf` modifier, while the access control logic\n    /// should be implemented in the restriction contracts.\n    modifier onlySelf() {\n        if (msg.sender != address(this)) {\n            revert OnlySelfAllowed();\n        }\n        _;\n    }\n\n    constructor(address[] memory _initialRestrictions) reentrancyGuardInitializer {\n        unchecked {\n            for (uint256 i = 0; i < _initialRestrictions.length; ++i) {\n                _addRestriction(_initialRestrictions[i]);\n            }\n        }\n    }\n\n    /// @notice Returns the list of active restrictions.\n    function getRestrictions() public view returns (address[] memory) {\n        return activeRestrictions.values();\n    }\n\n    /// @inheritdoc IChainAdmin\n    function isRestrictionActive(address _restriction) external view returns (bool) {\n        return activeRestrictions.contains(_restriction);\n    }\n\n    /// @inheritdoc IChainAdmin\n    function addRestriction(address _restriction) external onlySelf {\n        _addRestriction(_restriction);\n    }\n\n    /// @inheritdoc IChainAdmin\n    function removeRestriction(address _restriction) external onlySelf {\n        if (!activeRestrictions.remove(_restriction)) {\n            revert RestrictionWasNotPresent(_restriction);\n        }\n        emit RestrictionRemoved(_restriction);\n    }\n\n    /// @notice Set the expected upgrade timestamp for a specific protocol version.\n    /// @param _protocolVersion The ZKsync chain protocol version.\n    /// @param _upgradeTimestamp The timestamp at which the chain node should expect the upgrade to happen.\n    function setUpgradeTimestamp(uint256 _protocolVersion, uint256 _upgradeTimestamp) external onlySelf {\n        protocolVersionToUpgradeTimestamp[_protocolVersion] = _upgradeTimestamp;\n        emit UpdateUpgradeTimestamp(_protocolVersion, _upgradeTimestamp);\n    }\n\n    /// @notice Execute multiple calls as part of contract administration.\n    /// @param _calls Array of Call structures defining target, value, and data for each call.\n    /// @param _requireSuccess If true, reverts transaction on any call failure.\n    /// @dev Intended for batch processing of contract interactions, managing gas efficiency and atomicity of operations.\n    /// @dev Note, that this function lacks access control. It is expected that the access control is implemented in a separate restriction contract.\n    /// @dev Even though all the validation from external modules is executed via `staticcall`, the function\n    /// is marked as `nonReentrant` to prevent reentrancy attacks in case the staticcall restriction is lifted in the future.\n    function multicall(Call[] calldata _calls, bool _requireSuccess) external payable nonReentrant {\n        if (_calls.length == 0) {\n            revert NoCallsProvided();\n        }\n        for (uint256 i = 0; i < _calls.length; ++i) {\n            _validateCall(_calls[i]);\n\n            // slither-disable-next-line arbitrary-send-eth\n            (bool success, bytes memory returnData) = _calls[i].target.call{value: _calls[i].value}(_calls[i].data);\n            if (_requireSuccess && !success) {\n                // Propagate an error if the call fails.\n                assembly {\n                    revert(add(returnData, 0x20), mload(returnData))\n                }\n            }\n            emit CallExecuted(_calls[i], success, returnData);\n        }\n    }\n\n    /// @dev Contract might receive/hold ETH as part of the maintenance process.\n    receive() external payable {}\n\n    /// @notice Function that ensures that the current admin can perform the call.\n    /// @dev Reverts in case the call can not be performed. Successfully executes otherwise\n    function _validateCall(Call calldata _call) private view {\n        address[] memory restrictions = getRestrictions();\n\n        unchecked {\n            for (uint256 i = 0; i < restrictions.length; ++i) {\n                Restriction(restrictions[i]).validateCall(_call, msg.sender);\n            }\n        }\n    }\n\n    /// @notice Adds a new restriction to the active restrictions set.\n    /// @param _restriction The address of the restriction contract to be added.\n    function _addRestriction(address _restriction) private {\n        RestrictionValidator.validateRestriction(_restriction);\n\n        if (!activeRestrictions.add(_restriction)) {\n            revert RestrictionWasAlreadyPresent(_restriction);\n        }\n        emit RestrictionAdded(_restriction);\n    }\n}\n"
      },
      "contracts/governance/ChainAdminOwnable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Ownable2Step} from \"@openzeppelin/contracts-v4/access/Ownable2Step.sol\";\nimport {IChainAdminOwnable} from \"./IChainAdminOwnable.sol\";\nimport {IAdmin} from \"../state-transition/chain-interfaces/IAdmin.sol\";\nimport {NoCallsProvided, Unauthorized, ZeroAddress} from \"../common/L1ContractErrors.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The contract is designed to hold the `admin` role in ZKSync Chain (State Transition) contracts.\n/// The owner of the contract can perform any external calls and also save the information needed for\n/// the blockchain node to accept the protocol upgrade. Another role - `tokenMultiplierSetter` can be used in the contract\n/// to change the base token gas price in the Chain contract.\ncontract ChainAdminOwnable is IChainAdminOwnable, Ownable2Step {\n    /// @notice Mapping of protocol versions to their expected upgrade timestamps.\n    /// @dev Needed for the offchain node administration to know when to start building batches with the new protocol version.\n    mapping(uint256 protocolVersion => uint256 upgradeTimestamp) public protocolVersionToUpgradeTimestamp;\n\n    /// @notice The address which can call `setTokenMultiplier` function to change the base token gas price in the Chain contract.\n    /// @dev The token base price can be changed quite often, so the private key for this role is supposed to be stored in the node\n    /// and used by the automated service in a way similar to the sequencer workflow.\n    address public tokenMultiplierSetter;\n\n    constructor(address _initialOwner, address _initialTokenMultiplierSetter) {\n        if (_initialOwner == address(0)) {\n            revert ZeroAddress();\n        }\n        _transferOwnership(_initialOwner);\n        // Can be zero if no one has this permission.\n        tokenMultiplierSetter = _initialTokenMultiplierSetter;\n        emit NewTokenMultiplierSetter(address(0), _initialTokenMultiplierSetter);\n    }\n\n    /// @notice Updates the address responsible for setting token multipliers on the Chain contract .\n    /// @param _tokenMultiplierSetter The new address to be set as the token multiplier setter.\n    function setTokenMultiplierSetter(address _tokenMultiplierSetter) external onlyOwner {\n        emit NewTokenMultiplierSetter(tokenMultiplierSetter, _tokenMultiplierSetter);\n        tokenMultiplierSetter = _tokenMultiplierSetter;\n    }\n\n    /// @notice Set the expected upgrade timestamp for a specific protocol version.\n    /// @param _protocolVersion The ZKsync chain protocol version.\n    /// @param _upgradeTimestamp The timestamp at which the chain node should expect the upgrade to happen.\n    function setUpgradeTimestamp(uint256 _protocolVersion, uint256 _upgradeTimestamp) external onlyOwner {\n        protocolVersionToUpgradeTimestamp[_protocolVersion] = _upgradeTimestamp;\n        emit UpdateUpgradeTimestamp(_protocolVersion, _upgradeTimestamp);\n    }\n\n    /// @notice Execute multiple calls as part of contract administration.\n    /// @param _calls Array of Call structures defining target, value, and data for each call.\n    /// @param _requireSuccess If true, reverts transaction on any call failure.\n    /// @dev Intended for batch processing of contract interactions, managing gas efficiency and atomicity of operations.\n    function multicall(Call[] calldata _calls, bool _requireSuccess) external payable onlyOwner {\n        if (_calls.length == 0) {\n            revert NoCallsProvided();\n        }\n        // solhint-disable-next-line gas-length-in-loops\n        for (uint256 i = 0; i < _calls.length; ++i) {\n            // slither-disable-next-line arbitrary-send-eth\n            (bool success, bytes memory returnData) = _calls[i].target.call{value: _calls[i].value}(_calls[i].data);\n            if (_requireSuccess && !success) {\n                // Propagate an error if the call fails.\n                assembly {\n                    revert(add(returnData, 0x20), mload(returnData))\n                }\n            }\n            emit CallExecuted(_calls[i], success, returnData);\n        }\n    }\n\n    /// @notice Sets the token multiplier in the specified Chain contract.\n    /// @param _chainContract The chain contract address where the token multiplier will be set.\n    /// @param _nominator The numerator part of the token multiplier.\n    /// @param _denominator The denominator part of the token multiplier.\n    function setTokenMultiplier(IAdmin _chainContract, uint128 _nominator, uint128 _denominator) external {\n        if (msg.sender != tokenMultiplierSetter) {\n            revert Unauthorized(msg.sender);\n        }\n        _chainContract.setTokenMultiplier(_nominator, _denominator);\n    }\n\n    /// @dev Contract might receive/hold ETH as part of the maintenance process.\n    receive() external payable {}\n}\n"
      },
      "contracts/governance/Common.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\n/// @dev Represents a call to be made during multicall.\n/// @param target The address to which the call will be made.\n/// @param value The amount of Ether (in wei) to be sent along with the call.\n/// @param data The calldata to be executed on the `target` address.\nstruct Call {\n    address target;\n    uint256 value;\n    bytes data;\n}\n"
      },
      "contracts/governance/Governance.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Ownable2Step} from \"@openzeppelin/contracts-v4/access/Ownable2Step.sol\";\nimport {IGovernance} from \"./IGovernance.sol\";\nimport {Call} from \"./Common.sol\";\nimport {ZeroAddress, Unauthorized, OperationMustBeReady, OperationMustBePending, OperationExists, InvalidDelay, PreviousOperationNotExecuted} from \"../common/L1ContractErrors.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev Contract design is inspired by OpenZeppelin TimelockController and in-house Diamond Proxy upgrade mechanism.\n/// @notice This contract manages operations (calls with preconditions) for governance tasks.\n/// The contract allows for operations to be scheduled, executed, and canceled with\n/// appropriate permissions and delays. It is used for managing and coordinating upgrades\n/// and changes in all ZK chain governed contracts.\n///\n/// Operations can be proposed as either fully transparent upgrades with on-chain data,\n/// or \"shadow\" upgrades where upgrade data is not published on-chain before execution. Proposed operations\n/// are subject to a delay before they can be executed, but they can be executed instantly\n/// with the security council’s permission.\ncontract Governance is IGovernance, Ownable2Step {\n    /// @notice A constant representing the timestamp for completed operations.\n    uint256 internal constant EXECUTED_PROPOSAL_TIMESTAMP = uint256(1);\n\n    /// @notice The address of the security council.\n    /// @dev It is supposed to be multisig contract.\n    address public securityCouncil;\n\n    /// @notice A mapping to store timestamps when each operation will be ready for execution.\n    /// @dev - 0 means the operation is not created.\n    /// @dev - 1 (EXECUTED_PROPOSAL_TIMESTAMP) means the operation is already executed.\n    /// @dev - any other value means timestamp in seconds when the operation will be ready for execution.\n    mapping(bytes32 operationId => uint256 executionTimestamp) public timestamps;\n\n    /// @notice The minimum delay in seconds for operations to be ready for execution.\n    uint256 public minDelay;\n\n    /// @notice Initializes the contract with the admin address, security council address, and minimum delay.\n    /// @param _admin The address to be assigned as the admin of the contract.\n    /// @param _securityCouncil The address to be assigned as the security council of the contract.\n    /// @param _minDelay The initial minimum delay (in seconds) to be set for operations.\n    /// @dev We allow for a zero address for _securityCouncil because it can be set later\n    constructor(address _admin, address _securityCouncil, uint256 _minDelay) {\n        if (_admin == address(0)) {\n            revert ZeroAddress();\n        }\n\n        _transferOwnership(_admin);\n\n        securityCouncil = _securityCouncil;\n        emit ChangeSecurityCouncil(address(0), _securityCouncil);\n\n        minDelay = _minDelay;\n        emit ChangeMinDelay(0, _minDelay);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Checks that the message sender is contract itself.\n    modifier onlySelf() {\n        if (msg.sender != address(this)) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Checks that the message sender is an active security council.\n    modifier onlySecurityCouncil() {\n        if (msg.sender != securityCouncil) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Checks that the message sender is an active owner or an active security council.\n    modifier onlyOwnerOrSecurityCouncil() {\n        if (msg.sender != owner() && msg.sender != securityCouncil) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            OPERATION GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Returns whether an id corresponds to a registered operation. This\n    /// includes Waiting, Ready, and Done operations.\n    function isOperation(bytes32 _id) public view returns (bool) {\n        return getOperationState(_id) != OperationState.Unset;\n    }\n\n    /// @dev Returns whether an operation is pending or not. Note that a \"pending\" operation may also be \"ready\".\n    function isOperationPending(bytes32 _id) public view returns (bool) {\n        OperationState state = getOperationState(_id);\n        return state == OperationState.Waiting || state == OperationState.Ready;\n    }\n\n    /// @dev Returns whether an operation is ready for execution. Note that a \"ready\" operation is also \"pending\".\n    function isOperationReady(bytes32 _id) public view returns (bool) {\n        return getOperationState(_id) == OperationState.Ready;\n    }\n\n    /// @dev Returns whether an operation is done or not.\n    function isOperationDone(bytes32 _id) public view returns (bool) {\n        return getOperationState(_id) == OperationState.Done;\n    }\n\n    /// @dev Returns operation state.\n    function getOperationState(bytes32 _id) public view returns (OperationState) {\n        uint256 timestamp = timestamps[_id];\n        if (timestamp == 0) {\n            return OperationState.Unset;\n        } else if (timestamp == EXECUTED_PROPOSAL_TIMESTAMP) {\n            return OperationState.Done;\n        } else if (timestamp > block.timestamp) {\n            return OperationState.Waiting;\n        } else {\n            return OperationState.Ready;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            SCHEDULING CALLS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Propose a fully transparent upgrade, providing upgrade data on-chain.\n    /// @notice The owner will be able to execute the proposal either:\n    /// - With a `delay` timelock on its own.\n    /// - With security council instantly.\n    /// @dev Only the current owner can propose an upgrade.\n    /// @param _operation The operation parameters will be executed with the upgrade.\n    /// @param _delay The delay time (in seconds) after which the proposed upgrade can be executed by the owner.\n    function scheduleTransparent(Operation calldata _operation, uint256 _delay) external onlyOwner {\n        bytes32 id = hashOperation(_operation);\n        _schedule(id, _delay);\n        emit TransparentOperationScheduled(id, _delay, _operation);\n    }\n\n    /// @notice Propose \"shadow\" upgrade, upgrade data is not publishing on-chain.\n    /// @notice The owner will be able to execute the proposal either:\n    /// - With a `delay` timelock on its own.\n    /// - With security council instantly.\n    /// @dev Only the current owner can propose an upgrade.\n    /// @param _id The operation hash (see `hashOperation` function)\n    /// @param _delay The delay time (in seconds) after which the proposed upgrade may be executed by the owner.\n    function scheduleShadow(bytes32 _id, uint256 _delay) external onlyOwner {\n        _schedule(_id, _delay);\n        emit ShadowOperationScheduled(_id, _delay);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            CANCELING CALLS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Cancel the scheduled operation.\n    /// @dev Only owner can call this function.\n    /// @param _id Proposal id value (see `hashOperation`)\n    function cancel(bytes32 _id) external onlyOwner {\n        if (!isOperationPending(_id)) {\n            revert OperationMustBePending();\n        }\n        delete timestamps[_id];\n        emit OperationCancelled(_id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXECUTING CALLS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Executes the scheduled operation after the delay passed.\n    /// @dev Both the owner and security council may execute delayed operations.\n    /// @param _operation The operation parameters will be executed with the upgrade.\n    //  slither-disable-next-line reentrancy-eth\n    function execute(Operation calldata _operation) external payable onlyOwnerOrSecurityCouncil {\n        bytes32 id = hashOperation(_operation);\n        // Check if the predecessor operation is completed.\n        _checkPredecessorDone(_operation.predecessor);\n        // Ensure that the operation is ready to proceed.\n        if (!isOperationReady(id)) {\n            revert OperationMustBeReady();\n        }\n        // Execute operation.\n        // slither-disable-next-line reentrancy-eth\n        _execute(_operation.calls);\n        // Reconfirming that the operation is still ready after execution.\n        // This is needed to avoid unexpected reentrancy attacks of re-executing the same operation.\n        if (!isOperationReady(id)) {\n            revert OperationMustBeReady();\n        }\n        // Set operation to be done\n        timestamps[id] = EXECUTED_PROPOSAL_TIMESTAMP;\n        emit OperationExecuted(id);\n    }\n\n    /// @notice Executes the scheduled operation with the security council instantly.\n    /// @dev Only the security council may execute an operation instantly.\n    /// @param _operation The operation parameters will be executed with the upgrade.\n    //  slither-disable-next-line reentrancy-eth\n    function executeInstant(Operation calldata _operation) external payable onlySecurityCouncil {\n        bytes32 id = hashOperation(_operation);\n        // Check if the predecessor operation is completed.\n        _checkPredecessorDone(_operation.predecessor);\n        // Ensure that the operation is in a pending state before proceeding.\n        if (!isOperationPending(id)) {\n            revert OperationMustBePending();\n        }\n        // Execute operation.\n        // slither-disable-next-line reentrancy-eth\n        _execute(_operation.calls);\n        // Reconfirming that the operation is still pending before execution.\n        // This is needed to avoid unexpected reentrancy attacks of re-executing the same operation.\n        if (!isOperationPending(id)) {\n            revert OperationMustBePending();\n        }\n        // Set operation to be done\n        timestamps[id] = EXECUTED_PROPOSAL_TIMESTAMP;\n        emit OperationExecuted(id);\n    }\n\n    /// @dev Returns the identifier of an operation.\n    /// @param _operation The operation object to compute the identifier for.\n    function hashOperation(Operation calldata _operation) public pure returns (bytes32) {\n        return keccak256(abi.encode(_operation));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Schedule an operation that is to become valid after a given delay.\n    /// @param _id The operation hash (see `hashOperation` function)\n    /// @param _delay The delay time (in seconds) after which the proposed upgrade can be executed by the owner.\n    function _schedule(bytes32 _id, uint256 _delay) internal {\n        if (isOperation(_id)) {\n            revert OperationExists();\n        }\n        if (_delay < minDelay) {\n            revert InvalidDelay();\n        }\n\n        timestamps[_id] = block.timestamp + _delay;\n    }\n\n    /// @dev Execute an operation's calls.\n    /// @param _calls The array of calls to be executed.\n    function _execute(Call[] calldata _calls) internal {\n        // We disable this check because calldata array length is cheap.\n        // solhint-disable-next-line gas-length-in-loops\n        for (uint256 i = 0; i < _calls.length; ++i) {\n            // slither-disable-next-line arbitrary-send-eth\n            (bool success, bytes memory returnData) = _calls[i].target.call{value: _calls[i].value}(_calls[i].data);\n            if (!success) {\n                // Propagate an error if the call fails.\n                assembly {\n                    revert(add(returnData, 0x20), mload(returnData))\n                }\n            }\n        }\n    }\n\n    /// @notice Verifies if the predecessor operation is completed.\n    /// @param _predecessorId The hash of the operation that should be completed.\n    /// @dev Doesn't check the operation to be complete if the input is zero.\n    function _checkPredecessorDone(bytes32 _predecessorId) internal view {\n        if (_predecessorId != bytes32(0) && !isOperationDone(_predecessorId)) {\n            revert PreviousOperationNotExecuted();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            SELF UPGRADES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Changes the minimum timelock duration for future operations.\n    /// @param _newDelay The new minimum delay time (in seconds) for future operations.\n    function updateDelay(uint256 _newDelay) external onlySelf {\n        emit ChangeMinDelay(minDelay, _newDelay);\n        minDelay = _newDelay;\n    }\n\n    /// @dev Updates the address of the security council.\n    /// @param _newSecurityCouncil The address of the new security council.\n    function updateSecurityCouncil(address _newSecurityCouncil) external onlySelf {\n        emit ChangeSecurityCouncil(securityCouncil, _newSecurityCouncil);\n        securityCouncil = _newSecurityCouncil;\n    }\n\n    /// @dev Contract might receive/hold ETH as part of the maintenance process.\n    receive() external payable {}\n}\n"
      },
      "contracts/governance/IAccessControlRestriction.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\n/// @title AccessControlRestriction contract interface\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IAccessControlRestriction {\n    /// @notice Emitted when the required role for a specific function is set.\n    event RoleSet(address indexed target, bytes4 indexed selector, bytes32 requiredRole);\n\n    /// @notice Emitted when the required role for a fallback function is set.\n    event FallbackRoleSet(address indexed target, bytes32 requiredRole);\n}\n"
      },
      "contracts/governance/IChainAdmin.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Call} from \"./Common.sol\";\n\n/// @title ChainAdmin contract interface\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IChainAdmin {\n    /// @notice Emitted when the expected upgrade timestamp for a specific protocol version is set.\n    event UpdateUpgradeTimestamp(uint256 indexed protocolVersion, uint256 upgradeTimestamp);\n\n    /// @notice Emitted when the call is executed from the contract.\n    event CallExecuted(Call call, bool success, bytes returnData);\n\n    /// @notice Emitted when a new restriction is added.\n    event RestrictionAdded(address indexed restriction);\n\n    /// @notice Emitted when a restriction is removed.\n    event RestrictionRemoved(address indexed restriction);\n\n    /// @notice Returns the list of active restrictions.\n    function getRestrictions() external view returns (address[] memory);\n\n    /// @notice Checks if the restriction is active.\n    /// @param _restriction The address of the restriction contract.\n    function isRestrictionActive(address _restriction) external view returns (bool);\n\n    /// @notice Adds a new restriction to the active restrictions set.\n    /// @param _restriction The address of the restriction contract.\n    function addRestriction(address _restriction) external;\n\n    /// @notice Removes a restriction from the active restrictions set.\n    /// @param _restriction The address of the restriction contract.\n    /// @dev Sometimes restrictions might need to enforce their permanence (e.g. if a chain should be a rollup forever).\n    function removeRestriction(address _restriction) external;\n\n    /// @notice Execute multiple calls as part of contract administration.\n    /// @param _calls Array of Call structures defining target, value, and data for each call.\n    /// @param _requireSuccess If true, reverts transaction on any call failure.\n    /// @dev Intended for batch processing of contract interactions, managing gas efficiency and atomicity of operations.\n    /// @dev Note, that this function lacks access control. It is expected that the access control is implemented in a separate restriction contract.\n    /// @dev Even though all the validation from external modules is executed via `staticcall`, the function\n    /// is marked as `nonReentrant` to prevent reentrancy attacks in case the staticcall restriction is lifted in the future.\n    function multicall(Call[] calldata _calls, bool _requireSuccess) external payable;\n}\n"
      },
      "contracts/governance/IChainAdminOwnable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IAdmin} from \"../state-transition/chain-interfaces/IAdmin.sol\";\n\n/// @title ChainAdmin contract interface\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IChainAdminOwnable {\n    /// @dev Represents a call to be made during multicall.\n    /// @param target The address to which the call will be made.\n    /// @param value The amount of Ether (in wei) to be sent along with the call.\n    /// @param data The calldata to be executed on the `target` address.\n    struct Call {\n        address target;\n        uint256 value;\n        bytes data;\n    }\n\n    /// @notice Emitted when the expected upgrade timestamp for a specific protocol version is set.\n    event UpdateUpgradeTimestamp(uint256 indexed _protocolVersion, uint256 _upgradeTimestamp);\n\n    /// @notice Emitted when the call is executed from the contract.\n    event CallExecuted(Call _call, bool _success, bytes _returnData);\n\n    /// @notice Emitted when the new token multiplier address is set.\n    event NewTokenMultiplierSetter(address _oldTokenMultiplierSetter, address _newTokenMultiplierSetter);\n\n    function setTokenMultiplierSetter(address _tokenMultiplierSetter) external;\n\n    function setUpgradeTimestamp(uint256 _protocolVersion, uint256 _upgradeTimestamp) external;\n\n    function multicall(Call[] calldata _calls, bool _requireSuccess) external payable;\n\n    function setTokenMultiplier(IAdmin _chainContract, uint128 _nominator, uint128 _denominator) external;\n}\n"
      },
      "contracts/governance/IGovernance.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {Call} from \"./Common.sol\";\n\n/// @title Governance contract interface\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IGovernance {\n    /// @dev This enumeration includes the following states:\n    /// @param Unset Default state, indicating the operation has not been set.\n    /// @param Waiting The operation is scheduled but not yet ready to be executed.\n    /// @param Ready The operation is ready to be executed.\n    /// @param Done The operation has been successfully executed.\n    enum OperationState {\n        Unset,\n        Waiting,\n        Ready,\n        Done\n    }\n\n    /// @dev Defines the structure of an operation that Governance executes.\n    /// @param calls An array of `Call` structs, each representing a call to be made during the operation.\n    /// @param predecessor The hash of the predecessor operation, that should be executed before this operation.\n    /// @param salt A bytes32 value used for creating unique operation hashes.\n    struct Operation {\n        Call[] calls;\n        bytes32 predecessor;\n        bytes32 salt;\n    }\n\n    function isOperation(bytes32 _id) external view returns (bool);\n\n    function isOperationPending(bytes32 _id) external view returns (bool);\n\n    function isOperationReady(bytes32 _id) external view returns (bool);\n\n    function isOperationDone(bytes32 _id) external view returns (bool);\n\n    function getOperationState(bytes32 _id) external view returns (OperationState);\n\n    function scheduleTransparent(Operation calldata _operation, uint256 _delay) external;\n\n    function scheduleShadow(bytes32 _id, uint256 _delay) external;\n\n    function cancel(bytes32 _id) external;\n\n    function execute(Operation calldata _operation) external payable;\n\n    function executeInstant(Operation calldata _operation) external payable;\n\n    function hashOperation(Operation calldata _operation) external pure returns (bytes32);\n\n    function updateDelay(uint256 _newDelay) external;\n\n    function updateSecurityCouncil(address _newSecurityCouncil) external;\n\n    /// @notice Emitted when transparent operation is scheduled.\n    event TransparentOperationScheduled(bytes32 indexed _id, uint256 delay, Operation _operation);\n\n    /// @notice Emitted when shadow operation is scheduled.\n    event ShadowOperationScheduled(bytes32 indexed _id, uint256 delay);\n\n    /// @notice Emitted when the operation is executed with delay or instantly.\n    event OperationExecuted(bytes32 indexed _id);\n\n    /// @notice Emitted when the security council address is changed.\n    event ChangeSecurityCouncil(address _securityCouncilBefore, address _securityCouncilAfter);\n\n    /// @notice Emitted when the minimum delay for future operations is modified.\n    event ChangeMinDelay(uint256 _delayBefore, uint256 _delayAfter);\n\n    /// @notice Emitted when the operation with specified id is cancelled.\n    event OperationCancelled(bytes32 indexed _id);\n}\n"
      },
      "contracts/governance/IPermanentRestriction.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\n/// @notice The interface for the permanent restriction contract.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IPermanentRestriction {\n    /// @notice Emitted when the implementation is allowed or disallowed.\n    event AdminImplementationAllowed(bytes32 indexed implementationHash, bool isAllowed);\n\n    /// @notice Emitted when a certain calldata is allowed or disallowed.\n    event AllowedDataChanged(bytes data, bool isAllowed);\n\n    /// @notice Emitted when the selector is labeled as validated or not.\n    event SelectorValidationChanged(bytes4 indexed selector, bool isValidated);\n\n    /// @notice Emitted when the L2 admin is whitelisted or not.\n    event AllowL2Admin(address indexed adminAddress);\n}\n"
      },
      "contracts/governance/L2AdminFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {ChainAdmin} from \"./ChainAdmin.sol\";\nimport {RestrictionValidator} from \"./restriction/RestrictionValidator.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev Contract used to deploy ChainAdmin contracts on L2.\n/// @dev It can be used to ensure that certain L2 admins are deployed with\n/// predefined restrictions. E.g. it can be used to deploy admins that ensure that\n/// a chain is a permanent rollup.\n/// @dev This contract is expected to be deployed in zkEVM (L2) environment.\n/// @dev The contract is immutable, in case the restrictions need to be changed,\n/// a new contract should be deployed.\ncontract L2AdminFactory {\n    /// @notice Emitted when an admin is deployed on the L2.\n    /// @param admin The address of the newly deployed admin.\n    event AdminDeployed(address indexed admin);\n\n    /// @dev We use storage instead of immutable variables due to the\n    /// specifics of the zkEVM environment, where storage is actually cheaper.\n    address[] public requiredRestrictions;\n\n    constructor(address[] memory _requiredRestrictions) {\n        _validateRestrctions(_requiredRestrictions);\n        requiredRestrictions = _requiredRestrictions;\n    }\n\n    /// @notice Deploys a new L2 admin contract.\n    /// @return admin The address of the deployed admin contract.\n    // solhint-disable-next-line gas-calldata-parameters\n    function deployAdmin(address[] memory _additionalRestrictions) external returns (address admin) {\n        // Even though the chain admin will likely perform similar checks,\n        // we keep those here just in case, since it is not expensive, while allowing to fail fast.\n        _validateRestrctions(_additionalRestrictions);\n        uint256 cachedRequired = requiredRestrictions.length;\n        uint256 cachedAdditional = _additionalRestrictions.length;\n        address[] memory restrictions = new address[](cachedRequired + cachedAdditional);\n\n        unchecked {\n            for (uint256 i = 0; i < cachedRequired; ++i) {\n                restrictions[i] = requiredRestrictions[i];\n            }\n            for (uint256 i = 0; i < cachedAdditional; ++i) {\n                restrictions[cachedRequired + i] = _additionalRestrictions[i];\n            }\n        }\n\n        // Note, that we are using CREATE instead of CREATE2 to prevent\n        // an attack where malicious deployer could select malicious `seed1` and `seed2` where\n        // this factory with `seed1` produces the same address as some other random factory with `seed2`,\n        // allowing to deploy a malicious contract.\n        admin = address(new ChainAdmin(restrictions));\n\n        emit AdminDeployed(address(admin));\n    }\n\n    /// @notice Checks that the provided list of restrictions is correct.\n    /// @param _restrictions List of the restrictions to check.\n    /// @dev In case either of the restrictions is not correct, the function reverts.\n    function _validateRestrctions(address[] memory _restrictions) internal view {\n        unchecked {\n            uint256 length = _restrictions.length;\n            for (uint256 i = 0; i < length; ++i) {\n                RestrictionValidator.validateRestriction(_restrictions[i]);\n            }\n        }\n    }\n}\n"
      },
      "contracts/governance/L2ProxyAdminDeployer.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\n// solhint-disable gas-length-in-loops\n\nimport {ProxyAdmin} from \"@openzeppelin/contracts-v4/proxy/transparent/ProxyAdmin.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The contract that deterministically deploys a ProxyAdmin, while\n/// ensuring that its owner is the aliased governance contract\ncontract L2ProxyAdminDeployer {\n    address public immutable PROXY_ADMIN_ADDRESS;\n\n    constructor(address _aliasedGovernance) {\n        ProxyAdmin admin = new ProxyAdmin{salt: bytes32(0)}();\n        admin.transferOwnership(_aliasedGovernance);\n\n        PROXY_ADMIN_ADDRESS = address(admin);\n    }\n}\n"
      },
      "contracts/governance/PermanentRestriction.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {TooHighDeploymentNonce, CallNotAllowed, RemovingPermanentRestriction, ZeroAddress, UnallowedImplementation, AlreadyWhitelisted, NotAllowed} from \"../common/L1ContractErrors.sol\";\n\nimport {L2TransactionRequestTwoBridgesOuter, BridgehubBurnCTMAssetData} from \"../bridgehub/IBridgehub.sol\";\nimport {Ownable2StepUpgradeable} from \"@openzeppelin/contracts-upgradeable-v4/access/Ownable2StepUpgradeable.sol\";\nimport {L2ContractHelper} from \"../common/libraries/L2ContractHelper.sol\";\nimport {NEW_ENCODING_VERSION, IAssetRouterBase} from \"../bridge/asset-router/IAssetRouterBase.sol\";\n\nimport {Call} from \"./Common.sol\";\nimport {Restriction} from \"./restriction/Restriction.sol\";\nimport {IChainAdmin} from \"./IChainAdmin.sol\";\nimport {IBridgehub} from \"../bridgehub/IBridgehub.sol\";\nimport {IZKChain} from \"../state-transition/chain-interfaces/IZKChain.sol\";\nimport {IGetters} from \"../state-transition/chain-interfaces/IGetters.sol\";\nimport {IAdmin} from \"../state-transition/chain-interfaces/IAdmin.sol\";\n\nimport {IPermanentRestriction} from \"./IPermanentRestriction.sol\";\n\n/// @dev The value up to which the nonces of the L2AdminDeployer could be used. This is needed\n/// to limit the impact of the birthday paradox attack, where an attack could craft a malicious\n/// address on L1.\nuint256 constant MAX_ALLOWED_NONCE = (1 << 48);\n\n/// @title PermanentRestriction contract\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice This contract should be used by chains that wish to guarantee that certain security\n/// properties are preserved forever.\n/// @dev To be deployed as a transparent upgradable proxy, owned by a trusted decentralized governance.\n/// @dev Once of the instances of such contract is to ensure that a ZkSyncHyperchain is a rollup forever.\ncontract PermanentRestriction is Restriction, IPermanentRestriction, Ownable2StepUpgradeable {\n    /// @notice The address of the Bridgehub contract.\n    IBridgehub public immutable BRIDGE_HUB;\n\n    /// @notice The address of the L2 admin factory that should be used to deploy the chain admins\n    /// for chains that migrated on top of an L2 settlement layer.\n    /// @dev If this contract is deployed on L2, this address is 0.\n    /// @dev This address is expected to be the same on all L2 chains.\n    address public immutable L2_ADMIN_FACTORY;\n\n    /// @notice The mapping of the allowed admin implementations.\n    mapping(bytes32 implementationCodeHash => bool isAllowed) public allowedAdminImplementations;\n\n    /// @notice The mapping of the allowed calls.\n    mapping(bytes allowedCalldata => bool isAllowed) public allowedCalls;\n\n    /// @notice The mapping of the validated selectors.\n    mapping(bytes4 selector => bool isValidated) public selectorsToValidate;\n\n    /// @notice The mapping of whitelisted L2 admins.\n    mapping(address adminAddress => bool isWhitelisted) public allowedL2Admins;\n\n    constructor(IBridgehub _bridgehub, address _l2AdminFactory) {\n        _disableInitializers();\n        BRIDGE_HUB = _bridgehub;\n        L2_ADMIN_FACTORY = _l2AdminFactory;\n    }\n\n    /// @notice The initialization function for the proxy contract.\n    /// @param _initialOwner The initial owner of the permanent restriction.\n    /// @dev Expected to be delegatecalled by the `TransparentUpgradableProxy`\n    /// upon initialization.\n    function initialize(address _initialOwner) external initializer {\n        if (_initialOwner == address(0)) {\n            revert ZeroAddress();\n        }\n        _transferOwnership(_initialOwner);\n    }\n\n    /// @notice Allows a certain `ChainAdmin` implementation to be used as an admin.\n    /// @param _implementationHash The hash of the implementation code.\n    /// @param _isAllowed The flag that indicates if the implementation is allowed.\n    function setAllowedAdminImplementation(bytes32 _implementationHash, bool _isAllowed) external onlyOwner {\n        allowedAdminImplementations[_implementationHash] = _isAllowed;\n\n        emit AdminImplementationAllowed(_implementationHash, _isAllowed);\n    }\n\n    /// @notice Allows a certain calldata for a selector to be used.\n    /// @param _data The calldata for the function.\n    /// @param _isAllowed The flag that indicates if the calldata is allowed.\n    function setAllowedData(bytes calldata _data, bool _isAllowed) external onlyOwner {\n        allowedCalls[_data] = _isAllowed;\n\n        emit AllowedDataChanged(_data, _isAllowed);\n    }\n\n    /// @notice Allows a certain selector to be validated.\n    /// @param _selector The selector of the function.\n    /// @param _isValidated The flag that indicates if the selector is validated.\n    function setSelectorShouldBeValidated(bytes4 _selector, bool _isValidated) external onlyOwner {\n        selectorsToValidate[_selector] = _isValidated;\n\n        emit SelectorValidationChanged(_selector, _isValidated);\n    }\n\n    /// @notice Whitelists a certain L2 admin.\n    /// @param deploymentNonce The deployment nonce of the `L2_ADMIN_FACTORY` used for the deployment.\n    function allowL2Admin(uint256 deploymentNonce) external {\n        if (deploymentNonce > MAX_ALLOWED_NONCE) {\n            revert TooHighDeploymentNonce();\n        }\n\n        // We do not do any additional validations for constructor data or the bytecode,\n        // we expect that only admins of the allowed format are to be deployed.\n        address expectedAddress = L2ContractHelper.computeCreateAddress(L2_ADMIN_FACTORY, deploymentNonce);\n\n        if (allowedL2Admins[expectedAddress]) {\n            revert AlreadyWhitelisted(expectedAddress);\n        }\n\n        allowedL2Admins[expectedAddress] = true;\n        emit AllowL2Admin(expectedAddress);\n    }\n\n    /// @inheritdoc Restriction\n    function validateCall(\n        Call calldata _call,\n        address // _invoker\n    ) external view override {\n        _validateAsChainAdmin(_call);\n        _validateMigrationToL2(_call);\n        _validateRemoveRestriction(_call);\n    }\n\n    /// @notice Validates the migration to an L2 settlement layer.\n    /// @param _call The call data.\n    /// @dev Note that we do not need to validate the migration to the L1 layer as the admin\n    /// is not changed in this case.\n    function _validateMigrationToL2(Call calldata _call) private view {\n        (address admin, bool isMigration) = _getNewAdminFromMigration(_call);\n        if (isMigration) {\n            if (!allowedL2Admins[admin]) {\n                revert NotAllowed(admin);\n            }\n        }\n    }\n\n    /// @notice Validates the call as the chain admin\n    /// @param _call The call data.\n    function _validateAsChainAdmin(Call calldata _call) private view {\n        if (!_isAdminOfAChain(_call.target)) {\n            // We only validate calls related to being an admin of a chain\n            return;\n        }\n\n        // All calls with the length of the data below 4 will get into `receive`/`fallback` functions,\n        // we consider it to always be allowed.\n        if (_call.data.length < 4) {\n            return;\n        }\n\n        bytes4 selector = bytes4(_call.data[:4]);\n\n        if (selector == IAdmin.setPendingAdmin.selector) {\n            _validateNewAdmin(_call);\n            return;\n        }\n\n        if (!selectorsToValidate[selector]) {\n            // The selector is not validated, any data is allowed.\n            return;\n        }\n\n        if (!allowedCalls[_call.data]) {\n            revert CallNotAllowed(_call.data);\n        }\n    }\n\n    /// @notice Validates the correctness of the new admin.\n    /// @param _call The call data.\n    /// @dev Ensures that the admin has a whitelisted implementation and does not remove this restriction.\n    function _validateNewAdmin(Call calldata _call) private view {\n        address newChainAdmin = abi.decode(_call.data[4:], (address));\n\n        bytes32 implementationCodeHash = newChainAdmin.codehash;\n\n        if (!allowedAdminImplementations[implementationCodeHash]) {\n            revert UnallowedImplementation(implementationCodeHash);\n        }\n\n        // Since the implementation is known to be correct (from the checks above), we\n        // can safely trust the returned value from the call below\n        if (!IChainAdmin(newChainAdmin).isRestrictionActive(address(this))) {\n            revert RemovingPermanentRestriction();\n        }\n    }\n\n    /// @notice Validates the removal of the restriction.\n    /// @param _call The call data.\n    /// @dev Ensures that this restriction is not removed.\n    function _validateRemoveRestriction(Call calldata _call) private view {\n        if (_call.target != msg.sender) {\n            return;\n        }\n\n        if (_call.data.length < 4) {\n            return;\n        }\n\n        if (bytes4(_call.data[:4]) != IChainAdmin.removeRestriction.selector) {\n            return;\n        }\n\n        address removedRestriction = abi.decode(_call.data[4:], (address));\n\n        if (removedRestriction == address(this)) {\n            revert RemovingPermanentRestriction();\n        }\n    }\n\n    /// @notice Checks if the `msg.sender` is an admin of a certain ZkSyncHyperchain.\n    /// @param _chain The address of the chain.\n    function _isAdminOfAChain(address _chain) internal view returns (bool) {\n        if (_chain == address(0)) {\n            return false;\n        }\n\n        // Unfortunately there is no easy way to double check that indeed the `_chain` is a ZkSyncHyperchain.\n        // So we do the following:\n        // - Query it for `chainId`. If it reverts, it is not a ZkSyncHyperchain.\n        // - Query the Bridgehub for the Hyperchain with the given `chainId`.\n        // - We compare the corresponding addresses\n\n        // Note, that we do use assembly here to ensure that the function does not panic in case of\n        // either incorrect `_chain` address or in case the returndata is too large\n\n        (uint256 chainId, bool chainIdQuerySuccess) = _getChainIdUnffallibleCall(_chain);\n\n        if (!chainIdQuerySuccess) {\n            // It is not a hyperchain, so we can return `false` here.\n            return false;\n        }\n\n        // Note, that here it is important to use the legacy `getHyperchain` function, so that the contract\n        // is compatible with the legacy ones.\n        if (BRIDGE_HUB.getHyperchain(chainId) != _chain) {\n            // It is not a hyperchain, so we can return `false` here.\n            return false;\n        }\n\n        // Now, the chain is known to be a hyperchain, so it must implement the corresponding interface\n        address admin = IZKChain(_chain).getAdmin();\n\n        return admin == msg.sender;\n    }\n\n    /// @notice Tries to call `IGetters.getChainId()` function on the `_potentialChainAddress`.\n    /// It ensures that the returndata is of correct format and if not, it returns false.\n    /// @param _chain The address of the potential chain\n    /// @return chainId The chainId of the chain.\n    /// @return success Whether the `chain` is indeed an address of a ZK Chain.\n    /// @dev Returns a tuple of the chainId and whether the call was successful.\n    /// If the second item is `false`, the caller should ignore the first value.\n    function _getChainIdUnffallibleCall(address _chain) private view returns (uint256 chainId, bool success) {\n        bytes4 selector = IGetters.getChainId.selector;\n        assembly {\n            // We use scratch space here, so it is safe\n            mstore(0, selector)\n            success := staticcall(gas(), _chain, 0, 4, 0, 0)\n\n            let isReturndataSizeCorrect := eq(returndatasize(), 32)\n\n            success := and(success, isReturndataSizeCorrect)\n\n            if success {\n                // We use scratch space here, so it is safe\n                returndatacopy(0, 0, 32)\n\n                chainId := mload(0)\n            }\n        }\n    }\n\n    /// @notice Tries to get the new admin from the migration.\n    /// @param _call The call data.\n    /// @return Returns a tuple of of the new admin and whether the transaction is indeed the migration.\n    /// If the second item is `false`, the caller should ignore the first value.\n    /// @dev If any other error is returned, it is assumed to be out of gas or some other unexpected\n    /// error that should be bubbled up by the caller.\n    function _getNewAdminFromMigration(Call calldata _call) internal view returns (address, bool) {\n        if (_call.target != address(BRIDGE_HUB)) {\n            return (address(0), false);\n        }\n\n        if (_call.data.length < 4) {\n            return (address(0), false);\n        }\n\n        if (bytes4(_call.data[:4]) != IBridgehub.requestL2TransactionTwoBridges.selector) {\n            return (address(0), false);\n        }\n\n        address sharedBridge = BRIDGE_HUB.sharedBridge();\n\n        // Assuming that correctly encoded calldata is provided, the following line must never fail,\n        // since the correct selector was checked before.\n        L2TransactionRequestTwoBridgesOuter memory request = abi.decode(\n            _call.data[4:],\n            (L2TransactionRequestTwoBridgesOuter)\n        );\n\n        if (request.secondBridgeAddress != sharedBridge) {\n            return (address(0), false);\n        }\n\n        bytes memory secondBridgeData = request.secondBridgeCalldata;\n        if (secondBridgeData.length == 0) {\n            return (address(0), false);\n        }\n\n        if (secondBridgeData[0] != NEW_ENCODING_VERSION) {\n            return (address(0), false);\n        }\n        bytes memory encodedData = new bytes(secondBridgeData.length - 1);\n        assembly {\n            mcopy(add(encodedData, 0x20), add(secondBridgeData, 0x21), mload(encodedData))\n        }\n\n        // From now on, we know that the used encoding version is `NEW_ENCODING_VERSION` that is\n        // supported only in the new protocol version with Gateway support, so we can assume\n        // that the methods like e.g. Bridgehub.ctmAssetIdToAddress must exist.\n\n        // This is the format of the `secondBridgeData` under the `NEW_ENCODING_VERSION`.\n        // If it fails, it would mean that the data is not correct and the call would eventually fail anyway.\n        (bytes32 chainAssetId, bytes memory bridgehubData) = abi.decode(encodedData, (bytes32, bytes));\n\n        // We will just check that the chainAssetId is a valid chainAssetId.\n        // For now, for simplicity, we do not check that the admin is exactly the admin\n        // of this chain.\n        address ctmAddress = BRIDGE_HUB.ctmAssetIdToAddress(chainAssetId);\n        if (ctmAddress == address(0)) {\n            return (address(0), false);\n        }\n\n        // Almost certainly it will be Bridgehub, but we add this check just in case we have circumstances\n        // that require us to use a different asset handler.\n        address assetHandlerAddress = IAssetRouterBase(sharedBridge).assetHandlerAddress(chainAssetId);\n        if (assetHandlerAddress != address(BRIDGE_HUB)) {\n            return (address(0), false);\n        }\n\n        // The asset handler of CTM is the bridgehub and so the following decoding should work\n        BridgehubBurnCTMAssetData memory burnData = abi.decode(bridgehubData, (BridgehubBurnCTMAssetData));\n        (address l2Admin, ) = abi.decode(burnData.ctmData, (address, bytes));\n\n        return (l2Admin, true);\n    }\n}\n"
      },
      "contracts/governance/TransitionaryOwner.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\n// solhint-disable gas-length-in-loops\n\nimport {Ownable2Step} from \"@openzeppelin/contracts-v4/access/Ownable2Step.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The contract that is used a temporary owner for Ownable2Step contracts until the\n/// governance can accept the ownership\ncontract TransitionaryOwner {\n    address public immutable GOVERNANCE_ADDRESS;\n\n    constructor(address _governanceAddress) {\n        GOVERNANCE_ADDRESS = _governanceAddress;\n    }\n\n    /// @notice Claims that ownership of a contract and transfers it to the governance\n    function claimOwnershipAndGiveToGovernance(address target) external {\n        Ownable2Step(target).acceptOwnership();\n        Ownable2Step(target).transferOwnership(GOVERNANCE_ADDRESS);\n    }\n}\n"
      },
      "contracts/governance/restriction/IRestriction.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Call} from \"../Common.sol\";\n\n/// @dev The magic value that has to be returned by the `getSupportsRestrictionMagic`\nbytes32 constant RESTRICTION_MAGIC = keccak256(\"Restriction\");\n\n/// @title Restriction contract interface\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IRestriction {\n    /// @notice A method used to check that the contract supports this interface.\n    /// @return Returns the `RESTRICTION_MAGIC`\n    function getSupportsRestrictionMagic() external view returns (bytes32);\n\n    /// @notice Ensures that the invoker has the required role to call the function.\n    /// @param _call The call data.\n    /// @param _invoker The address of the invoker.\n    function validateCall(Call calldata _call, address _invoker) external view;\n}\n"
      },
      "contracts/governance/restriction/Restriction.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Call} from \"../Common.sol\";\nimport {IRestriction, RESTRICTION_MAGIC} from \"./IRestriction.sol\";\n\n/// @title Restriction contract interface\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\nabstract contract Restriction is IRestriction {\n    /// @notice A method used to check that the contract supports this interface.\n    /// @return Returns the `RESTRICTION_MAGIC`\n    function getSupportsRestrictionMagic() external view returns (bytes32) {\n        return RESTRICTION_MAGIC;\n    }\n\n    /// @notice Ensures that the invoker has the required role to call the function.\n    /// @param _call The call data.\n    /// @param _invoker The address of the invoker.\n    function validateCall(Call calldata _call, address _invoker) external view virtual;\n}\n"
      },
      "contracts/governance/restriction/RestrictionValidator.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {NotARestriction} from \"../../common/L1ContractErrors.sol\";\nimport {IRestriction, RESTRICTION_MAGIC} from \"./IRestriction.sol\";\n\n/// @title Restriction validator\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The library which validates whether an address can be a valid restriction\nlibrary RestrictionValidator {\n    /// @notice Ensures that the provided address implements the restriction interface\n    /// @dev Note that it *can not guarantee* that the corresponding address indeed implements\n    /// the interface completely or that it is implemented correctly. It is mainly used to\n    /// ensure that invalid restrictions can not be accidentally added.\n    function validateRestriction(address _restriction) internal view {\n        if (IRestriction(_restriction).getSupportsRestrictionMagic() != RESTRICTION_MAGIC) {\n            revert NotARestriction(_restriction);\n        }\n    }\n}\n"
      },
      "contracts/state-transition/ChainTypeManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {EnumerableMap} from \"@openzeppelin/contracts-v4/utils/structs/EnumerableMap.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts-v4/utils/math/SafeCast.sol\";\n\nimport {Diamond} from \"./libraries/Diamond.sol\";\nimport {DiamondProxy} from \"./chain-deps/DiamondProxy.sol\";\nimport {IAdmin} from \"./chain-interfaces/IAdmin.sol\";\nimport {IDiamondInit} from \"./chain-interfaces/IDiamondInit.sol\";\nimport {IExecutor} from \"./chain-interfaces/IExecutor.sol\";\nimport {IChainTypeManager, ChainTypeManagerInitializeData, ChainCreationParams} from \"./IChainTypeManager.sol\";\nimport {IZKChain} from \"./chain-interfaces/IZKChain.sol\";\nimport {FeeParams} from \"./chain-deps/ZKChainStorage.sol\";\nimport {Ownable2StepUpgradeable} from \"@openzeppelin/contracts-upgradeable-v4/access/Ownable2StepUpgradeable.sol\";\nimport {L2_TO_L1_LOG_SERIALIZE_SIZE, DEFAULT_L2_LOGS_TREE_ROOT_HASH, EMPTY_STRING_KECCAK} from \"../common/Config.sol\";\nimport {InitialForceDeploymentMismatch, AdminZero, OutdatedProtocolVersion} from \"./L1StateTransitionErrors.sol\";\nimport {ChainAlreadyLive, Unauthorized, ZeroAddress, HashMismatch, GenesisUpgradeZero, GenesisBatchHashZero, GenesisIndexStorageZero, GenesisBatchCommitmentZero, MigrationsNotPaused} from \"../common/L1ContractErrors.sol\";\nimport {SemVer} from \"../common/libraries/SemVer.sol\";\nimport {IBridgehub} from \"../bridgehub/IBridgehub.sol\";\n\nimport {ReentrancyGuard} from \"../common/ReentrancyGuard.sol\";\n\n/// @title State Transition Manager contract\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract ChainTypeManager is IChainTypeManager, ReentrancyGuard, Ownable2StepUpgradeable {\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n\n    /// @notice Address of the bridgehub\n    address public immutable BRIDGE_HUB;\n\n    /// @notice The map from chainId => zkChain contract\n    EnumerableMap.UintToAddressMap internal __DEPRECATED_zkChainMap;\n\n    /// @dev The batch zero hash, calculated at initialization\n    bytes32 public storedBatchZero;\n\n    /// @dev The stored cutData for diamond cut\n    bytes32 public initialCutHash;\n\n    /// @dev The l1GenesisUpgrade contract address, used to set chainId\n    address public l1GenesisUpgrade;\n\n    /// @dev The current packed protocolVersion. To access human-readable version, use `getSemverProtocolVersion` function.\n    uint256 public protocolVersion;\n\n    /// @dev The timestamp when protocolVersion can be last used\n    mapping(uint256 _protocolVersion => uint256) public protocolVersionDeadline;\n\n    /// @dev The validatorTimelock contract address\n    address public validatorTimelock;\n\n    /// @dev The stored cutData for upgrade diamond cut. protocolVersion => cutHash\n    mapping(uint256 protocolVersion => bytes32 cutHash) public upgradeCutHash;\n\n    /// @dev The address used to manage non critical updates\n    address public admin;\n\n    /// @dev The address to accept the admin role\n    address private pendingAdmin;\n\n    /// @dev The initial force deployment hash\n    bytes32 public initialForceDeploymentHash;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    /// @dev Note, that while the contract does not use `nonReentrant` modifier, we still keep the `reentrancyGuardInitializer`\n    /// here for two reasons:\n    /// - It prevents the function from being called twice (including in the proxy impl).\n    /// - It makes the local version consistent with the one in production, which already had the reentrancy guard\n    /// initialized.\n    constructor(address _bridgehub) reentrancyGuardInitializer {\n        BRIDGE_HUB = _bridgehub;\n\n        // While this does not provide a protection in the production, it is needed for local testing\n        // Length of the L2Log encoding should not be equal to the length of other L2Logs' tree nodes preimages\n        assert(L2_TO_L1_LOG_SERIALIZE_SIZE != 2 * 32);\n\n        _disableInitializers();\n    }\n\n    /// @notice only the bridgehub can call\n    modifier onlyBridgehub() {\n        if (msg.sender != BRIDGE_HUB) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice the admin can call, for non-critical updates\n    modifier onlyOwnerOrAdmin() {\n        if (msg.sender != admin && msg.sender != owner()) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @return The tuple of (major, minor, patch) protocol version.\n    function getSemverProtocolVersion() external view returns (uint32, uint32, uint32) {\n        // slither-disable-next-line unused-return\n        return SemVer.unpackSemVer(SafeCast.toUint96(protocolVersion));\n    }\n\n    /// @notice return the chain contract address for a chainId\n    function getZKChain(uint256 _chainId) public view returns (address) {\n        return IBridgehub(BRIDGE_HUB).getZKChain(_chainId);\n    }\n\n    /// @notice return the chain contract address for a chainId\n    /// @notice Do not use! use getZKChain instead. This will be removed.\n    function getZKChainLegacy(uint256 _chainId) public view returns (address chainAddress) {\n        // slither-disable-next-line unused-return\n        (, chainAddress) = __DEPRECATED_zkChainMap.tryGet(_chainId);\n    }\n\n    /// @notice Returns the address of the ZK chain admin with the corresponding chainID.\n    /// @notice Not related to the CTM, but it is here for legacy reasons.\n    /// @param _chainId the chainId of the chain\n    function getChainAdmin(uint256 _chainId) external view override returns (address) {\n        return IZKChain(getZKChain(_chainId)).getAdmin();\n    }\n\n    /// @dev initialize\n    /// @dev Note, that while the contract does not use `nonReentrant` modifier, we still keep the `reentrancyGuardInitializer`\n    /// here for two reasons:\n    /// - It prevents the function from being called twice (including in the proxy impl).\n    /// - It makes the local version consistent with the one in production, which already had the reentrancy guard\n    /// initialized.\n    function initialize(ChainTypeManagerInitializeData calldata _initializeData) external reentrancyGuardInitializer {\n        if (_initializeData.owner == address(0)) {\n            revert ZeroAddress();\n        }\n        _transferOwnership(_initializeData.owner);\n\n        protocolVersion = _initializeData.protocolVersion;\n        _setProtocolVersionDeadline(_initializeData.protocolVersion, type(uint256).max);\n        validatorTimelock = _initializeData.validatorTimelock;\n\n        _setChainCreationParams(_initializeData.chainCreationParams);\n    }\n\n    /// @notice Updates the parameters with which a new chain is created\n    /// @param _chainCreationParams The new chain creation parameters\n    function _setChainCreationParams(ChainCreationParams calldata _chainCreationParams) internal {\n        if (_chainCreationParams.genesisUpgrade == address(0)) {\n            revert GenesisUpgradeZero();\n        }\n        if (_chainCreationParams.genesisBatchHash == bytes32(0)) {\n            revert GenesisBatchHashZero();\n        }\n        if (_chainCreationParams.genesisIndexRepeatedStorageChanges == uint64(0)) {\n            revert GenesisIndexStorageZero();\n        }\n        if (_chainCreationParams.genesisBatchCommitment == bytes32(0)) {\n            revert GenesisBatchCommitmentZero();\n        }\n\n        l1GenesisUpgrade = _chainCreationParams.genesisUpgrade;\n\n        // We need to initialize the state hash because it is used in the commitment of the next batch\n        IExecutor.StoredBatchInfo memory batchZero = IExecutor.StoredBatchInfo({\n            batchNumber: 0,\n            batchHash: _chainCreationParams.genesisBatchHash,\n            indexRepeatedStorageChanges: _chainCreationParams.genesisIndexRepeatedStorageChanges,\n            numberOfLayer1Txs: 0,\n            priorityOperationsHash: EMPTY_STRING_KECCAK,\n            l2LogsTreeRoot: DEFAULT_L2_LOGS_TREE_ROOT_HASH,\n            timestamp: 0,\n            commitment: _chainCreationParams.genesisBatchCommitment\n        });\n        storedBatchZero = keccak256(abi.encode(batchZero));\n        bytes32 newInitialCutHash = keccak256(abi.encode(_chainCreationParams.diamondCut));\n        initialCutHash = newInitialCutHash;\n        bytes32 forceDeploymentHash = keccak256(abi.encode(_chainCreationParams.forceDeploymentsData));\n        initialForceDeploymentHash = forceDeploymentHash;\n\n        emit NewChainCreationParams({\n            genesisUpgrade: _chainCreationParams.genesisUpgrade,\n            genesisBatchHash: _chainCreationParams.genesisBatchHash,\n            genesisIndexRepeatedStorageChanges: _chainCreationParams.genesisIndexRepeatedStorageChanges,\n            genesisBatchCommitment: _chainCreationParams.genesisBatchCommitment,\n            newInitialCutHash: newInitialCutHash,\n            forceDeploymentHash: forceDeploymentHash\n        });\n    }\n\n    /// @notice Updates the parameters with which a new chain is created\n    /// @param _chainCreationParams The new chain creation parameters\n    function setChainCreationParams(ChainCreationParams calldata _chainCreationParams) external onlyOwner {\n        _setChainCreationParams(_chainCreationParams);\n    }\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    /// @dev Please note, if the owner wants to enforce the admin change it must execute both `setPendingAdmin` and\n    /// `acceptAdmin` atomically. Otherwise `admin` can set different pending admin and so fail to accept the admin rights.\n    function setPendingAdmin(address _newPendingAdmin) external onlyOwnerOrAdmin {\n        // Save previous value into the stack to put it into the event later\n        address oldPendingAdmin = pendingAdmin;\n        // Change pending admin\n        pendingAdmin = _newPendingAdmin;\n        emit NewPendingAdmin(oldPendingAdmin, _newPendingAdmin);\n    }\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external {\n        address currentPendingAdmin = pendingAdmin;\n        // Only proposed by current admin address can claim the admin rights\n        if (msg.sender != currentPendingAdmin) {\n            revert Unauthorized(msg.sender);\n        }\n\n        address previousAdmin = admin;\n        admin = currentPendingAdmin;\n        delete pendingAdmin;\n\n        emit NewPendingAdmin(currentPendingAdmin, address(0));\n        emit NewAdmin(previousAdmin, currentPendingAdmin);\n    }\n\n    /// @dev set validatorTimelock. Cannot do it during initialization, as validatorTimelock is deployed after CTM\n    /// @param _validatorTimelock the new validatorTimelock address\n    function setValidatorTimelock(address _validatorTimelock) external onlyOwner {\n        address oldValidatorTimelock = validatorTimelock;\n        validatorTimelock = _validatorTimelock;\n        emit NewValidatorTimelock(oldValidatorTimelock, _validatorTimelock);\n    }\n\n    /// @dev set New Version with upgrade from old version\n    /// @param _cutData the new diamond cut data\n    /// @param _oldProtocolVersion the old protocol version\n    /// @param _oldProtocolVersionDeadline the deadline for the old protocol version\n    /// @param _newProtocolVersion the new protocol version\n    function setNewVersionUpgrade(\n        Diamond.DiamondCutData calldata _cutData,\n        uint256 _oldProtocolVersion,\n        uint256 _oldProtocolVersionDeadline,\n        uint256 _newProtocolVersion\n    ) external onlyOwner {\n        if (!IBridgehub(BRIDGE_HUB).migrationPaused()) {\n            revert MigrationsNotPaused();\n        }\n\n        bytes32 newCutHash = keccak256(abi.encode(_cutData));\n        uint256 previousProtocolVersion = protocolVersion;\n        upgradeCutHash[_oldProtocolVersion] = newCutHash;\n        _setProtocolVersionDeadline(_oldProtocolVersion, _oldProtocolVersionDeadline);\n        _setProtocolVersionDeadline(_newProtocolVersion, type(uint256).max);\n        protocolVersion = _newProtocolVersion;\n        emit NewProtocolVersion(previousProtocolVersion, _newProtocolVersion);\n        emit NewUpgradeCutHash(_oldProtocolVersion, newCutHash);\n        emit NewUpgradeCutData(_newProtocolVersion, _cutData);\n    }\n\n    /// @dev check that the protocolVersion is active\n    /// @param _protocolVersion the protocol version to check\n    function protocolVersionIsActive(uint256 _protocolVersion) external view override returns (bool) {\n        return block.timestamp <= protocolVersionDeadline[_protocolVersion];\n    }\n\n    /// @notice Set the protocol version deadline\n    /// @param _protocolVersion the protocol version\n    /// @param _timestamp the timestamp is the deadline\n    function setProtocolVersionDeadline(uint256 _protocolVersion, uint256 _timestamp) external onlyOwner {\n        _setProtocolVersionDeadline(_protocolVersion, _timestamp);\n    }\n\n    /// @dev set upgrade for some protocolVersion\n    /// @param _cutData the new diamond cut data\n    /// @param _oldProtocolVersion the old protocol version\n    function setUpgradeDiamondCut(\n        Diamond.DiamondCutData calldata _cutData,\n        uint256 _oldProtocolVersion\n    ) external onlyOwner {\n        bytes32 newCutHash = keccak256(abi.encode(_cutData));\n        upgradeCutHash[_oldProtocolVersion] = newCutHash;\n        emit NewUpgradeCutHash(_oldProtocolVersion, newCutHash);\n    }\n\n    /// @dev freezes the specified chain\n    /// @param _chainId the chainId of the chain\n    function freezeChain(uint256 _chainId) external onlyOwner {\n        IZKChain(getZKChain(_chainId)).freezeDiamond();\n    }\n\n    /// @dev freezes the specified chain\n    /// @param _chainId the chainId of the chain\n    function unfreezeChain(uint256 _chainId) external onlyOwner {\n        IZKChain(getZKChain(_chainId)).unfreezeDiamond();\n    }\n\n    /// @dev reverts batches on the specified chain\n    /// @param _chainId the chainId of the chain\n    /// @param _newLastBatch the new last batch\n    function revertBatches(uint256 _chainId, uint256 _newLastBatch) external onlyOwnerOrAdmin {\n        IZKChain(getZKChain(_chainId)).revertBatchesSharedBridge(_chainId, _newLastBatch);\n    }\n\n    /// @dev execute predefined upgrade\n    /// @param _chainId the chainId of the chain\n    /// @param _oldProtocolVersion the old protocol version\n    /// @param _diamondCut the diamond cut data\n    function upgradeChainFromVersion(\n        uint256 _chainId,\n        uint256 _oldProtocolVersion,\n        Diamond.DiamondCutData calldata _diamondCut\n    ) external onlyOwner {\n        IZKChain(getZKChain(_chainId)).upgradeChainFromVersion(_oldProtocolVersion, _diamondCut);\n    }\n\n    /// @dev executes upgrade on chain\n    /// @param _chainId the chainId of the chain\n    /// @param _diamondCut the diamond cut data\n    function executeUpgrade(uint256 _chainId, Diamond.DiamondCutData calldata _diamondCut) external onlyOwner {\n        IZKChain(getZKChain(_chainId)).executeUpgrade(_diamondCut);\n    }\n\n    /// @dev setPriorityTxMaxGasLimit for the specified chain\n    /// @param _chainId the chainId of the chain\n    /// @param _maxGasLimit the new max gas limit\n    function setPriorityTxMaxGasLimit(uint256 _chainId, uint256 _maxGasLimit) external onlyOwner {\n        IZKChain(getZKChain(_chainId)).setPriorityTxMaxGasLimit(_maxGasLimit);\n    }\n\n    /// @dev setTokenMultiplier for the specified chain\n    /// @param _chainId the chainId of the chain\n    /// @param _nominator the new nominator of the token multiplier\n    /// @param _denominator the new denominator of the token multiplier\n    function setTokenMultiplier(uint256 _chainId, uint128 _nominator, uint128 _denominator) external onlyOwner {\n        IZKChain(getZKChain(_chainId)).setTokenMultiplier(_nominator, _denominator);\n    }\n\n    /// @dev changeFeeParams for the specified chain\n    /// @param _chainId the chainId of the chain\n    /// @param _newFeeParams the new fee params\n    function changeFeeParams(uint256 _chainId, FeeParams calldata _newFeeParams) external onlyOwner {\n        IZKChain(getZKChain(_chainId)).changeFeeParams(_newFeeParams);\n    }\n\n    /// @dev setValidator for the specified chain\n    /// @param _chainId the chainId of the chain\n    /// @param _validator the new validator\n    /// @param _active whether the validator is active\n    function setValidator(uint256 _chainId, address _validator, bool _active) external onlyOwner {\n        IZKChain(getZKChain(_chainId)).setValidator(_validator, _active);\n    }\n\n    /// @dev setPorterAvailability for the specified chain\n    /// @param _chainId the chainId of the chain\n    /// @param _zkPorterIsAvailable whether the zkPorter mode is available\n    function setPorterAvailability(uint256 _chainId, bool _zkPorterIsAvailable) external onlyOwner {\n        IZKChain(getZKChain(_chainId)).setPorterAvailability(_zkPorterIsAvailable);\n    }\n\n    /// registration\n\n    /// @notice deploys a full set of chains contracts\n    /// @param _chainId the chain's id\n    /// @param _baseTokenAssetId the base token asset id used to pay for gas fees\n    /// @param _admin the chain's admin address\n    /// @param _diamondCut the diamond cut data that initializes the chains Diamond Proxy\n    function _deployNewChain(\n        uint256 _chainId,\n        bytes32 _baseTokenAssetId,\n        address _admin,\n        bytes memory _diamondCut\n    ) internal returns (address zkChainAddress) {\n        if (getZKChain(_chainId) != address(0)) {\n            // ZKChain already registered\n            revert ChainAlreadyLive();\n        }\n\n        Diamond.DiamondCutData memory diamondCut = abi.decode(_diamondCut, (Diamond.DiamondCutData));\n\n        {\n            // check input\n            bytes32 cutHashInput = keccak256(_diamondCut);\n            if (cutHashInput != initialCutHash) {\n                revert HashMismatch(initialCutHash, cutHashInput);\n            }\n        }\n\n        // construct init data\n        bytes memory initData;\n        /// all together 4+9*32=292 bytes for the selector + mandatory data\n        // solhint-disable-next-line func-named-parameters\n        initData = bytes.concat(\n            IDiamondInit.initialize.selector,\n            bytes32(_chainId),\n            bytes32(uint256(uint160(BRIDGE_HUB))),\n            bytes32(uint256(uint160(address(this)))),\n            bytes32(protocolVersion),\n            bytes32(uint256(uint160(_admin))),\n            bytes32(uint256(uint160(validatorTimelock))),\n            _baseTokenAssetId,\n            storedBatchZero,\n            diamondCut.initCalldata\n        );\n\n        diamondCut.initCalldata = initData;\n        // deploy zkChainContract\n        // slither-disable-next-line reentrancy-no-eth\n        DiamondProxy zkChainContract = new DiamondProxy{salt: bytes32(0)}(block.chainid, diamondCut);\n        // save data\n        zkChainAddress = address(zkChainContract);\n        emit NewZKChain(_chainId, zkChainAddress);\n    }\n\n    /// @notice called by Bridgehub when a chain registers\n    /// @param _chainId the chain's id\n    /// @param _baseTokenAssetId the base token asset id used to pay for gas fees\n    /// @param _admin the chain's admin address\n    /// @param _initData the diamond cut data, force deployments and factoryDeps encoded\n    /// @param _factoryDeps the factory dependencies used for the genesis upgrade\n    /// that initializes the chains Diamond Proxy\n    function createNewChain(\n        uint256 _chainId,\n        bytes32 _baseTokenAssetId,\n        address _admin,\n        bytes calldata _initData,\n        bytes[] calldata _factoryDeps\n    ) external onlyBridgehub returns (address zkChainAddress) {\n        (bytes memory _diamondCut, bytes memory _forceDeploymentData) = abi.decode(_initData, (bytes, bytes));\n\n        // solhint-disable-next-line func-named-parameters\n        zkChainAddress = _deployNewChain(_chainId, _baseTokenAssetId, _admin, _diamondCut);\n\n        {\n            // check input\n            bytes32 forceDeploymentHash = keccak256(abi.encode(_forceDeploymentData));\n            if (forceDeploymentHash != initialForceDeploymentHash) {\n                revert InitialForceDeploymentMismatch(forceDeploymentHash, initialForceDeploymentHash);\n            }\n        }\n        // genesis upgrade, deploys some contracts, sets chainId\n        IAdmin(zkChainAddress).genesisUpgrade(\n            l1GenesisUpgrade,\n            address(IBridgehub(BRIDGE_HUB).l1CtmDeployer()),\n            _forceDeploymentData,\n            _factoryDeps\n        );\n    }\n\n    /// @param _chainId the chainId of the chain\n    function getProtocolVersion(uint256 _chainId) public view returns (uint256) {\n        return IZKChain(getZKChain(_chainId)).getProtocolVersion();\n    }\n\n    /// @notice Called by the bridgehub during the migration of a chain to another settlement layer.\n    /// @param _chainId The chain id of the chain to be migrated.\n    /// @param _data The data needed to perform the migration.\n    function forwardedBridgeBurn(\n        uint256 _chainId,\n        bytes calldata _data\n    ) external view override onlyBridgehub returns (bytes memory ctmForwardedBridgeMintData) {\n        // Note that the `_diamondCut` here is not for the current chain, for the chain where the migration\n        // happens. The correctness of it will be checked on the CTM on the new settlement layer.\n        (address _newSettlementLayerAdmin, bytes memory _diamondCut) = abi.decode(_data, (address, bytes));\n        if (_newSettlementLayerAdmin == address(0)) {\n            revert AdminZero();\n        }\n\n        // We ensure that the chain has the latest protocol version to avoid edge cases\n        // related to different protocol version support.\n        uint256 chainProtocolVersion = IZKChain(getZKChain(_chainId)).getProtocolVersion();\n        if (chainProtocolVersion != protocolVersion) {\n            revert OutdatedProtocolVersion(chainProtocolVersion, protocolVersion);\n        }\n\n        return\n            abi.encode(\n                IBridgehub(BRIDGE_HUB).baseTokenAssetId(_chainId),\n                _newSettlementLayerAdmin,\n                protocolVersion,\n                _diamondCut\n            );\n    }\n\n    /// @notice Called by the bridgehub during the migration of a chain to the current settlement layer.\n    /// @param _chainId The chain id of the chain to be migrated.\n    /// @param _ctmData The data returned from `forwardedBridgeBurn` for the chain.\n    function forwardedBridgeMint(\n        uint256 _chainId,\n        bytes calldata _ctmData\n    ) external override onlyBridgehub returns (address chainAddress) {\n        (bytes32 _baseTokenAssetId, address _admin, uint256 _protocolVersion, bytes memory _diamondCut) = abi.decode(\n            _ctmData,\n            (bytes32, address, uint256, bytes)\n        );\n\n        // We ensure that the chain has the latest protocol version to avoid edge cases\n        // related to different protocol version support.\n        if (_protocolVersion != protocolVersion) {\n            revert OutdatedProtocolVersion(_protocolVersion, protocolVersion);\n        }\n        chainAddress = _deployNewChain({\n            _chainId: _chainId,\n            _baseTokenAssetId: _baseTokenAssetId,\n            _admin: _admin,\n            _diamondCut: _diamondCut\n        });\n    }\n\n    /// @notice Called by the bridgehub during the failed migration of a chain.\n    /// param _chainId the chainId of the chain\n    /// param _assetInfo the assetInfo of the chain\n    /// param _depositSender the address of that sent the deposit\n    /// param _ctmData the data of the migration\n    function forwardedBridgeRecoverFailedTransfer(\n        uint256 /* _chainId */,\n        bytes32 /* _assetInfo */,\n        address /* _depositSender */,\n        bytes calldata /* _ctmData */\n    ) external {\n        // Function is empty due to the fact that when calling `forwardedBridgeBurn` there are no\n        // state updates that occur.\n    }\n\n    /// @notice Set the protocol version deadline\n    /// @param _protocolVersion the protocol version\n    /// @param _timestamp the timestamp is the deadline\n    function _setProtocolVersionDeadline(uint256 _protocolVersion, uint256 _timestamp) internal {\n        protocolVersionDeadline[_protocolVersion] = _timestamp;\n        emit UpdateProtocolVersionDeadline(_protocolVersion, _timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Legacy functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice return the chain contract address for a chainId\n    function getHyperchain(uint256 _chainId) public view returns (address) {\n        // During upgrade, there will be a period when the zkChains mapping on\n        // bridgehub will not be filled yet, while the ValidatorTimelock\n        // will still query the address to obtain the chain id.\n        //\n        // To cover this case, we firstly use the existing storage and only then\n        // we use the bridgehub if the former was not present.\n        // This logic should be deleted in one of the future upgrades.\n        address legacyAddress = getZKChainLegacy(_chainId);\n        if (legacyAddress != address(0)) {\n            return legacyAddress;\n        }\n        return getZKChain(_chainId);\n    }\n}\n"
      },
      "contracts/state-transition/IChainTypeManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {Diamond} from \"./libraries/Diamond.sol\";\nimport {L2CanonicalTransaction} from \"../common/Messaging.sol\";\nimport {FeeParams} from \"./chain-deps/ZKChainStorage.sol\";\n\n// import {IBridgehub} from \"../bridgehub/IBridgehub.sol\";\n\n/// @notice Struct that holds all data needed for initializing CTM Proxy.\n/// @dev We use struct instead of raw parameters in `initialize` function to prevent \"Stack too deep\" error\n/// @param owner The address who can manage non-critical updates in the contract\n/// @param validatorTimelock The address that serves as consensus, i.e. can submit blocks to be processed\n/// @param chainCreationParams The struct that contains the fields that define how a new chain should be created\n/// @param protocolVersion The initial protocol version on the newly deployed chain\nstruct ChainTypeManagerInitializeData {\n    address owner;\n    address validatorTimelock;\n    ChainCreationParams chainCreationParams;\n    uint256 protocolVersion;\n}\n\n/// @notice The struct that contains the fields that define how a new chain should be created\n/// within this CTM.\n/// @param genesisUpgrade The address that is used in the diamond cut initialize address on chain creation\n/// @param genesisBatchHash Batch hash of the genesis (initial) batch\n/// @param genesisIndexRepeatedStorageChanges The serial number of the shortcut storage key for the genesis batch\n/// @param genesisBatchCommitment The zk-proof commitment for the genesis batch\n/// @param diamondCut The diamond cut for the first upgrade transaction on the newly deployed chain\n// solhint-disable-next-line gas-struct-packing\nstruct ChainCreationParams {\n    address genesisUpgrade;\n    bytes32 genesisBatchHash;\n    uint64 genesisIndexRepeatedStorageChanges;\n    bytes32 genesisBatchCommitment;\n    Diamond.DiamondCutData diamondCut;\n    bytes forceDeploymentsData;\n}\n\ninterface IChainTypeManager {\n    /// @dev Emitted when a new ZKChain is added\n    event NewZKChain(uint256 indexed _chainId, address indexed _zkChainContract);\n\n    /// @dev emitted when an chain registers and a GenesisUpgrade happens\n    event GenesisUpgrade(\n        address indexed _zkChain,\n        L2CanonicalTransaction _l2Transaction,\n        uint256 indexed _protocolVersion\n    );\n\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice ValidatorTimelock changed\n    event NewValidatorTimelock(address indexed oldValidatorTimelock, address indexed newValidatorTimelock);\n\n    /// @notice chain creation parameters changed\n    event NewChainCreationParams(\n        address genesisUpgrade,\n        bytes32 genesisBatchHash,\n        uint64 genesisIndexRepeatedStorageChanges,\n        bytes32 genesisBatchCommitment,\n        bytes32 newInitialCutHash,\n        bytes32 forceDeploymentHash\n    );\n\n    /// @notice New UpgradeCutHash\n    event NewUpgradeCutHash(uint256 indexed protocolVersion, bytes32 indexed upgradeCutHash);\n\n    /// @notice New UpgradeCutData\n    event NewUpgradeCutData(uint256 indexed protocolVersion, Diamond.DiamondCutData diamondCutData);\n\n    /// @notice New ProtocolVersion\n    event NewProtocolVersion(uint256 indexed oldProtocolVersion, uint256 indexed newProtocolVersion);\n\n    /// @notice Updated ProtocolVersion deadline\n    event UpdateProtocolVersionDeadline(uint256 indexed protocolVersion, uint256 deadline);\n\n    function BRIDGE_HUB() external view returns (address);\n\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    function acceptAdmin() external;\n\n    function getZKChain(uint256 _chainId) external view returns (address);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    function getZKChainLegacy(uint256 _chainId) external view returns (address);\n\n    function storedBatchZero() external view returns (bytes32);\n\n    function initialCutHash() external view returns (bytes32);\n\n    function l1GenesisUpgrade() external view returns (address);\n\n    function upgradeCutHash(uint256 _protocolVersion) external view returns (bytes32);\n\n    function protocolVersion() external view returns (uint256);\n\n    function protocolVersionDeadline(uint256 _protocolVersion) external view returns (uint256);\n\n    function protocolVersionIsActive(uint256 _protocolVersion) external view returns (bool);\n\n    function getProtocolVersion(uint256 _chainId) external view returns (uint256);\n\n    function initialize(ChainTypeManagerInitializeData calldata _initializeData) external;\n\n    function setValidatorTimelock(address _validatorTimelock) external;\n\n    function setChainCreationParams(ChainCreationParams calldata _chainCreationParams) external;\n\n    function getChainAdmin(uint256 _chainId) external view returns (address);\n\n    function createNewChain(\n        uint256 _chainId,\n        bytes32 _baseTokenAssetId,\n        address _admin,\n        bytes calldata _initData,\n        bytes[] calldata _factoryDeps\n    ) external returns (address);\n\n    function setNewVersionUpgrade(\n        Diamond.DiamondCutData calldata _cutData,\n        uint256 _oldProtocolVersion,\n        uint256 _oldProtocolVersionDeadline,\n        uint256 _newProtocolVersion\n    ) external;\n\n    function setUpgradeDiamondCut(Diamond.DiamondCutData calldata _cutData, uint256 _oldProtocolVersion) external;\n\n    function executeUpgrade(uint256 _chainId, Diamond.DiamondCutData calldata _diamondCut) external;\n\n    function setPriorityTxMaxGasLimit(uint256 _chainId, uint256 _maxGasLimit) external;\n\n    function freezeChain(uint256 _chainId) external;\n\n    function unfreezeChain(uint256 _chainId) external;\n\n    function setTokenMultiplier(uint256 _chainId, uint128 _nominator, uint128 _denominator) external;\n\n    function changeFeeParams(uint256 _chainId, FeeParams calldata _newFeeParams) external;\n\n    function setValidator(uint256 _chainId, address _validator, bool _active) external;\n\n    function setPorterAvailability(uint256 _chainId, bool _zkPorterIsAvailable) external;\n\n    function upgradeChainFromVersion(\n        uint256 _chainId,\n        uint256 _oldProtocolVersion,\n        Diamond.DiamondCutData calldata _diamondCut\n    ) external;\n\n    function getSemverProtocolVersion() external view returns (uint32, uint32, uint32);\n\n    function forwardedBridgeBurn(\n        uint256 _chainId,\n        bytes calldata _data\n    ) external returns (bytes memory _bridgeMintData);\n\n    function forwardedBridgeMint(uint256 _chainId, bytes calldata _data) external returns (address);\n\n    function forwardedBridgeRecoverFailedTransfer(\n        uint256 _chainId,\n        bytes32 _assetInfo,\n        address _depositSender,\n        bytes calldata _ctmData\n    ) external;\n}\n"
      },
      "contracts/state-transition/L1StateTransitionErrors.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.21;\n\n// 0x2e89f517\nerror L1DAValidatorAddressIsZero();\n\n// 0x944bc075\nerror L2DAValidatorAddressIsZero();\n\n// 0xca1c3cbc\nerror AlreadyMigrated();\n\n// 0xf05c64c6\nerror NotChainAdmin(address prevMsgSender, address admin);\n\n// 0xc59d372c\nerror ProtocolVersionNotUpToDate(uint256 currentProtocolVersion, uint256 protocolVersion);\n\n// 0xedae13f3\nerror ExecutedIsNotConsistentWithVerified(uint256 batchesExecuted, uint256 batchesVerified);\n\n// 0x712d02d2\nerror VerifiedIsNotConsistentWithCommitted(uint256 batchesVerified, uint256 batchesCommitted);\n\n// 0xfb1a3b59\nerror InvalidNumberOfBatchHashes(uint256 batchHashesLength, uint256 expected);\n\n// 0xa840274f\nerror PriorityQueueNotReady();\n\n// 0x79274f04\nerror UnsupportedProofMetadataVersion(uint256 metadataVersion);\n\n// 0xa969e486\nerror LocalRootIsZero();\n\n// 0xbdaf7d42\nerror LocalRootMustBeZero();\n\n// 0xd0266e26\nerror NotSettlementLayer();\n\n// 0x32ddf9a2\nerror NotHyperchain();\n\n// 0x2237c426\nerror MismatchL2DAValidator();\n\n// 0x2c01a4af\nerror MismatchNumberOfLayer1Txs(uint256 numberOfLayer1Txs, uint256 expectedLength);\n\n// 0xfbd630b8\nerror InvalidBatchesDataLength(uint256 batchesDataLength, uint256 priorityOpsDataLength);\n\n// 0x55008233\nerror PriorityOpsDataLeftPathLengthIsNotZero();\n\n// 0x8be936a9\nerror PriorityOpsDataRightPathLengthIsNotZero();\n\n// 0x99d44739\nerror PriorityOpsDataItemHashesLengthIsNotZero();\n\n// 0x885ae069\nerror OperatorDAInputTooSmall(uint256 operatorDAInputLength, uint256 minAllowedLength);\n\n// 0xbeb96791\nerror InvalidNumberOfBlobs(uint256 blobsProvided, uint256 maxBlobsSupported);\n\n// 0xd2531c15\nerror InvalidL2DAOutputHash(bytes32 l2DAValidatorOutputHash);\n\n// 0x04e05fd1\nerror OnlyOneBlobWithCalldataAllowed();\n\n// 0x2dc9747d\nerror PubdataInputTooSmall(uint256 pubdataInputLength, uint256 totalBlobsCommitmentSize);\n\n// 0x9044dff9\nerror PubdataLengthTooBig(uint256 pubdataLength, uint256 totalBlobSizeBytes);\n\n// 0x5513177c\nerror InvalidPubdataHash(bytes32 fullPubdataHash, bytes32 providedPubdataHash);\n\n// 0x5717f940\nerror InvalidPubdataSource(uint8 pubdataSource);\n\n// 0x125d99b0\nerror BlobHashBlobCommitmentMismatchValue();\n\n// 0x7fbff2dd\nerror L1DAValidatorInvalidSender(address msgSender);\n\n// 0xc06789fa\nerror InvalidCommitment();\n\n// 0xc866ff2c\nerror InitialForceDeploymentMismatch(bytes32 forceDeploymentHash, bytes32 initialForceDeploymentHash);\n\n// 0xb325f767\nerror AdminZero();\n\n// 0x681150be\nerror OutdatedProtocolVersion(uint256 protocolVersion, uint256 currentProtocolVersion);\n\n// 0x87470e36\nerror NotL1(uint256 blockChainId);\n\n// 0x90f67ecf\nerror InvalidStartIndex(uint256 treeStartIndex, uint256 commitmentStartIndex);\n\n// 0x0f67bc0a\nerror InvalidUnprocessedIndex(uint256 treeUnprocessedIndex, uint256 commitmentUnprocessedIndex);\n\n// 0x30043900\nerror InvalidNextLeafIndex(uint256 treeNextLeafIndex, uint256 commitmentNextLeafIndex);\n\n// 0xf9ba09d6\nerror NotAllBatchesExecuted();\n\n// 0x9b53b101\nerror NotHistoricalRoot();\n\n// 0xc02d3ee3\nerror ContractNotDeployed();\n\n// 0xd7b2559b\nerror NotMigrated();\n\n// 0x52595598\nerror ValL1DAWrongInputLength(uint256 inputLength, uint256 expectedLength);\n"
      },
      "contracts/state-transition/TestnetVerifier.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Verifier} from \"./Verifier.sol\";\nimport {IVerifier} from \"./chain-interfaces/IVerifier.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Modified version of the main verifier contract for the testnet environment\n/// @dev This contract is used to skip the zkp verification for the testnet environment.\n/// If the proof is not empty, it will verify it using the main verifier contract,\n/// otherwise, it will skip the verification.\ncontract TestnetVerifier is Verifier {\n    constructor() {\n        assert(block.chainid != 1);\n    }\n\n    /// @dev Verifies a zk-SNARK proof, skipping the verification if the proof is empty.\n    /// @inheritdoc IVerifier\n    function verify(uint256[] calldata _publicInputs, uint256[] calldata _proof) public view override returns (bool) {\n        // We allow skipping the zkp verification for the test(net) environment\n        // If the proof is not empty, verify it, otherwise, skip the verification\n        if (_proof.length == 0) {\n            return true;\n        }\n\n        return super.verify(_publicInputs, _proof);\n    }\n}\n"
      },
      "contracts/state-transition/ValidatorTimelock.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Ownable2Step} from \"@openzeppelin/contracts-v4/access/Ownable2Step.sol\";\nimport {LibMap} from \"./libraries/LibMap.sol\";\nimport {IExecutor} from \"./chain-interfaces/IExecutor.sol\";\nimport {IChainTypeManager} from \"./IChainTypeManager.sol\";\nimport {Unauthorized, TimeNotReached, ZeroAddress} from \"../common/L1ContractErrors.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Intermediate smart contract between the validator EOA account and the ZK chains state transition diamond smart contract.\n/// @dev The primary purpose of this contract is to provide a trustless means of delaying batch execution without\n/// modifying the main zkChain diamond contract. As such, even if this contract is compromised, it will not impact the main\n/// contract.\n/// @dev ZKsync actively monitors the chain activity and reacts to any suspicious activity by freezing the chain.\n/// This allows time for investigation and mitigation before resuming normal operations.\n/// @dev The contract overloads all of the 4 methods, that are used in state transition. When the batch is committed,\n/// the timestamp is stored for it. Later, when the owner calls the batch execution, the contract checks that batch\n/// was committed not earlier than X time ago.\ncontract ValidatorTimelock is IExecutor, Ownable2Step {\n    using LibMap for LibMap.Uint32Map;\n\n    /// @dev Part of the IBase interface. Not used in this contract.\n    string public constant override getName = \"ValidatorTimelock\";\n\n    /// @notice The delay between committing and executing batches is changed.\n    event NewExecutionDelay(uint256 _newExecutionDelay);\n\n    /// @notice A new validator has been added.\n    event ValidatorAdded(uint256 indexed _chainId, address _addedValidator);\n\n    /// @notice A validator has been removed.\n    event ValidatorRemoved(uint256 indexed _chainId, address _removedValidator);\n\n    /// @notice Error for when an address is already a validator.\n    error AddressAlreadyValidator(uint256 _chainId);\n\n    /// @notice Error for when an address is not a validator.\n    error ValidatorDoesNotExist(uint256 _chainId);\n\n    /// @dev The chainTypeManager smart contract.\n    IChainTypeManager public chainTypeManager;\n\n    /// @dev The mapping of L2 chainId => batch number => timestamp when it was committed.\n    mapping(uint256 chainId => LibMap.Uint32Map batchNumberToTimestampMapping) internal committedBatchTimestamp;\n\n    /// @dev The address that can commit/revert/validate/execute batches.\n    mapping(uint256 _chainId => mapping(address _validator => bool)) public validators;\n\n    /// @dev The delay between committing and executing batches.\n    uint32 public executionDelay;\n\n    constructor(address _initialOwner, uint32 _executionDelay) {\n        _transferOwnership(_initialOwner);\n        executionDelay = _executionDelay;\n    }\n\n    /// @notice Checks if the caller is the admin of the chain.\n    modifier onlyChainAdmin(uint256 _chainId) {\n        if (msg.sender != chainTypeManager.getChainAdmin(_chainId)) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Checks if the caller is a validator.\n    modifier onlyValidator(uint256 _chainId) {\n        if (!validators[_chainId][msg.sender]) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @dev Sets a new state transition manager.\n    function setChainTypeManager(IChainTypeManager _chainTypeManager) external onlyOwner {\n        if (address(_chainTypeManager) == address(0)) {\n            revert ZeroAddress();\n        }\n        chainTypeManager = _chainTypeManager;\n    }\n\n    /// @dev Sets an address as a validator.\n    function addValidator(uint256 _chainId, address _newValidator) external onlyChainAdmin(_chainId) {\n        if (validators[_chainId][_newValidator]) {\n            revert AddressAlreadyValidator(_chainId);\n        }\n        validators[_chainId][_newValidator] = true;\n        emit ValidatorAdded(_chainId, _newValidator);\n    }\n\n    /// @dev Removes an address as a validator.\n    function removeValidator(uint256 _chainId, address _validator) external onlyChainAdmin(_chainId) {\n        if (!validators[_chainId][_validator]) {\n            revert ValidatorDoesNotExist(_chainId);\n        }\n        validators[_chainId][_validator] = false;\n        emit ValidatorRemoved(_chainId, _validator);\n    }\n\n    /// @dev Set the delay between committing and executing batches.\n    function setExecutionDelay(uint32 _executionDelay) external onlyOwner {\n        executionDelay = _executionDelay;\n        emit NewExecutionDelay(_executionDelay);\n    }\n\n    /// @dev Returns the timestamp when `_l2BatchNumber` was committed.\n    function getCommittedBatchTimestamp(uint256 _chainId, uint256 _l2BatchNumber) external view returns (uint256) {\n        return committedBatchTimestamp[_chainId].get(_l2BatchNumber);\n    }\n\n    /// @dev Records the timestamp for all provided committed batches and make\n    /// a call to the zkChain diamond contract with the same calldata.\n    function commitBatchesSharedBridge(\n        uint256 _chainId,\n        uint256 _processBatchFrom,\n        uint256 _processBatchTo,\n        bytes calldata\n    ) external onlyValidator(_chainId) {\n        unchecked {\n            // This contract is only a temporary solution, that hopefully will be disabled until 2106 year, so...\n            // It is safe to cast.\n            uint32 timestamp = uint32(block.timestamp);\n            // We disable this check because calldata array length is cheap.\n            for (uint256 i = _processBatchFrom; i <= _processBatchTo; ++i) {\n                committedBatchTimestamp[_chainId].set(i, timestamp);\n            }\n        }\n        _propagateToZKChain(_chainId);\n    }\n\n    /// @dev Make a call to the zkChain diamond contract with the same calldata.\n    /// Note: If the batch is reverted, it needs to be committed first before the execution.\n    /// So it's safe to not override the committed batches.\n    function revertBatchesSharedBridge(uint256 _chainId, uint256) external onlyValidator(_chainId) {\n        _propagateToZKChain(_chainId);\n    }\n\n    /// @dev Make a call to the zkChain diamond contract with the same calldata.\n    /// Note: We don't track the time when batches are proven, since all information about\n    /// the batch is known on the commit stage and the proved is not finalized (may be reverted).\n    function proveBatchesSharedBridge(\n        uint256 _chainId,\n        uint256, // _processBatchFrom\n        uint256, // _processBatchTo\n        bytes calldata\n    ) external onlyValidator(_chainId) {\n        _propagateToZKChain(_chainId);\n    }\n\n    /// @dev Check that batches were committed at least X time ago and\n    /// make a call to the zkChain diamond contract with the same calldata.\n    function executeBatchesSharedBridge(\n        uint256 _chainId,\n        uint256 _processBatchFrom,\n        uint256 _processBatchTo,\n        bytes calldata\n    ) external onlyValidator(_chainId) {\n        uint256 delay = executionDelay; // uint32\n        unchecked {\n            // We disable this check because calldata array length is cheap.\n            for (uint256 i = _processBatchFrom; i <= _processBatchTo; ++i) {\n                uint256 commitBatchTimestamp = committedBatchTimestamp[_chainId].get(i);\n\n                // Note: if the `commitBatchTimestamp` is zero, that means either:\n                // * The batch was committed, but not through this contract.\n                // * The batch wasn't committed at all, so execution will fail in the ZKsync contract.\n                // We allow executing such batches.\n\n                if (block.timestamp < commitBatchTimestamp + delay) {\n                    revert TimeNotReached(commitBatchTimestamp + delay, block.timestamp);\n                }\n            }\n        }\n        _propagateToZKChain(_chainId);\n    }\n\n    /// @dev Call the zkChain diamond contract with the same calldata as this contract was called.\n    /// Note: it is called the zkChain diamond contract, not delegatecalled!\n    function _propagateToZKChain(uint256 _chainId) internal {\n        // Note, that it is important to use chain type manager and\n        // the legacy method here for obtaining the chain id in order for\n        // this contract to before the CTM upgrade is finalized.\n        address contractAddress = chainTypeManager.getHyperchain(_chainId);\n        if (contractAddress == address(0)) {\n            revert ZeroAddress();\n        }\n        assembly {\n            // Copy function signature and arguments from calldata at zero position into memory at pointer position\n            calldatacopy(0, 0, calldatasize())\n            // Call method of the ZK chain diamond contract returns 0 on error\n            let result := call(gas(), contractAddress, 0, 0, calldatasize(), 0, 0)\n            // Get the size of the last return data\n            let size := returndatasize()\n            // Copy the size length of bytes from return data at zero position to pointer position\n            returndatacopy(0, 0, size)\n            // Depending on the result value\n            switch result\n            case 0 {\n                // End execution and revert state changes\n                revert(0, size)\n            }\n            default {\n                // Return data with length of size at pointers position\n                return(0, size)\n            }\n        }\n    }\n}\n"
      },
      "contracts/state-transition/Verifier.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IVerifier} from \"./chain-interfaces/IVerifier.sol\";\n\n/* solhint-disable max-line-length */\n/// @author Matter Labs\n/// @notice Modified version of the Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of\n/// Knowledge (PLONK) verifier.\n/// Modifications have been made to optimize the proof system for ZK chain circuits.\n/// @dev Contract was generated from a verification key with a hash of 0x14f97b81e54b35fe673d8708cc1a19e1ea5b5e348e12d31e39824ed4f42bbca2\n/// @dev It uses a custom memory layout inside the inline assembly block. Each reserved memory cell is declared in the\n/// constants below.\n/// @dev For a better understanding of the verifier algorithm please refer to the following papers:\n/// * Original Plonk Article: https://eprint.iacr.org/2019/953.pdf\n/// * Original LookUp Article: https://eprint.iacr.org/2020/315.pdf\n/// * Plonk for ZKsync v1.1: https://github.com/matter-labs/solidity_plonk_verifier/raw/recursive/bellman_vk_codegen_recursive/RecursivePlonkUnrolledForEthereum.pdf\n/// The notation used in the code is the same as in the papers.\n/* solhint-enable max-line-length */\ncontract Verifier is IVerifier {\n    /*//////////////////////////////////////////////////////////////\n                             Verification keys\n    //////////////////////////////////////////////////////////////*/\n\n    // Memory slots from 0x000 to 0x200 are reserved for intermediate computations and call to precompiles.\n\n    uint256 internal constant VK_GATE_SETUP_0_X_SLOT = 0x200 + 0x000;\n    uint256 internal constant VK_GATE_SETUP_0_Y_SLOT = 0x200 + 0x020;\n    uint256 internal constant VK_GATE_SETUP_1_X_SLOT = 0x200 + 0x040;\n    uint256 internal constant VK_GATE_SETUP_1_Y_SLOT = 0x200 + 0x060;\n    uint256 internal constant VK_GATE_SETUP_2_X_SLOT = 0x200 + 0x080;\n    uint256 internal constant VK_GATE_SETUP_2_Y_SLOT = 0x200 + 0x0a0;\n    uint256 internal constant VK_GATE_SETUP_3_X_SLOT = 0x200 + 0x0c0;\n    uint256 internal constant VK_GATE_SETUP_3_Y_SLOT = 0x200 + 0x0e0;\n    uint256 internal constant VK_GATE_SETUP_4_X_SLOT = 0x200 + 0x100;\n    uint256 internal constant VK_GATE_SETUP_4_Y_SLOT = 0x200 + 0x120;\n    uint256 internal constant VK_GATE_SETUP_5_X_SLOT = 0x200 + 0x140;\n    uint256 internal constant VK_GATE_SETUP_5_Y_SLOT = 0x200 + 0x160;\n    uint256 internal constant VK_GATE_SETUP_6_X_SLOT = 0x200 + 0x180;\n    uint256 internal constant VK_GATE_SETUP_6_Y_SLOT = 0x200 + 0x1a0;\n    uint256 internal constant VK_GATE_SETUP_7_X_SLOT = 0x200 + 0x1c0;\n    uint256 internal constant VK_GATE_SETUP_7_Y_SLOT = 0x200 + 0x1e0;\n\n    uint256 internal constant VK_GATE_SELECTORS_0_X_SLOT = 0x200 + 0x200;\n    uint256 internal constant VK_GATE_SELECTORS_0_Y_SLOT = 0x200 + 0x220;\n    uint256 internal constant VK_GATE_SELECTORS_1_X_SLOT = 0x200 + 0x240;\n    uint256 internal constant VK_GATE_SELECTORS_1_Y_SLOT = 0x200 + 0x260;\n\n    uint256 internal constant VK_PERMUTATION_0_X_SLOT = 0x200 + 0x280;\n    uint256 internal constant VK_PERMUTATION_0_Y_SLOT = 0x200 + 0x2a0;\n    uint256 internal constant VK_PERMUTATION_1_X_SLOT = 0x200 + 0x2c0;\n    uint256 internal constant VK_PERMUTATION_1_Y_SLOT = 0x200 + 0x2e0;\n    uint256 internal constant VK_PERMUTATION_2_X_SLOT = 0x200 + 0x300;\n    uint256 internal constant VK_PERMUTATION_2_Y_SLOT = 0x200 + 0x320;\n    uint256 internal constant VK_PERMUTATION_3_X_SLOT = 0x200 + 0x340;\n    uint256 internal constant VK_PERMUTATION_3_Y_SLOT = 0x200 + 0x360;\n\n    uint256 internal constant VK_LOOKUP_SELECTOR_X_SLOT = 0x200 + 0x380;\n    uint256 internal constant VK_LOOKUP_SELECTOR_Y_SLOT = 0x200 + 0x3a0;\n\n    uint256 internal constant VK_LOOKUP_TABLE_0_X_SLOT = 0x200 + 0x3c0;\n    uint256 internal constant VK_LOOKUP_TABLE_0_Y_SLOT = 0x200 + 0x3e0;\n    uint256 internal constant VK_LOOKUP_TABLE_1_X_SLOT = 0x200 + 0x400;\n    uint256 internal constant VK_LOOKUP_TABLE_1_Y_SLOT = 0x200 + 0x420;\n    uint256 internal constant VK_LOOKUP_TABLE_2_X_SLOT = 0x200 + 0x440;\n    uint256 internal constant VK_LOOKUP_TABLE_2_Y_SLOT = 0x200 + 0x460;\n    uint256 internal constant VK_LOOKUP_TABLE_3_X_SLOT = 0x200 + 0x480;\n    uint256 internal constant VK_LOOKUP_TABLE_3_Y_SLOT = 0x200 + 0x4a0;\n\n    uint256 internal constant VK_LOOKUP_TABLE_TYPE_X_SLOT = 0x200 + 0x4c0;\n    uint256 internal constant VK_LOOKUP_TABLE_TYPE_Y_SLOT = 0x200 + 0x4e0;\n\n    uint256 internal constant VK_RECURSIVE_FLAG_SLOT = 0x200 + 0x500;\n\n    /*//////////////////////////////////////////////////////////////\n                             Proof\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant PROOF_PUBLIC_INPUT = 0x200 + 0x520 + 0x000;\n\n    uint256 internal constant PROOF_STATE_POLYS_0_X_SLOT = 0x200 + 0x520 + 0x020;\n    uint256 internal constant PROOF_STATE_POLYS_0_Y_SLOT = 0x200 + 0x520 + 0x040;\n    uint256 internal constant PROOF_STATE_POLYS_1_X_SLOT = 0x200 + 0x520 + 0x060;\n    uint256 internal constant PROOF_STATE_POLYS_1_Y_SLOT = 0x200 + 0x520 + 0x080;\n    uint256 internal constant PROOF_STATE_POLYS_2_X_SLOT = 0x200 + 0x520 + 0x0a0;\n    uint256 internal constant PROOF_STATE_POLYS_2_Y_SLOT = 0x200 + 0x520 + 0x0c0;\n    uint256 internal constant PROOF_STATE_POLYS_3_X_SLOT = 0x200 + 0x520 + 0x0e0;\n    uint256 internal constant PROOF_STATE_POLYS_3_Y_SLOT = 0x200 + 0x520 + 0x100;\n\n    uint256 internal constant PROOF_COPY_PERMUTATION_GRAND_PRODUCT_X_SLOT = 0x200 + 0x520 + 0x120;\n    uint256 internal constant PROOF_COPY_PERMUTATION_GRAND_PRODUCT_Y_SLOT = 0x200 + 0x520 + 0x140;\n\n    uint256 internal constant PROOF_LOOKUP_S_POLY_X_SLOT = 0x200 + 0x520 + 0x160;\n    uint256 internal constant PROOF_LOOKUP_S_POLY_Y_SLOT = 0x200 + 0x520 + 0x180;\n\n    uint256 internal constant PROOF_LOOKUP_GRAND_PRODUCT_X_SLOT = 0x200 + 0x520 + 0x1a0;\n    uint256 internal constant PROOF_LOOKUP_GRAND_PRODUCT_Y_SLOT = 0x200 + 0x520 + 0x1c0;\n\n    uint256 internal constant PROOF_QUOTIENT_POLY_PARTS_0_X_SLOT = 0x200 + 0x520 + 0x1e0;\n    uint256 internal constant PROOF_QUOTIENT_POLY_PARTS_0_Y_SLOT = 0x200 + 0x520 + 0x200;\n    uint256 internal constant PROOF_QUOTIENT_POLY_PARTS_1_X_SLOT = 0x200 + 0x520 + 0x220;\n    uint256 internal constant PROOF_QUOTIENT_POLY_PARTS_1_Y_SLOT = 0x200 + 0x520 + 0x240;\n    uint256 internal constant PROOF_QUOTIENT_POLY_PARTS_2_X_SLOT = 0x200 + 0x520 + 0x260;\n    uint256 internal constant PROOF_QUOTIENT_POLY_PARTS_2_Y_SLOT = 0x200 + 0x520 + 0x280;\n    uint256 internal constant PROOF_QUOTIENT_POLY_PARTS_3_X_SLOT = 0x200 + 0x520 + 0x2a0;\n    uint256 internal constant PROOF_QUOTIENT_POLY_PARTS_3_Y_SLOT = 0x200 + 0x520 + 0x2c0;\n\n    uint256 internal constant PROOF_STATE_POLYS_0_OPENING_AT_Z_SLOT = 0x200 + 0x520 + 0x2e0;\n    uint256 internal constant PROOF_STATE_POLYS_1_OPENING_AT_Z_SLOT = 0x200 + 0x520 + 0x300;\n    uint256 internal constant PROOF_STATE_POLYS_2_OPENING_AT_Z_SLOT = 0x200 + 0x520 + 0x320;\n    uint256 internal constant PROOF_STATE_POLYS_3_OPENING_AT_Z_SLOT = 0x200 + 0x520 + 0x340;\n\n    uint256 internal constant PROOF_STATE_POLYS_3_OPENING_AT_Z_OMEGA_SLOT = 0x200 + 0x520 + 0x360;\n    uint256 internal constant PROOF_GATE_SELECTORS_0_OPENING_AT_Z_SLOT = 0x200 + 0x520 + 0x380;\n\n    uint256 internal constant PROOF_COPY_PERMUTATION_POLYS_0_OPENING_AT_Z_SLOT = 0x200 + 0x520 + 0x3a0;\n    uint256 internal constant PROOF_COPY_PERMUTATION_POLYS_1_OPENING_AT_Z_SLOT = 0x200 + 0x520 + 0x3c0;\n    uint256 internal constant PROOF_COPY_PERMUTATION_POLYS_2_OPENING_AT_Z_SLOT = 0x200 + 0x520 + 0x3e0;\n\n    uint256 internal constant PROOF_COPY_PERMUTATION_GRAND_PRODUCT_OPENING_AT_Z_OMEGA_SLOT = 0x200 + 0x520 + 0x400;\n    uint256 internal constant PROOF_LOOKUP_S_POLY_OPENING_AT_Z_OMEGA_SLOT = 0x200 + 0x520 + 0x420;\n    uint256 internal constant PROOF_LOOKUP_GRAND_PRODUCT_OPENING_AT_Z_OMEGA_SLOT = 0x200 + 0x520 + 0x440;\n    uint256 internal constant PROOF_LOOKUP_T_POLY_OPENING_AT_Z_SLOT = 0x200 + 0x520 + 0x460;\n    uint256 internal constant PROOF_LOOKUP_T_POLY_OPENING_AT_Z_OMEGA_SLOT = 0x200 + 0x520 + 0x480;\n    uint256 internal constant PROOF_LOOKUP_SELECTOR_POLY_OPENING_AT_Z_SLOT = 0x200 + 0x520 + 0x4a0;\n    uint256 internal constant PROOF_LOOKUP_TABLE_TYPE_POLY_OPENING_AT_Z_SLOT = 0x200 + 0x520 + 0x4c0;\n    uint256 internal constant PROOF_QUOTIENT_POLY_OPENING_AT_Z_SLOT = 0x200 + 0x520 + 0x4e0;\n    uint256 internal constant PROOF_LINEARISATION_POLY_OPENING_AT_Z_SLOT = 0x200 + 0x520 + 0x500;\n\n    uint256 internal constant PROOF_OPENING_PROOF_AT_Z_X_SLOT = 0x200 + 0x520 + 0x520;\n    uint256 internal constant PROOF_OPENING_PROOF_AT_Z_Y_SLOT = 0x200 + 0x520 + 0x540;\n    uint256 internal constant PROOF_OPENING_PROOF_AT_Z_OMEGA_X_SLOT = 0x200 + 0x520 + 0x560;\n    uint256 internal constant PROOF_OPENING_PROOF_AT_Z_OMEGA_Y_SLOT = 0x200 + 0x520 + 0x580;\n\n    uint256 internal constant PROOF_RECURSIVE_PART_P1_X_SLOT = 0x200 + 0x520 + 0x5a0;\n    uint256 internal constant PROOF_RECURSIVE_PART_P1_Y_SLOT = 0x200 + 0x520 + 0x5c0;\n\n    uint256 internal constant PROOF_RECURSIVE_PART_P2_X_SLOT = 0x200 + 0x520 + 0x5e0;\n    uint256 internal constant PROOF_RECURSIVE_PART_P2_Y_SLOT = 0x200 + 0x520 + 0x600;\n\n    /*//////////////////////////////////////////////////////////////\n                             Transcript slot\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant TRANSCRIPT_BEGIN_SLOT = 0x200 + 0x520 + 0x620 + 0x00;\n    uint256 internal constant TRANSCRIPT_DST_BYTE_SLOT = 0x200 + 0x520 + 0x620 + 0x03;\n    uint256 internal constant TRANSCRIPT_STATE_0_SLOT = 0x200 + 0x520 + 0x620 + 0x04;\n    uint256 internal constant TRANSCRIPT_STATE_1_SLOT = 0x200 + 0x520 + 0x620 + 0x24;\n    uint256 internal constant TRANSCRIPT_CHALLENGE_SLOT = 0x200 + 0x520 + 0x620 + 0x44;\n\n    /*//////////////////////////////////////////////////////////////\n                             Partial verifier state\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant STATE_ALPHA_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x000;\n    uint256 internal constant STATE_BETA_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x020;\n    uint256 internal constant STATE_GAMMA_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x040;\n    uint256 internal constant STATE_POWER_OF_ALPHA_2_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x060;\n    uint256 internal constant STATE_POWER_OF_ALPHA_3_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x080;\n    uint256 internal constant STATE_POWER_OF_ALPHA_4_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x0a0;\n    uint256 internal constant STATE_POWER_OF_ALPHA_5_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x0c0;\n    uint256 internal constant STATE_POWER_OF_ALPHA_6_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x0e0;\n    uint256 internal constant STATE_POWER_OF_ALPHA_7_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x100;\n    uint256 internal constant STATE_POWER_OF_ALPHA_8_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x120;\n    uint256 internal constant STATE_ETA_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x140;\n    uint256 internal constant STATE_BETA_LOOKUP_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x160;\n    uint256 internal constant STATE_GAMMA_LOOKUP_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x180;\n    uint256 internal constant STATE_BETA_PLUS_ONE_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x1a0;\n    uint256 internal constant STATE_BETA_GAMMA_PLUS_GAMMA_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x1c0;\n    uint256 internal constant STATE_V_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x1e0;\n    uint256 internal constant STATE_U_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x200;\n    uint256 internal constant STATE_Z_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x220;\n    uint256 internal constant STATE_Z_MINUS_LAST_OMEGA_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x240;\n    uint256 internal constant STATE_L_0_AT_Z_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x260;\n    uint256 internal constant STATE_L_N_MINUS_ONE_AT_Z_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x280;\n    uint256 internal constant STATE_Z_IN_DOMAIN_SIZE = 0x200 + 0x520 + 0x620 + 0x80 + 0x2a0;\n\n    /*//////////////////////////////////////////////////////////////\n                             Queries\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant QUERIES_BUFFER_POINT_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0x00;\n\n    uint256 internal constant QUERIES_AT_Z_0_X_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0x40;\n    uint256 internal constant QUERIES_AT_Z_0_Y_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0x60;\n    uint256 internal constant QUERIES_AT_Z_1_X_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0x80;\n    uint256 internal constant QUERIES_AT_Z_1_Y_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0xa0;\n\n    uint256 internal constant QUERIES_T_POLY_AGGREGATED_X_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0xc0;\n    uint256 internal constant QUERIES_T_POLY_AGGREGATED_Y_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0xe0;\n\n    /*//////////////////////////////////////////////////////////////\n                             Aggregated commitment\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant AGGREGATED_AT_Z_X_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0x100 + 0x00;\n    uint256 internal constant AGGREGATED_AT_Z_Y_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0x100 + 0x20;\n\n    uint256 internal constant AGGREGATED_AT_Z_OMEGA_X_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0x100 + 0x40;\n    uint256 internal constant AGGREGATED_AT_Z_OMEGA_Y_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0x100 + 0x60;\n\n    uint256 internal constant AGGREGATED_OPENING_AT_Z_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0x100 + 0x80;\n    uint256 internal constant AGGREGATED_OPENING_AT_Z_OMEGA_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0x100 + 0xa0;\n\n    /*//////////////////////////////////////////////////////////////\n                             Pairing data\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant PAIRING_BUFFER_POINT_X_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0x100 + 0xc0 + 0x00;\n    uint256 internal constant PAIRING_BUFFER_POINT_Y_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0x100 + 0xc0 + 0x20;\n\n    uint256 internal constant PAIRING_PAIR_WITH_GENERATOR_X_SLOT =\n        0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0x100 + 0xc0 + 0x40;\n    uint256 internal constant PAIRING_PAIR_WITH_GENERATOR_Y_SLOT =\n        0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0x100 + 0xc0 + 0x60;\n\n    uint256 internal constant PAIRING_PAIR_WITH_X_X_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0x100 + 0x100 + 0x80;\n    uint256 internal constant PAIRING_PAIR_WITH_X_Y_SLOT = 0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0x100 + 0x100 + 0xa0;\n\n    /*//////////////////////////////////////////////////////////////\n               Slots for scalar multiplication optimizations\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant COPY_PERMUTATION_FIRST_AGGREGATED_COMMITMENT_COEFF =\n        0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0x100 + 0x100 + 0xc0;\n    uint256 internal constant LOOKUP_GRAND_PRODUCT_FIRST_AGGREGATED_COMMITMENT_COEFF =\n        0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0x100 + 0x100 + 0xe0;\n    uint256 internal constant LOOKUP_S_FIRST_AGGREGATED_COMMITMENT_COEFF =\n        0x200 + 0x520 + 0x620 + 0x80 + 0x2c0 + 0x100 + 0x100 + 0x100;\n\n    /*//////////////////////////////////////////////////////////////\n                             Constants\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant OMEGA = 0x1951441010b2b95a6e47a6075066a50a036f5ba978c050f2821df86636c0facb;\n    uint256 internal constant DOMAIN_SIZE = 0x1000000; // 2^24\n    uint256 internal constant Q_MOD = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n    uint256 internal constant R_MOD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    /// @dev flip of 0xe000000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant FR_MASK = 0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    // non residues\n    uint256 internal constant NON_RESIDUES_0 = 0x05;\n    uint256 internal constant NON_RESIDUES_1 = 0x07;\n    uint256 internal constant NON_RESIDUES_2 = 0x0a;\n\n    // trusted setup g2 elements\n    uint256 internal constant G2_ELEMENTS_0_X1 = 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2;\n    uint256 internal constant G2_ELEMENTS_0_X2 = 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed;\n    uint256 internal constant G2_ELEMENTS_0_Y1 = 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b;\n    uint256 internal constant G2_ELEMENTS_0_Y2 = 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa;\n    uint256 internal constant G2_ELEMENTS_1_X1 = 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1;\n    uint256 internal constant G2_ELEMENTS_1_X2 = 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0;\n    uint256 internal constant G2_ELEMENTS_1_Y1 = 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4;\n    uint256 internal constant G2_ELEMENTS_1_Y2 = 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55;\n\n    /// @inheritdoc IVerifier\n    function verificationKeyHash() external pure returns (bytes32 vkHash) {\n        _loadVerificationKey();\n\n        assembly {\n            let start := VK_GATE_SETUP_0_X_SLOT\n            let end := VK_RECURSIVE_FLAG_SLOT\n            let length := add(sub(end, start), 0x20)\n\n            vkHash := keccak256(start, length)\n        }\n    }\n\n    /// @notice Load verification keys to memory in runtime.\n    /// @dev The constants are loaded into memory in a specific layout declared in the constants starting from\n    /// `VK_` prefix.\n    /// NOTE: Function may corrupt the memory state if some memory was used before this function was called.\n    /// The VK consists of commitments to setup polynomials:\n    /// [q_a], [q_b], [q_c], [q_d],                  - main gate setup commitments\n    /// [q_{d_next}], [q_ab], [q_ac], [q_const]      /\n    /// [main_gate_selector], [custom_gate_selector] - gate selectors commitments\n    /// [sigma_0], [sigma_1], [sigma_2], [sigma_3]   - permutation polynomials commitments\n    /// [lookup_selector]                            - lookup selector commitment\n    /// [col_0], [col_1], [col_2], [col_3]           - lookup columns commitments\n    /// [table_type]                                 - lookup table type commitment\n    function _loadVerificationKey() internal pure virtual {\n        assembly {\n            // gate setup commitments\n            mstore(VK_GATE_SETUP_0_X_SLOT, 0x110deb1e0863737f9a3d7b4de641a03aa00a77bc9f1a05acc9d55b76ab9fdd4d)\n            mstore(VK_GATE_SETUP_0_Y_SLOT, 0x2c9dc252441e9298b7f6df6335a252517b7bccb924adf537b87c5cd3383fd7a9)\n            mstore(VK_GATE_SETUP_1_X_SLOT, 0x04659caf7b05471ba5ba85b1ab62267aa6c456836e625f169f7119d55b9462d2)\n            mstore(VK_GATE_SETUP_1_Y_SLOT, 0x0ea63403692148d2ad22189a1e5420076312f4d46e62036a043a6b0b84d5b410)\n            mstore(VK_GATE_SETUP_2_X_SLOT, 0x0e6696d09d65fce1e42805be03fca1f14aea247281f688981f925e77d4ce2291)\n            mstore(VK_GATE_SETUP_2_Y_SLOT, 0x0228f6cf8fe20c1e07e5b78bf8c41d50e55975a126d22a198d1e56acd4bbb3dd)\n            mstore(VK_GATE_SETUP_3_X_SLOT, 0x14685dafe340b1dec5eafcd5e7faddaf24f3781ddc53309cc25d0b42c00541dd)\n            mstore(VK_GATE_SETUP_3_Y_SLOT, 0x0e651cff9447cb360198899b80fa23e89ec13bc94ff161729aa841d2b55ea5be)\n            mstore(VK_GATE_SETUP_4_X_SLOT, 0x16e9ef76cb68f2750eb0ee72382dd9911a982308d0ab10ef94dada13c382ae73)\n            mstore(VK_GATE_SETUP_4_Y_SLOT, 0x22e404bc91350f3bc7daad1d1025113742436983c85eac5ab7b42221a181b81e)\n            mstore(VK_GATE_SETUP_5_X_SLOT, 0x0d9b29613037a5025655c82b143d2b7449c98f3aea358307c8529249cc54f3b9)\n            mstore(VK_GATE_SETUP_5_Y_SLOT, 0x15b3c4c946ad1babfc4c03ff7c2423fd354af3a9305c499b7fb3aaebe2fee746)\n            mstore(VK_GATE_SETUP_6_X_SLOT, 0x2a4cb6c495dbc7201142cc773da895ae2046e790073988fb850aca6aead27b8a)\n            mstore(VK_GATE_SETUP_6_Y_SLOT, 0x28ef9200c3cb67da82030520d640292014f5f7c2e2909da608812e04671a3acf)\n            mstore(VK_GATE_SETUP_7_X_SLOT, 0x283344a1ab3e55ecfd904d0b8e9f4faea338df5a4ead2fa9a42f0e103da40abc)\n            mstore(VK_GATE_SETUP_7_Y_SLOT, 0x223b37b83b9687512d322993edd70e508dd80adb10bcf7321a3cc8a44c269521)\n\n            // gate selectors commitments\n            mstore(VK_GATE_SELECTORS_0_X_SLOT, 0x1f67f0ba5f7e837bc680acb4e612ebd938ad35211aa6e05b96cad19e66b82d2d)\n            mstore(VK_GATE_SELECTORS_0_Y_SLOT, 0x2820641a84d2e8298ac2ac42bd4b912c0c37f768ecc83d3a29e7c720763d15a1)\n            mstore(VK_GATE_SELECTORS_1_X_SLOT, 0x0353257957562270292a17860ca8e8827703f828f440ee004848b1e23fdf9de2)\n            mstore(VK_GATE_SELECTORS_1_Y_SLOT, 0x305f4137fee253dff8b2bfe579038e8f25d5bd217865072af5d89fc8800ada24)\n\n            // permutation commitments\n            mstore(VK_PERMUTATION_0_X_SLOT, 0x13a600154b369ff3237706d00948e465ee1c32c7a6d3e18bccd9c4a15910f2e5)\n            mstore(VK_PERMUTATION_0_Y_SLOT, 0x138aa24fbf4cdddc75114811b3d59040394c218ecef3eb46ef9bd646f7e53776)\n            mstore(VK_PERMUTATION_1_X_SLOT, 0x277fff1f80c409357e2d251d79f6e3fd2164b755ce69cfd72de5c690289df662)\n            mstore(VK_PERMUTATION_1_Y_SLOT, 0x25235588e28c70eea3e35531c80deac25cd9b53ea3f98993f120108bc7abf670)\n            mstore(VK_PERMUTATION_2_X_SLOT, 0x0990e07a9b001048b947d0e5bd6157214c7359b771f01bf52bd771ba563a900e)\n            mstore(VK_PERMUTATION_2_Y_SLOT, 0x05e5fb090dd40914c8606d875e301167ae3047d684a02b44d9d36f1eaf43d0b4)\n            mstore(VK_PERMUTATION_3_X_SLOT, 0x1d4656690b33299db5631401a282afab3e16c78ee2c9ad9efea628171dcbc6bc)\n            mstore(VK_PERMUTATION_3_Y_SLOT, 0x0ebda2ebe582f601f813ec1e3970d13ef1500c742a85cce9b7f190f333de03b0)\n\n            // lookup tables commitments\n            mstore(VK_LOOKUP_TABLE_0_X_SLOT, 0x2c513ed74d9d57a5ec901e074032741036353a2c4513422e96e7b53b302d765b)\n            mstore(VK_LOOKUP_TABLE_0_Y_SLOT, 0x04dd964427e430f16004076d708c0cb21e225056cc1d57418cfbd3d472981468)\n            mstore(VK_LOOKUP_TABLE_1_X_SLOT, 0x1ea83e5e65c6f8068f4677e2911678cf329b28259642a32db1f14b8347828aac)\n            mstore(VK_LOOKUP_TABLE_1_Y_SLOT, 0x1d22bc884a2da4962a893ba8de13f57aaeb785ed52c5e686994839cab8f7475d)\n            mstore(VK_LOOKUP_TABLE_2_X_SLOT, 0x0b2e7212d0d9cff26d0bdf3d79b2cac029a25dfeb1cafdf49e2349d7db348d89)\n            mstore(VK_LOOKUP_TABLE_2_Y_SLOT, 0x1301f9b252419ea240eb67fda720ca0b16d92364027285f95e9b1349490fa283)\n            mstore(VK_LOOKUP_TABLE_3_X_SLOT, 0x02f7b99fdfa5b418548c2d777785820e02383cfc87e7085e280a375a358153bf)\n            mstore(VK_LOOKUP_TABLE_3_Y_SLOT, 0x09d004fe08dc4d19c382df36fad22ef676185663543703e6a4b40203e50fd8a6)\n\n            // lookup selector commitment\n            mstore(VK_LOOKUP_SELECTOR_X_SLOT, 0x2f4d347c7fb61daaadfff881e24f4b5dcfdc0d70a95bcb148168b90ef93e0007)\n            mstore(VK_LOOKUP_SELECTOR_Y_SLOT, 0x2322632465ba8e28cd0a4befd813ea85a972f4f6fa8e8603cf5d062dbcb14065)\n\n            // table type commitment\n            mstore(VK_LOOKUP_TABLE_TYPE_X_SLOT, 0x1e3c9fc98c118e4bc34f1f93d214a5d86898e980c40d8e2c180c6ada377a7467)\n            mstore(VK_LOOKUP_TABLE_TYPE_Y_SLOT, 0x2260a13535c35a15c173f5e5797d4b675b55d164a9995bfb7624971324bd84a8)\n\n            // flag for using recursive part\n            mstore(VK_RECURSIVE_FLAG_SLOT, 0)\n        }\n    }\n\n    /// @inheritdoc IVerifier\n    function verify(\n        uint256[] calldata, // _publicInputs\n        uint256[] calldata // _proof\n    ) public view virtual returns (bool) {\n        // No memory was accessed yet, so keys can be loaded into the right place and not corrupt any other memory.\n        _loadVerificationKey();\n\n        // Beginning of the big inline assembly block that makes all the verification work.\n        // Note: We use the custom memory layout, so the return value should be returned from the assembly, not\n        // Solidity code.\n        assembly {\n            /*//////////////////////////////////////////////////////////////\n                                    Utils\n            //////////////////////////////////////////////////////////////*/\n\n            /// @dev Reverts execution with a provided revert reason.\n            /// @param len The byte length of the error message string, which is expected to be no more than 32.\n            /// @param reason The 1-word revert reason string, encoded in ASCII.\n            function revertWithMessage(len, reason) {\n                // \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\n                mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                // Data offset\n                mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n                // Length of revert string\n                mstore(0x24, len)\n                // Revert reason\n                mstore(0x44, reason)\n                // Revert\n                revert(0x00, 0x64)\n            }\n\n            /// @dev Performs modular exponentiation using the formula (value ^ power) mod R_MOD.\n            function modexp(value, power) -> res {\n                mstore(0x00, 0x20)\n                mstore(0x20, 0x20)\n                mstore(0x40, 0x20)\n                mstore(0x60, value)\n                mstore(0x80, power)\n                mstore(0xa0, R_MOD)\n                if iszero(staticcall(gas(), 5, 0, 0xc0, 0x00, 0x20)) {\n                    revertWithMessage(24, \"modexp precompile failed\")\n                }\n                res := mload(0x00)\n            }\n\n            /// @dev Performs a point multiplication operation and stores the result in a given memory destination.\n            function pointMulIntoDest(point, s, dest) {\n                mstore(0x00, mload(point))\n                mstore(0x20, mload(add(point, 0x20)))\n                mstore(0x40, s)\n                if iszero(staticcall(gas(), 7, 0, 0x60, dest, 0x40)) {\n                    revertWithMessage(30, \"pointMulIntoDest: ecMul failed\")\n                }\n            }\n\n            /// @dev Performs a point addition operation and stores the result in a given memory destination.\n            function pointAddIntoDest(p1, p2, dest) {\n                mstore(0x00, mload(p1))\n                mstore(0x20, mload(add(p1, 0x20)))\n                mstore(0x40, mload(p2))\n                mstore(0x60, mload(add(p2, 0x20)))\n                if iszero(staticcall(gas(), 6, 0x00, 0x80, dest, 0x40)) {\n                    revertWithMessage(30, \"pointAddIntoDest: ecAdd failed\")\n                }\n            }\n\n            /// @dev Performs a point subtraction operation and updates the first point with the result.\n            function pointSubAssign(p1, p2) {\n                mstore(0x00, mload(p1))\n                mstore(0x20, mload(add(p1, 0x20)))\n                mstore(0x40, mload(p2))\n                mstore(0x60, sub(Q_MOD, mload(add(p2, 0x20))))\n                if iszero(staticcall(gas(), 6, 0x00, 0x80, p1, 0x40)) {\n                    revertWithMessage(28, \"pointSubAssign: ecAdd failed\")\n                }\n            }\n\n            /// @dev Performs a point addition operation and updates the first point with the result.\n            function pointAddAssign(p1, p2) {\n                mstore(0x00, mload(p1))\n                mstore(0x20, mload(add(p1, 0x20)))\n                mstore(0x40, mload(p2))\n                mstore(0x60, mload(add(p2, 0x20)))\n                if iszero(staticcall(gas(), 6, 0x00, 0x80, p1, 0x40)) {\n                    revertWithMessage(28, \"pointAddAssign: ecAdd failed\")\n                }\n            }\n\n            /// @dev Performs a point multiplication operation and then adds the result to the destination point.\n            function pointMulAndAddIntoDest(point, s, dest) {\n                mstore(0x00, mload(point))\n                mstore(0x20, mload(add(point, 0x20)))\n                mstore(0x40, s)\n                let success := staticcall(gas(), 7, 0, 0x60, 0, 0x40)\n\n                mstore(0x40, mload(dest))\n                mstore(0x60, mload(add(dest, 0x20)))\n                success := and(success, staticcall(gas(), 6, 0x00, 0x80, dest, 0x40))\n\n                if iszero(success) {\n                    revertWithMessage(22, \"pointMulAndAddIntoDest\")\n                }\n            }\n\n            /// @dev Negates an elliptic curve point by changing the sign of the y-coordinate.\n            function pointNegate(point) {\n                let pY := mload(add(point, 0x20))\n                switch pY\n                case 0 {\n                    if mload(point) {\n                        revertWithMessage(26, \"pointNegate: invalid point\")\n                    }\n                }\n                default {\n                    mstore(add(point, 0x20), sub(Q_MOD, pY))\n                }\n            }\n\n            /*//////////////////////////////////////////////////////////////\n                                    Transcript helpers\n            //////////////////////////////////////////////////////////////*/\n\n            /// @dev Updates the transcript state with a new challenge value.\n            function updateTranscript(value) {\n                mstore8(TRANSCRIPT_DST_BYTE_SLOT, 0x00)\n                mstore(TRANSCRIPT_CHALLENGE_SLOT, value)\n                let newState0 := keccak256(TRANSCRIPT_BEGIN_SLOT, 0x64)\n                mstore8(TRANSCRIPT_DST_BYTE_SLOT, 0x01)\n                let newState1 := keccak256(TRANSCRIPT_BEGIN_SLOT, 0x64)\n                mstore(TRANSCRIPT_STATE_1_SLOT, newState1)\n                mstore(TRANSCRIPT_STATE_0_SLOT, newState0)\n            }\n\n            /// @dev Retrieves a transcript challenge.\n            function getTranscriptChallenge(numberOfChallenge) -> challenge {\n                mstore8(TRANSCRIPT_DST_BYTE_SLOT, 0x02)\n                mstore(TRANSCRIPT_CHALLENGE_SLOT, shl(224, numberOfChallenge))\n                challenge := and(keccak256(TRANSCRIPT_BEGIN_SLOT, 0x48), FR_MASK)\n            }\n\n            /*//////////////////////////////////////////////////////////////\n                                    1. Load Proof\n            //////////////////////////////////////////////////////////////*/\n\n            /// @dev This function loads a zk-SNARK proof, ensures it's properly formatted, and stores it in memory.\n            /// It ensures the number of inputs and the elliptic curve point's validity.\n            /// Note: It does NOT reject inputs that exceed these module sizes, but rather wraps them within the\n            /// module bounds.\n            /// The proof consists of:\n            /// 1. Public input: (1 field element from F_r)\n            ///\n            /// 2. Polynomial commitments (elliptic curve points over F_q):\n            ///     [a], [b], [c], [d]         - state polynomials commitments\n            ///     [z_perm]                   - copy-permutation grand product commitment\n            ///     [s]                        - polynomial for lookup argument commitment\n            ///     [z_lookup]                 - lookup grand product commitment\n            ///     [t_0], [t_1], [t_2], [t_3] - quotient polynomial parts commitments\n            ///     [W], [W']                  - proof openings commitments\n            ///\n            /// 3. Polynomial evaluations at z and z*omega (field elements from F_r):\n            ///     t(z)                                  - quotient polynomial opening\n            ///     a(z), b(z), c(z), d(z), d(z*omega)    - state polynomials openings\n            ///     main_gate_selector(z)                 - main gate selector opening\n            ///     sigma_0(z), sigma_1(z), sigma_2(z)    - permutation polynomials openings\n            ///     z_perm(z*omega)                       - copy-permutation grand product opening\n            ///     z_lookup(z*omega)                     - lookup grand product opening\n            ///     lookup_selector(z)                    - lookup selector opening\n            ///     s(x*omega), t(z*omega), table_type(z) - lookup argument polynomial openings\n            ///     r(z)                                  - linearisation polynomial opening\n            ///\n            /// 4. Recursive proof (0 or 2 elliptic curve points over F_q)\n            function loadProof() {\n                // 1. Load public input\n                let offset := calldataload(0x04)\n                let publicInputLengthInWords := calldataload(add(offset, 0x04))\n                let isValid := eq(publicInputLengthInWords, 1) // We expect only one public input\n                mstore(PROOF_PUBLIC_INPUT, and(calldataload(add(offset, 0x24)), FR_MASK))\n\n                // 2. Load the proof (except for the recursive part)\n                offset := calldataload(0x24)\n                let proofLengthInWords := calldataload(add(offset, 0x04))\n\n                // Check the proof length depending on whether the recursive part is present\n                let expectedProofLength\n                switch mload(VK_RECURSIVE_FLAG_SLOT)\n                case 0 {\n                    expectedProofLength := 44\n                }\n                default {\n                    expectedProofLength := 48\n                }\n                isValid := and(eq(proofLengthInWords, expectedProofLength), isValid)\n\n                // PROOF_STATE_POLYS_0\n                {\n                    let x := mod(calldataload(add(offset, 0x024)), Q_MOD)\n                    let y := mod(calldataload(add(offset, 0x044)), Q_MOD)\n                    let xx := mulmod(x, x, Q_MOD)\n                    isValid := and(eq(mulmod(y, y, Q_MOD), addmod(mulmod(x, xx, Q_MOD), 3, Q_MOD)), isValid)\n                    mstore(PROOF_STATE_POLYS_0_X_SLOT, x)\n                    mstore(PROOF_STATE_POLYS_0_Y_SLOT, y)\n                }\n                // PROOF_STATE_POLYS_1\n                {\n                    let x := mod(calldataload(add(offset, 0x064)), Q_MOD)\n                    let y := mod(calldataload(add(offset, 0x084)), Q_MOD)\n                    let xx := mulmod(x, x, Q_MOD)\n                    isValid := and(eq(mulmod(y, y, Q_MOD), addmod(mulmod(x, xx, Q_MOD), 3, Q_MOD)), isValid)\n                    mstore(PROOF_STATE_POLYS_1_X_SLOT, x)\n                    mstore(PROOF_STATE_POLYS_1_Y_SLOT, y)\n                }\n                // PROOF_STATE_POLYS_2\n                {\n                    let x := mod(calldataload(add(offset, 0x0a4)), Q_MOD)\n                    let y := mod(calldataload(add(offset, 0x0c4)), Q_MOD)\n                    let xx := mulmod(x, x, Q_MOD)\n                    isValid := and(eq(mulmod(y, y, Q_MOD), addmod(mulmod(x, xx, Q_MOD), 3, Q_MOD)), isValid)\n                    mstore(PROOF_STATE_POLYS_2_X_SLOT, x)\n                    mstore(PROOF_STATE_POLYS_2_Y_SLOT, y)\n                }\n                // PROOF_STATE_POLYS_3\n                {\n                    let x := mod(calldataload(add(offset, 0x0e4)), Q_MOD)\n                    let y := mod(calldataload(add(offset, 0x104)), Q_MOD)\n                    let xx := mulmod(x, x, Q_MOD)\n                    isValid := and(eq(mulmod(y, y, Q_MOD), addmod(mulmod(x, xx, Q_MOD), 3, Q_MOD)), isValid)\n                    mstore(PROOF_STATE_POLYS_3_X_SLOT, x)\n                    mstore(PROOF_STATE_POLYS_3_Y_SLOT, y)\n                }\n                // PROOF_COPY_PERMUTATION_GRAND_PRODUCT\n                {\n                    let x := mod(calldataload(add(offset, 0x124)), Q_MOD)\n                    let y := mod(calldataload(add(offset, 0x144)), Q_MOD)\n                    let xx := mulmod(x, x, Q_MOD)\n                    isValid := and(eq(mulmod(y, y, Q_MOD), addmod(mulmod(x, xx, Q_MOD), 3, Q_MOD)), isValid)\n                    mstore(PROOF_COPY_PERMUTATION_GRAND_PRODUCT_X_SLOT, x)\n                    mstore(PROOF_COPY_PERMUTATION_GRAND_PRODUCT_Y_SLOT, y)\n                }\n                // PROOF_LOOKUP_S_POLY\n                {\n                    let x := mod(calldataload(add(offset, 0x164)), Q_MOD)\n                    let y := mod(calldataload(add(offset, 0x184)), Q_MOD)\n                    let xx := mulmod(x, x, Q_MOD)\n                    isValid := and(eq(mulmod(y, y, Q_MOD), addmod(mulmod(x, xx, Q_MOD), 3, Q_MOD)), isValid)\n                    mstore(PROOF_LOOKUP_S_POLY_X_SLOT, x)\n                    mstore(PROOF_LOOKUP_S_POLY_Y_SLOT, y)\n                }\n                // PROOF_LOOKUP_GRAND_PRODUCT\n                {\n                    let x := mod(calldataload(add(offset, 0x1a4)), Q_MOD)\n                    let y := mod(calldataload(add(offset, 0x1c4)), Q_MOD)\n                    let xx := mulmod(x, x, Q_MOD)\n                    isValid := and(eq(mulmod(y, y, Q_MOD), addmod(mulmod(x, xx, Q_MOD), 3, Q_MOD)), isValid)\n                    mstore(PROOF_LOOKUP_GRAND_PRODUCT_X_SLOT, x)\n                    mstore(PROOF_LOOKUP_GRAND_PRODUCT_Y_SLOT, y)\n                }\n                // PROOF_QUOTIENT_POLY_PARTS_0\n                {\n                    let x := mod(calldataload(add(offset, 0x1e4)), Q_MOD)\n                    let y := mod(calldataload(add(offset, 0x204)), Q_MOD)\n                    let xx := mulmod(x, x, Q_MOD)\n                    isValid := and(eq(mulmod(y, y, Q_MOD), addmod(mulmod(x, xx, Q_MOD), 3, Q_MOD)), isValid)\n                    mstore(PROOF_QUOTIENT_POLY_PARTS_0_X_SLOT, x)\n                    mstore(PROOF_QUOTIENT_POLY_PARTS_0_Y_SLOT, y)\n                }\n                // PROOF_QUOTIENT_POLY_PARTS_1\n                {\n                    let x := mod(calldataload(add(offset, 0x224)), Q_MOD)\n                    let y := mod(calldataload(add(offset, 0x244)), Q_MOD)\n                    let xx := mulmod(x, x, Q_MOD)\n                    isValid := and(eq(mulmod(y, y, Q_MOD), addmod(mulmod(x, xx, Q_MOD), 3, Q_MOD)), isValid)\n                    mstore(PROOF_QUOTIENT_POLY_PARTS_1_X_SLOT, x)\n                    mstore(PROOF_QUOTIENT_POLY_PARTS_1_Y_SLOT, y)\n                }\n                // PROOF_QUOTIENT_POLY_PARTS_2\n                {\n                    let x := mod(calldataload(add(offset, 0x264)), Q_MOD)\n                    let y := mod(calldataload(add(offset, 0x284)), Q_MOD)\n                    let xx := mulmod(x, x, Q_MOD)\n                    isValid := and(eq(mulmod(y, y, Q_MOD), addmod(mulmod(x, xx, Q_MOD), 3, Q_MOD)), isValid)\n                    mstore(PROOF_QUOTIENT_POLY_PARTS_2_X_SLOT, x)\n                    mstore(PROOF_QUOTIENT_POLY_PARTS_2_Y_SLOT, y)\n                }\n                // PROOF_QUOTIENT_POLY_PARTS_3\n                {\n                    let x := mod(calldataload(add(offset, 0x2a4)), Q_MOD)\n                    let y := mod(calldataload(add(offset, 0x2c4)), Q_MOD)\n                    let xx := mulmod(x, x, Q_MOD)\n                    isValid := and(eq(mulmod(y, y, Q_MOD), addmod(mulmod(x, xx, Q_MOD), 3, Q_MOD)), isValid)\n                    mstore(PROOF_QUOTIENT_POLY_PARTS_3_X_SLOT, x)\n                    mstore(PROOF_QUOTIENT_POLY_PARTS_3_Y_SLOT, y)\n                }\n\n                mstore(PROOF_STATE_POLYS_0_OPENING_AT_Z_SLOT, mod(calldataload(add(offset, 0x2e4)), R_MOD))\n                mstore(PROOF_STATE_POLYS_1_OPENING_AT_Z_SLOT, mod(calldataload(add(offset, 0x304)), R_MOD))\n                mstore(PROOF_STATE_POLYS_2_OPENING_AT_Z_SLOT, mod(calldataload(add(offset, 0x324)), R_MOD))\n                mstore(PROOF_STATE_POLYS_3_OPENING_AT_Z_SLOT, mod(calldataload(add(offset, 0x344)), R_MOD))\n\n                mstore(PROOF_STATE_POLYS_3_OPENING_AT_Z_OMEGA_SLOT, mod(calldataload(add(offset, 0x364)), R_MOD))\n                mstore(PROOF_GATE_SELECTORS_0_OPENING_AT_Z_SLOT, mod(calldataload(add(offset, 0x384)), R_MOD))\n\n                mstore(PROOF_COPY_PERMUTATION_POLYS_0_OPENING_AT_Z_SLOT, mod(calldataload(add(offset, 0x3a4)), R_MOD))\n                mstore(PROOF_COPY_PERMUTATION_POLYS_1_OPENING_AT_Z_SLOT, mod(calldataload(add(offset, 0x3c4)), R_MOD))\n                mstore(PROOF_COPY_PERMUTATION_POLYS_2_OPENING_AT_Z_SLOT, mod(calldataload(add(offset, 0x3e4)), R_MOD))\n\n                mstore(\n                    PROOF_COPY_PERMUTATION_GRAND_PRODUCT_OPENING_AT_Z_OMEGA_SLOT,\n                    mod(calldataload(add(offset, 0x404)), R_MOD)\n                )\n                mstore(PROOF_LOOKUP_S_POLY_OPENING_AT_Z_OMEGA_SLOT, mod(calldataload(add(offset, 0x424)), R_MOD))\n                mstore(PROOF_LOOKUP_GRAND_PRODUCT_OPENING_AT_Z_OMEGA_SLOT, mod(calldataload(add(offset, 0x444)), R_MOD))\n                mstore(PROOF_LOOKUP_T_POLY_OPENING_AT_Z_SLOT, mod(calldataload(add(offset, 0x464)), R_MOD))\n                mstore(PROOF_LOOKUP_T_POLY_OPENING_AT_Z_OMEGA_SLOT, mod(calldataload(add(offset, 0x484)), R_MOD))\n                mstore(PROOF_LOOKUP_SELECTOR_POLY_OPENING_AT_Z_SLOT, mod(calldataload(add(offset, 0x4a4)), R_MOD))\n                mstore(PROOF_LOOKUP_TABLE_TYPE_POLY_OPENING_AT_Z_SLOT, mod(calldataload(add(offset, 0x4c4)), R_MOD))\n                mstore(PROOF_QUOTIENT_POLY_OPENING_AT_Z_SLOT, mod(calldataload(add(offset, 0x4e4)), R_MOD))\n                mstore(PROOF_LINEARISATION_POLY_OPENING_AT_Z_SLOT, mod(calldataload(add(offset, 0x504)), R_MOD))\n\n                // PROOF_OPENING_PROOF_AT_Z\n                {\n                    let x := mod(calldataload(add(offset, 0x524)), Q_MOD)\n                    let y := mod(calldataload(add(offset, 0x544)), Q_MOD)\n                    let xx := mulmod(x, x, Q_MOD)\n                    isValid := and(eq(mulmod(y, y, Q_MOD), addmod(mulmod(x, xx, Q_MOD), 3, Q_MOD)), isValid)\n                    mstore(PROOF_OPENING_PROOF_AT_Z_X_SLOT, x)\n                    mstore(PROOF_OPENING_PROOF_AT_Z_Y_SLOT, y)\n                }\n                // PROOF_OPENING_PROOF_AT_Z_OMEGA\n                {\n                    let x := mod(calldataload(add(offset, 0x564)), Q_MOD)\n                    let y := mod(calldataload(add(offset, 0x584)), Q_MOD)\n                    let xx := mulmod(x, x, Q_MOD)\n                    isValid := and(eq(mulmod(y, y, Q_MOD), addmod(mulmod(x, xx, Q_MOD), 3, Q_MOD)), isValid)\n                    mstore(PROOF_OPENING_PROOF_AT_Z_OMEGA_X_SLOT, x)\n                    mstore(PROOF_OPENING_PROOF_AT_Z_OMEGA_Y_SLOT, y)\n                }\n\n                // 3. Load the recursive part of the proof\n                if mload(VK_RECURSIVE_FLAG_SLOT) {\n                    // recursive part should be consist of 2 points\n\n                    // PROOF_RECURSIVE_PART_P1\n                    {\n                        let x := mod(calldataload(add(offset, 0x5a4)), Q_MOD)\n                        let y := mod(calldataload(add(offset, 0x5c4)), Q_MOD)\n                        let xx := mulmod(x, x, Q_MOD)\n                        isValid := and(eq(mulmod(y, y, Q_MOD), addmod(mulmod(x, xx, Q_MOD), 3, Q_MOD)), isValid)\n                        mstore(PROOF_RECURSIVE_PART_P1_X_SLOT, x)\n                        mstore(PROOF_RECURSIVE_PART_P1_Y_SLOT, y)\n                    }\n                    // PROOF_RECURSIVE_PART_P2\n                    {\n                        let x := mod(calldataload(add(offset, 0x5e4)), Q_MOD)\n                        let y := mod(calldataload(add(offset, 0x604)), Q_MOD)\n                        let xx := mulmod(x, x, Q_MOD)\n                        isValid := and(eq(mulmod(y, y, Q_MOD), addmod(mulmod(x, xx, Q_MOD), 3, Q_MOD)), isValid)\n                        mstore(PROOF_RECURSIVE_PART_P2_X_SLOT, x)\n                        mstore(PROOF_RECURSIVE_PART_P2_Y_SLOT, y)\n                    }\n                }\n\n                // Revert if a proof is not valid\n                if iszero(isValid) {\n                    revertWithMessage(27, \"loadProof: Proof is invalid\")\n                }\n            }\n\n            /*//////////////////////////////////////////////////////////////\n                                    2. Transcript initialization\n            //////////////////////////////////////////////////////////////*/\n\n            /// @notice Recomputes all challenges\n            /// @dev The process is the following:\n            /// Commit:   PI, [a], [b], [c], [d]\n            /// Get:      eta\n            /// Commit:   [s]\n            /// Get:      beta, gamma\n            /// Commit:   [z_perm]\n            /// Get:      beta', gamma'\n            /// Commit:   [z_lookup]\n            /// Get:      alpha\n            /// Commit:   [t_0], [t_1], [t_2], [t_3]\n            /// Get:      z\n            /// Commit:   t(z), a(z), b(z), c(z), d(z), d(z*omega),\n            ///           main_gate_selector(z),\n            ///           sigma_0(z), sigma_1(z), sigma_2(z),\n            ///           z_perm(z*omega),\n            ///           t(z), lookup_selector(z), table_type(z),\n            ///           s(x*omega), z_lookup(z*omega), t(z*omega),\n            ///           r(z)\n            /// Get:      v\n            /// Commit:   [W], [W']\n            /// Get:      u\n            function initializeTranscript() {\n                // Round 1\n                updateTranscript(mload(PROOF_PUBLIC_INPUT))\n                updateTranscript(mload(PROOF_STATE_POLYS_0_X_SLOT))\n                updateTranscript(mload(PROOF_STATE_POLYS_0_Y_SLOT))\n                updateTranscript(mload(PROOF_STATE_POLYS_1_X_SLOT))\n                updateTranscript(mload(PROOF_STATE_POLYS_1_Y_SLOT))\n                updateTranscript(mload(PROOF_STATE_POLYS_2_X_SLOT))\n                updateTranscript(mload(PROOF_STATE_POLYS_2_Y_SLOT))\n                updateTranscript(mload(PROOF_STATE_POLYS_3_X_SLOT))\n                updateTranscript(mload(PROOF_STATE_POLYS_3_Y_SLOT))\n\n                mstore(STATE_ETA_SLOT, getTranscriptChallenge(0))\n\n                // Round 1.5\n                updateTranscript(mload(PROOF_LOOKUP_S_POLY_X_SLOT))\n                updateTranscript(mload(PROOF_LOOKUP_S_POLY_Y_SLOT))\n\n                mstore(STATE_BETA_SLOT, getTranscriptChallenge(1))\n                mstore(STATE_GAMMA_SLOT, getTranscriptChallenge(2))\n\n                // Round 2\n                updateTranscript(mload(PROOF_COPY_PERMUTATION_GRAND_PRODUCT_X_SLOT))\n                updateTranscript(mload(PROOF_COPY_PERMUTATION_GRAND_PRODUCT_Y_SLOT))\n\n                mstore(STATE_BETA_LOOKUP_SLOT, getTranscriptChallenge(3))\n                mstore(STATE_GAMMA_LOOKUP_SLOT, getTranscriptChallenge(4))\n\n                // Round 2.5\n                updateTranscript(mload(PROOF_LOOKUP_GRAND_PRODUCT_X_SLOT))\n                updateTranscript(mload(PROOF_LOOKUP_GRAND_PRODUCT_Y_SLOT))\n\n                mstore(STATE_ALPHA_SLOT, getTranscriptChallenge(5))\n\n                // Round 3\n                updateTranscript(mload(PROOF_QUOTIENT_POLY_PARTS_0_X_SLOT))\n                updateTranscript(mload(PROOF_QUOTIENT_POLY_PARTS_0_Y_SLOT))\n                updateTranscript(mload(PROOF_QUOTIENT_POLY_PARTS_1_X_SLOT))\n                updateTranscript(mload(PROOF_QUOTIENT_POLY_PARTS_1_Y_SLOT))\n                updateTranscript(mload(PROOF_QUOTIENT_POLY_PARTS_2_X_SLOT))\n                updateTranscript(mload(PROOF_QUOTIENT_POLY_PARTS_2_Y_SLOT))\n                updateTranscript(mload(PROOF_QUOTIENT_POLY_PARTS_3_X_SLOT))\n                updateTranscript(mload(PROOF_QUOTIENT_POLY_PARTS_3_Y_SLOT))\n\n                {\n                    let z := getTranscriptChallenge(6)\n\n                    mstore(STATE_Z_SLOT, z)\n                    mstore(STATE_Z_IN_DOMAIN_SIZE, modexp(z, DOMAIN_SIZE))\n                }\n\n                // Round 4\n                updateTranscript(mload(PROOF_QUOTIENT_POLY_OPENING_AT_Z_SLOT))\n\n                updateTranscript(mload(PROOF_STATE_POLYS_0_OPENING_AT_Z_SLOT))\n                updateTranscript(mload(PROOF_STATE_POLYS_1_OPENING_AT_Z_SLOT))\n                updateTranscript(mload(PROOF_STATE_POLYS_2_OPENING_AT_Z_SLOT))\n                updateTranscript(mload(PROOF_STATE_POLYS_3_OPENING_AT_Z_SLOT))\n\n                updateTranscript(mload(PROOF_STATE_POLYS_3_OPENING_AT_Z_OMEGA_SLOT))\n                updateTranscript(mload(PROOF_GATE_SELECTORS_0_OPENING_AT_Z_SLOT))\n\n                updateTranscript(mload(PROOF_COPY_PERMUTATION_POLYS_0_OPENING_AT_Z_SLOT))\n                updateTranscript(mload(PROOF_COPY_PERMUTATION_POLYS_1_OPENING_AT_Z_SLOT))\n                updateTranscript(mload(PROOF_COPY_PERMUTATION_POLYS_2_OPENING_AT_Z_SLOT))\n\n                updateTranscript(mload(PROOF_COPY_PERMUTATION_GRAND_PRODUCT_OPENING_AT_Z_OMEGA_SLOT))\n                updateTranscript(mload(PROOF_LOOKUP_T_POLY_OPENING_AT_Z_SLOT))\n                updateTranscript(mload(PROOF_LOOKUP_SELECTOR_POLY_OPENING_AT_Z_SLOT))\n                updateTranscript(mload(PROOF_LOOKUP_TABLE_TYPE_POLY_OPENING_AT_Z_SLOT))\n                updateTranscript(mload(PROOF_LOOKUP_S_POLY_OPENING_AT_Z_OMEGA_SLOT))\n                updateTranscript(mload(PROOF_LOOKUP_GRAND_PRODUCT_OPENING_AT_Z_OMEGA_SLOT))\n                updateTranscript(mload(PROOF_LOOKUP_T_POLY_OPENING_AT_Z_OMEGA_SLOT))\n                updateTranscript(mload(PROOF_LINEARISATION_POLY_OPENING_AT_Z_SLOT))\n\n                mstore(STATE_V_SLOT, getTranscriptChallenge(7))\n\n                // Round 5\n                updateTranscript(mload(PROOF_OPENING_PROOF_AT_Z_X_SLOT))\n                updateTranscript(mload(PROOF_OPENING_PROOF_AT_Z_Y_SLOT))\n                updateTranscript(mload(PROOF_OPENING_PROOF_AT_Z_OMEGA_X_SLOT))\n                updateTranscript(mload(PROOF_OPENING_PROOF_AT_Z_OMEGA_Y_SLOT))\n\n                mstore(STATE_U_SLOT, getTranscriptChallenge(8))\n            }\n\n            /*//////////////////////////////////////////////////////////////\n                                    3. Verifying quotient evaluation\n            //////////////////////////////////////////////////////////////*/\n\n            /// @notice Compute linearisation polynomial's constant term: r_0\n            /// @dev To save a verifier scalar multiplication, we split linearisation polynomial\n            /// into its constant and non-constant terms. The constant term is computed with the formula:\n            ///\n            /// r_0 = alpha^0 * L_0(z) * PI * q_{main selector}(z) + r(z)         -- main gate contribution\n            ///\n            ///     - alpha^4 * z_perm(z*omega)(sigma_0(z) * beta + gamma + a(z)) \\\n            ///                           (sigma_1(z) * beta + gamma + b(z))      |\n            ///                           (sigma_2(z) * beta + gamma + c(z))      | - permutation contribution\n            ///                           (sigma_3(z) + gamma)                    |\n            ///     - alpha^5 * L_0(z)                                            /\n            ///\n            ///     + alpha^6 * (s(z*omega) * beta' + gamma' (beta' + 1))         \\\n            ///               * (z - omega^{n-1}) * z_lookup(z*omega)             | - lookup contribution\n            ///     - alpha^7 * L_0(z)                                            |\n            ///     - alpha^8 * L_{n-1}(z) * (gamma' (beta' + 1))^{n-1}           /\n            ///\n            /// In the end we should check that t(z)*Z_H(z) = r(z) + r_0!\n            function verifyQuotientEvaluation() {\n                // Compute power of alpha\n                {\n                    let alpha := mload(STATE_ALPHA_SLOT)\n                    let currentAlpha := mulmod(alpha, alpha, R_MOD)\n                    mstore(STATE_POWER_OF_ALPHA_2_SLOT, currentAlpha)\n                    currentAlpha := mulmod(currentAlpha, alpha, R_MOD)\n                    mstore(STATE_POWER_OF_ALPHA_3_SLOT, currentAlpha)\n                    currentAlpha := mulmod(currentAlpha, alpha, R_MOD)\n                    mstore(STATE_POWER_OF_ALPHA_4_SLOT, currentAlpha)\n                    currentAlpha := mulmod(currentAlpha, alpha, R_MOD)\n                    mstore(STATE_POWER_OF_ALPHA_5_SLOT, currentAlpha)\n                    currentAlpha := mulmod(currentAlpha, alpha, R_MOD)\n                    mstore(STATE_POWER_OF_ALPHA_6_SLOT, currentAlpha)\n                    currentAlpha := mulmod(currentAlpha, alpha, R_MOD)\n                    mstore(STATE_POWER_OF_ALPHA_7_SLOT, currentAlpha)\n                    currentAlpha := mulmod(currentAlpha, alpha, R_MOD)\n                    mstore(STATE_POWER_OF_ALPHA_8_SLOT, currentAlpha)\n                }\n\n                // z\n                let stateZ := mload(STATE_Z_SLOT)\n                // L_0(z)\n                mstore(STATE_L_0_AT_Z_SLOT, evaluateLagrangePolyOutOfDomain(0, stateZ))\n                // L_{n-1}(z)\n                mstore(STATE_L_N_MINUS_ONE_AT_Z_SLOT, evaluateLagrangePolyOutOfDomain(sub(DOMAIN_SIZE, 1), stateZ))\n                // L_0(z) * PI\n                let stateT := mulmod(mload(STATE_L_0_AT_Z_SLOT), mload(PROOF_PUBLIC_INPUT), R_MOD)\n\n                // Compute main gate contribution\n                let result := mulmod(stateT, mload(PROOF_GATE_SELECTORS_0_OPENING_AT_Z_SLOT), R_MOD)\n\n                // Compute permutation contribution\n                result := addmod(result, permutationQuotientContribution(), R_MOD)\n\n                // Compute lookup contribution\n                result := addmod(result, lookupQuotientContribution(), R_MOD)\n\n                // Check that r(z) + r_0 = t(z) * Z_H(z)\n                result := addmod(mload(PROOF_LINEARISATION_POLY_OPENING_AT_Z_SLOT), result, R_MOD)\n\n                let vanishing := addmod(mload(STATE_Z_IN_DOMAIN_SIZE), sub(R_MOD, 1), R_MOD)\n                let lhs := mulmod(mload(PROOF_QUOTIENT_POLY_OPENING_AT_Z_SLOT), vanishing, R_MOD)\n                if iszero(eq(lhs, result)) {\n                    revertWithMessage(27, \"invalid quotient evaluation\")\n                }\n            }\n\n            /// @notice Evaluating L_{polyNum}(at) out of domain\n            /// @dev L_i is a Lagrange polynomial for our domain such that:\n            /// L_i(omega^i) = 1 and L_i(omega^j) = 0 for all j != i\n            function evaluateLagrangePolyOutOfDomain(polyNum, at) -> res {\n                let omegaPower := 1\n                if polyNum {\n                    omegaPower := modexp(OMEGA, polyNum)\n                }\n\n                res := addmod(modexp(at, DOMAIN_SIZE), sub(R_MOD, 1), R_MOD)\n\n                // Vanishing polynomial can not be zero at point `at`\n                if iszero(res) {\n                    revertWithMessage(28, \"invalid vanishing polynomial\")\n                }\n                res := mulmod(res, omegaPower, R_MOD)\n                let denominator := addmod(at, sub(R_MOD, omegaPower), R_MOD)\n                denominator := mulmod(denominator, DOMAIN_SIZE, R_MOD)\n                denominator := modexp(denominator, sub(R_MOD, 2))\n                res := mulmod(res, denominator, R_MOD)\n            }\n\n            /// @notice Compute permutation contribution to linearisation polynomial's constant term\n            function permutationQuotientContribution() -> res {\n                // res = alpha^4 * z_perm(z*omega)\n                res := mulmod(\n                    mload(STATE_POWER_OF_ALPHA_4_SLOT),\n                    mload(PROOF_COPY_PERMUTATION_GRAND_PRODUCT_OPENING_AT_Z_OMEGA_SLOT),\n                    R_MOD\n                )\n\n                {\n                    let gamma := mload(STATE_GAMMA_SLOT)\n                    let beta := mload(STATE_BETA_SLOT)\n\n                    let factorMultiplier\n                    {\n                        // res *= sigma_0(z) * beta + gamma + a(z)\n                        factorMultiplier := mulmod(mload(PROOF_COPY_PERMUTATION_POLYS_0_OPENING_AT_Z_SLOT), beta, R_MOD)\n                        factorMultiplier := addmod(factorMultiplier, gamma, R_MOD)\n                        factorMultiplier := addmod(\n                            factorMultiplier,\n                            mload(PROOF_STATE_POLYS_0_OPENING_AT_Z_SLOT),\n                            R_MOD\n                        )\n                        res := mulmod(res, factorMultiplier, R_MOD)\n                    }\n                    {\n                        // res *= sigma_1(z) * beta + gamma + b(z)\n                        factorMultiplier := mulmod(mload(PROOF_COPY_PERMUTATION_POLYS_1_OPENING_AT_Z_SLOT), beta, R_MOD)\n                        factorMultiplier := addmod(factorMultiplier, gamma, R_MOD)\n                        factorMultiplier := addmod(\n                            factorMultiplier,\n                            mload(PROOF_STATE_POLYS_1_OPENING_AT_Z_SLOT),\n                            R_MOD\n                        )\n                        res := mulmod(res, factorMultiplier, R_MOD)\n                    }\n                    {\n                        // res *= sigma_2(z) * beta + gamma + c(z)\n                        factorMultiplier := mulmod(mload(PROOF_COPY_PERMUTATION_POLYS_2_OPENING_AT_Z_SLOT), beta, R_MOD)\n                        factorMultiplier := addmod(factorMultiplier, gamma, R_MOD)\n                        factorMultiplier := addmod(\n                            factorMultiplier,\n                            mload(PROOF_STATE_POLYS_2_OPENING_AT_Z_SLOT),\n                            R_MOD\n                        )\n                        res := mulmod(res, factorMultiplier, R_MOD)\n                    }\n\n                    // res *= sigma_3(z) + gamma\n                    res := mulmod(res, addmod(mload(PROOF_STATE_POLYS_3_OPENING_AT_Z_SLOT), gamma, R_MOD), R_MOD)\n                }\n\n                // res = -res\n                res := sub(R_MOD, res)\n\n                // -= L_0(z) * alpha^5\n                let l0AtZ := mload(STATE_L_0_AT_Z_SLOT)\n                l0AtZ := mulmod(l0AtZ, mload(STATE_POWER_OF_ALPHA_5_SLOT), R_MOD)\n                res := addmod(res, sub(R_MOD, l0AtZ), R_MOD)\n            }\n\n            /// @notice Compute lookup contribution to linearisation polynomial's constant term\n            function lookupQuotientContribution() -> res {\n                let betaLookup := mload(STATE_BETA_LOOKUP_SLOT)\n                let gammaLookup := mload(STATE_GAMMA_LOOKUP_SLOT)\n                let betaPlusOne := addmod(betaLookup, 1, R_MOD)\n                let betaGamma := mulmod(betaPlusOne, gammaLookup, R_MOD)\n\n                mstore(STATE_BETA_PLUS_ONE_SLOT, betaPlusOne)\n                mstore(STATE_BETA_GAMMA_PLUS_GAMMA_SLOT, betaGamma)\n\n                // res =  alpha^6 * (s(z*omega) * beta' + gamma' (beta' + 1)) * z_lookup(z*omega)\n                res := mulmod(mload(PROOF_LOOKUP_S_POLY_OPENING_AT_Z_OMEGA_SLOT), betaLookup, R_MOD)\n                res := addmod(res, betaGamma, R_MOD)\n                res := mulmod(res, mload(PROOF_LOOKUP_GRAND_PRODUCT_OPENING_AT_Z_OMEGA_SLOT), R_MOD)\n                res := mulmod(res, mload(STATE_POWER_OF_ALPHA_6_SLOT), R_MOD)\n\n                // res *= z - omega^{n-1}\n                {\n                    let lastOmega := modexp(OMEGA, sub(DOMAIN_SIZE, 1))\n                    let zMinusLastOmega := addmod(mload(STATE_Z_SLOT), sub(R_MOD, lastOmega), R_MOD)\n                    mstore(STATE_Z_MINUS_LAST_OMEGA_SLOT, zMinusLastOmega)\n                    res := mulmod(res, zMinusLastOmega, R_MOD)\n                }\n\n                // res -= alpha^7 * L_{0}(z)\n                {\n                    let intermediateValue := mulmod(\n                        mload(STATE_L_0_AT_Z_SLOT),\n                        mload(STATE_POWER_OF_ALPHA_7_SLOT),\n                        R_MOD\n                    )\n                    res := addmod(res, sub(R_MOD, intermediateValue), R_MOD)\n                }\n\n                // res -= alpha^8 * L_{n-1}(z) * (gamma' (beta' + 1))^{n-1}\n                {\n                    let lnMinusOneAtZ := mload(STATE_L_N_MINUS_ONE_AT_Z_SLOT)\n                    let betaGammaPowered := modexp(betaGamma, sub(DOMAIN_SIZE, 1))\n                    let alphaPower8 := mload(STATE_POWER_OF_ALPHA_8_SLOT)\n\n                    let subtrahend := mulmod(mulmod(lnMinusOneAtZ, betaGammaPowered, R_MOD), alphaPower8, R_MOD)\n                    res := addmod(res, sub(R_MOD, subtrahend), R_MOD)\n                }\n            }\n\n            /// @notice Compute main gate contribution to linearisation polynomial commitment multiplied by v\n            function mainGateLinearisationContributionWithV(\n                dest,\n                stateOpening0AtZ,\n                stateOpening1AtZ,\n                stateOpening2AtZ,\n                stateOpening3AtZ\n            ) {\n                // += a(z) * [q_a]\n                pointMulIntoDest(VK_GATE_SETUP_0_X_SLOT, stateOpening0AtZ, dest)\n                // += b(z) * [q_b]\n                pointMulAndAddIntoDest(VK_GATE_SETUP_1_X_SLOT, stateOpening1AtZ, dest)\n                // += c(z) * [q_c]\n                pointMulAndAddIntoDest(VK_GATE_SETUP_2_X_SLOT, stateOpening2AtZ, dest)\n                // += d(z) * [q_d]\n                pointMulAndAddIntoDest(VK_GATE_SETUP_3_X_SLOT, stateOpening3AtZ, dest)\n                // += a(z) * b(z) * [q_ab]\n                pointMulAndAddIntoDest(VK_GATE_SETUP_4_X_SLOT, mulmod(stateOpening0AtZ, stateOpening1AtZ, R_MOD), dest)\n                // += a(z) * c(z) * [q_ac]\n                pointMulAndAddIntoDest(VK_GATE_SETUP_5_X_SLOT, mulmod(stateOpening0AtZ, stateOpening2AtZ, R_MOD), dest)\n                // += [q_const]\n                pointAddAssign(dest, VK_GATE_SETUP_6_X_SLOT)\n                // += d(z*omega) * [q_{d_next}]\n                pointMulAndAddIntoDest(VK_GATE_SETUP_7_X_SLOT, mload(PROOF_STATE_POLYS_3_OPENING_AT_Z_OMEGA_SLOT), dest)\n\n                // *= v * main_gate_selector(z)\n                let coeff := mulmod(mload(PROOF_GATE_SELECTORS_0_OPENING_AT_Z_SLOT), mload(STATE_V_SLOT), R_MOD)\n                pointMulIntoDest(dest, coeff, dest)\n            }\n\n            /// @notice Compute custom gate contribution to linearisation polynomial commitment multiplied by v\n            function addAssignRescueCustomGateLinearisationContributionWithV(\n                dest,\n                stateOpening0AtZ,\n                stateOpening1AtZ,\n                stateOpening2AtZ,\n                stateOpening3AtZ\n            ) {\n                let accumulator\n                let intermediateValue\n                //  = alpha * (a(z)^2 - b(z))\n                accumulator := mulmod(stateOpening0AtZ, stateOpening0AtZ, R_MOD)\n                accumulator := addmod(accumulator, sub(R_MOD, stateOpening1AtZ), R_MOD)\n                accumulator := mulmod(accumulator, mload(STATE_ALPHA_SLOT), R_MOD)\n                // += alpha^2 * (b(z)^2 - c(z))\n                intermediateValue := mulmod(stateOpening1AtZ, stateOpening1AtZ, R_MOD)\n                intermediateValue := addmod(intermediateValue, sub(R_MOD, stateOpening2AtZ), R_MOD)\n                intermediateValue := mulmod(intermediateValue, mload(STATE_POWER_OF_ALPHA_2_SLOT), R_MOD)\n                accumulator := addmod(accumulator, intermediateValue, R_MOD)\n                // += alpha^3 * (c(z) * a(z) - d(z))\n                intermediateValue := mulmod(stateOpening2AtZ, stateOpening0AtZ, R_MOD)\n                intermediateValue := addmod(intermediateValue, sub(R_MOD, stateOpening3AtZ), R_MOD)\n                intermediateValue := mulmod(intermediateValue, mload(STATE_POWER_OF_ALPHA_3_SLOT), R_MOD)\n                accumulator := addmod(accumulator, intermediateValue, R_MOD)\n\n                // *= v * [custom_gate_selector]\n                accumulator := mulmod(accumulator, mload(STATE_V_SLOT), R_MOD)\n                pointMulAndAddIntoDest(VK_GATE_SELECTORS_1_X_SLOT, accumulator, dest)\n            }\n\n            /// @notice Compute copy-permutation contribution to linearisation polynomial commitment multiplied by v\n            function addAssignPermutationLinearisationContributionWithV(\n                dest,\n                stateOpening0AtZ,\n                stateOpening1AtZ,\n                stateOpening2AtZ,\n                stateOpening3AtZ\n            ) {\n                // alpha^4\n                let factor := mload(STATE_POWER_OF_ALPHA_4_SLOT)\n                // Calculate the factor\n                {\n                    // *= (a(z) + beta * z + gamma)\n                    let zMulBeta := mulmod(mload(STATE_Z_SLOT), mload(STATE_BETA_SLOT), R_MOD)\n                    let gamma := mload(STATE_GAMMA_SLOT)\n\n                    let intermediateValue := addmod(addmod(zMulBeta, gamma, R_MOD), stateOpening0AtZ, R_MOD)\n                    factor := mulmod(factor, intermediateValue, R_MOD)\n\n                    // (b(z) + beta * z * k0 + gamma)\n                    intermediateValue := addmod(\n                        addmod(mulmod(zMulBeta, NON_RESIDUES_0, R_MOD), gamma, R_MOD),\n                        stateOpening1AtZ,\n                        R_MOD\n                    )\n                    factor := mulmod(factor, intermediateValue, R_MOD)\n\n                    // (c(z) + beta * z * k1 + gamma)\n                    intermediateValue := addmod(\n                        addmod(mulmod(zMulBeta, NON_RESIDUES_1, R_MOD), gamma, R_MOD),\n                        stateOpening2AtZ,\n                        R_MOD\n                    )\n                    factor := mulmod(factor, intermediateValue, R_MOD)\n\n                    // (d(z) + beta * z * k2 + gamma)\n                    intermediateValue := addmod(\n                        addmod(mulmod(zMulBeta, NON_RESIDUES_2, R_MOD), gamma, R_MOD),\n                        stateOpening3AtZ,\n                        R_MOD\n                    )\n                    factor := mulmod(factor, intermediateValue, R_MOD)\n                }\n\n                // += alpha^5 * L_0(z)\n                let l0AtZ := mload(STATE_L_0_AT_Z_SLOT)\n                factor := addmod(factor, mulmod(l0AtZ, mload(STATE_POWER_OF_ALPHA_5_SLOT), R_MOD), R_MOD)\n\n                // Here we can optimize one scalar multiplication by aggregating coefficients near [z_perm] during\n                // computing [F]\n                // We will sum them and add and make one scalar multiplication: (coeff1 + coeff2) * [z_perm]\n                factor := mulmod(factor, mload(STATE_V_SLOT), R_MOD)\n                mstore(COPY_PERMUTATION_FIRST_AGGREGATED_COMMITMENT_COEFF, factor)\n\n                // alpha^4 * beta * z_perm(z*omega)\n                factor := mulmod(mload(STATE_POWER_OF_ALPHA_4_SLOT), mload(STATE_BETA_SLOT), R_MOD)\n                factor := mulmod(factor, mload(PROOF_COPY_PERMUTATION_GRAND_PRODUCT_OPENING_AT_Z_OMEGA_SLOT), R_MOD)\n                {\n                    // *= (a(z) + beta * sigma_0(z) + gamma)\n                    let beta := mload(STATE_BETA_SLOT)\n                    let gamma := mload(STATE_GAMMA_SLOT)\n\n                    let intermediateValue := addmod(\n                        addmod(\n                            mulmod(mload(PROOF_COPY_PERMUTATION_POLYS_0_OPENING_AT_Z_SLOT), beta, R_MOD),\n                            gamma,\n                            R_MOD\n                        ),\n                        stateOpening0AtZ,\n                        R_MOD\n                    )\n                    factor := mulmod(factor, intermediateValue, R_MOD)\n\n                    // *= (b(z) + beta * sigma_1(z) + gamma)\n                    intermediateValue := addmod(\n                        addmod(\n                            mulmod(mload(PROOF_COPY_PERMUTATION_POLYS_1_OPENING_AT_Z_SLOT), beta, R_MOD),\n                            gamma,\n                            R_MOD\n                        ),\n                        stateOpening1AtZ,\n                        R_MOD\n                    )\n                    factor := mulmod(factor, intermediateValue, R_MOD)\n\n                    // *= (c(z) + beta * sigma_2(z) + gamma)\n                    intermediateValue := addmod(\n                        addmod(\n                            mulmod(mload(PROOF_COPY_PERMUTATION_POLYS_2_OPENING_AT_Z_SLOT), beta, R_MOD),\n                            gamma,\n                            R_MOD\n                        ),\n                        stateOpening2AtZ,\n                        R_MOD\n                    )\n                    factor := mulmod(factor, intermediateValue, R_MOD)\n                }\n\n                // *= v * [sigma_3]\n                factor := mulmod(factor, mload(STATE_V_SLOT), R_MOD)\n                pointMulIntoDest(VK_PERMUTATION_3_X_SLOT, factor, QUERIES_BUFFER_POINT_SLOT)\n\n                pointSubAssign(dest, QUERIES_BUFFER_POINT_SLOT)\n            }\n\n            /// @notice Compute lookup contribution to linearisation polynomial commitment multiplied by v\n            function addAssignLookupLinearisationContributionWithV(\n                dest,\n                stateOpening0AtZ,\n                stateOpening1AtZ,\n                stateOpening2AtZ\n            ) {\n                // alpha^6 * v * z_lookup(z*omega) * (z - omega^{n-1}) * [s]\n                let factor := mload(PROOF_LOOKUP_GRAND_PRODUCT_OPENING_AT_Z_OMEGA_SLOT)\n                factor := mulmod(factor, mload(STATE_POWER_OF_ALPHA_6_SLOT), R_MOD)\n                factor := mulmod(factor, mload(STATE_Z_MINUS_LAST_OMEGA_SLOT), R_MOD)\n                factor := mulmod(factor, mload(STATE_V_SLOT), R_MOD)\n\n                // Here we can optimize one scalar multiplication by aggregating coefficients near [s] during\n                // computing [F]\n                // We will sum them and add and make one scalar multiplication: (coeff1 + coeff2) * [s]\n                mstore(LOOKUP_S_FIRST_AGGREGATED_COMMITMENT_COEFF, factor)\n\n                // gamma(1 + beta) + t(x) + beta * t(x*omega)\n                factor := mload(PROOF_LOOKUP_T_POLY_OPENING_AT_Z_OMEGA_SLOT)\n                factor := mulmod(factor, mload(STATE_BETA_LOOKUP_SLOT), R_MOD)\n                factor := addmod(factor, mload(PROOF_LOOKUP_T_POLY_OPENING_AT_Z_SLOT), R_MOD)\n                factor := addmod(factor, mload(STATE_BETA_GAMMA_PLUS_GAMMA_SLOT), R_MOD)\n\n                // *= (gamma + f(z))\n                // We should use fact that f(x) =\n                // lookup_selector(x) * (a(x) + eta * b(x) + eta^2 * c(x) + eta^3 * table_type(x))\n                // to restore f(z)\n                let fReconstructed\n                {\n                    fReconstructed := stateOpening0AtZ\n                    let eta := mload(STATE_ETA_SLOT)\n                    let currentEta := eta\n\n                    fReconstructed := addmod(fReconstructed, mulmod(currentEta, stateOpening1AtZ, R_MOD), R_MOD)\n                    currentEta := mulmod(currentEta, eta, R_MOD)\n                    fReconstructed := addmod(fReconstructed, mulmod(currentEta, stateOpening2AtZ, R_MOD), R_MOD)\n                    currentEta := mulmod(currentEta, eta, R_MOD)\n\n                    // add type of table\n                    fReconstructed := addmod(\n                        fReconstructed,\n                        mulmod(mload(PROOF_LOOKUP_TABLE_TYPE_POLY_OPENING_AT_Z_SLOT), currentEta, R_MOD),\n                        R_MOD\n                    )\n                    fReconstructed := mulmod(fReconstructed, mload(PROOF_LOOKUP_SELECTOR_POLY_OPENING_AT_Z_SLOT), R_MOD)\n                    fReconstructed := addmod(fReconstructed, mload(STATE_GAMMA_LOOKUP_SLOT), R_MOD)\n                }\n                // *= -alpha^6 * (beta + 1) * (z - omega^{n-1})\n                factor := mulmod(factor, fReconstructed, R_MOD)\n                factor := mulmod(factor, mload(STATE_BETA_PLUS_ONE_SLOT), R_MOD)\n                factor := sub(R_MOD, factor)\n                factor := mulmod(factor, mload(STATE_POWER_OF_ALPHA_6_SLOT), R_MOD)\n\n                factor := mulmod(factor, mload(STATE_Z_MINUS_LAST_OMEGA_SLOT), R_MOD)\n\n                // += alpha^7 * L_0(z)\n                factor := addmod(\n                    factor,\n                    mulmod(mload(STATE_L_0_AT_Z_SLOT), mload(STATE_POWER_OF_ALPHA_7_SLOT), R_MOD),\n                    R_MOD\n                )\n\n                // += alpha^8 * L_{n-1}(z)\n                factor := addmod(\n                    factor,\n                    mulmod(mload(STATE_L_N_MINUS_ONE_AT_Z_SLOT), mload(STATE_POWER_OF_ALPHA_8_SLOT), R_MOD),\n                    R_MOD\n                )\n\n                // Here we can optimize one scalar multiplication by aggregating coefficients near [z_lookup] during\n                // computing [F]\n                // We will sum them and add and make one scalar multiplication: (coeff1 + coeff2) * [z_lookup]\n                factor := mulmod(factor, mload(STATE_V_SLOT), R_MOD)\n                mstore(LOOKUP_GRAND_PRODUCT_FIRST_AGGREGATED_COMMITMENT_COEFF, factor)\n            }\n\n            /*//////////////////////////////////////////////////////////////\n                                    4. Prepare queries\n            //////////////////////////////////////////////////////////////*/\n\n            /// @dev Here we compute the first and second parts of batched polynomial commitment\n            /// We use the formula:\n            ///     [D0] = [t_0] + z^n * [t_1] + z^{2n} * [t_2] + z^{3n} * [t_3]\n            /// and\n            ///     [D1] = main_gate_selector(z) * (                                        \\\n            ///                a(z) * [q_a] + b(z) * [q_b] + c(z) * [q_c] + d(z) * [q_d] +  | - main gate contribution\n            ///                a(z) * b(z) * [q_ab] + a(z) * c(z) * [q_ac] +                |\n            ///                [q_const] + d(z*omega) * [q_{d_next}])                       /\n            ///\n            ///            + alpha * [custom_gate_selector] * (                             \\\n            ///                (a(z)^2 - b(z))              +                               | - custom gate contribution\n            ///                (b(z)^2 - c(z))    * alpha   +                               |\n            ///                (a(z)*c(z) - d(z)) * alpha^2 )                               /\n            ///\n            ///            + alpha^4 * [z_perm] *                                           \\\n            ///                (a(z) + beta * z      + gamma) *                             |\n            ///                (b(z) + beta * z * k0 + gamma) *                             |\n            ///                (c(z) + beta * z * k1 + gamma) *                             |\n            ///                (d(z) + beta * z * k2 + gamma)                               | - permutation contribution\n            ///            - alpha^4 * z_perm(z*omega) * beta * [sigma_3] *                 |\n            ///                (a(z) + beta * sigma_0(z) + gamma) *                         |\n            ///                (b(z) + beta * sigma_1(z) + gamma) *                         |\n            ///                (c(z) + beta * sigma_2(z) + gamma) *                         |\n            ///            + alpha^5 * L_0(z) * [z_perm]                                    /\n            ///\n            ///            - alpha^6 * (1 + beta') * (gamma' + f(z)) * (z - omega^{n-1}) *  \\\n            ///                (gamma'(1 + beta') + t(z) + beta' * t(z*omega)) * [z_lookup] |\n            ///            + alpha^6 * z_lookup(z*omega) * (z - omega^{n-1}) * [s]          | - lookup contribution\n            ///            + alpha^7 * L_0(z) * [z_lookup]                                  |\n            ///            + alpha^8 * L_{n-1}(z) * [z_lookup]                              /\n            function prepareQueries() {\n                // Calculate [D0]\n                {\n                    let zInDomainSize := mload(STATE_Z_IN_DOMAIN_SIZE)\n                    let currentZ := zInDomainSize\n\n                    mstore(QUERIES_AT_Z_0_X_SLOT, mload(PROOF_QUOTIENT_POLY_PARTS_0_X_SLOT))\n                    mstore(QUERIES_AT_Z_0_Y_SLOT, mload(PROOF_QUOTIENT_POLY_PARTS_0_Y_SLOT))\n\n                    pointMulAndAddIntoDest(PROOF_QUOTIENT_POLY_PARTS_1_X_SLOT, currentZ, QUERIES_AT_Z_0_X_SLOT)\n                    currentZ := mulmod(currentZ, zInDomainSize, R_MOD)\n\n                    pointMulAndAddIntoDest(PROOF_QUOTIENT_POLY_PARTS_2_X_SLOT, currentZ, QUERIES_AT_Z_0_X_SLOT)\n                    currentZ := mulmod(currentZ, zInDomainSize, R_MOD)\n\n                    pointMulAndAddIntoDest(PROOF_QUOTIENT_POLY_PARTS_3_X_SLOT, currentZ, QUERIES_AT_Z_0_X_SLOT)\n                }\n\n                // Calculate v * [D1]\n                // We are going to multiply all the points in the sum by v to save\n                // one scalar multiplication during [F] computation\n                {\n                    let stateOpening0AtZ := mload(PROOF_STATE_POLYS_0_OPENING_AT_Z_SLOT)\n                    let stateOpening1AtZ := mload(PROOF_STATE_POLYS_1_OPENING_AT_Z_SLOT)\n                    let stateOpening2AtZ := mload(PROOF_STATE_POLYS_2_OPENING_AT_Z_SLOT)\n                    let stateOpening3AtZ := mload(PROOF_STATE_POLYS_3_OPENING_AT_Z_SLOT)\n\n                    mainGateLinearisationContributionWithV(\n                        QUERIES_AT_Z_1_X_SLOT,\n                        stateOpening0AtZ,\n                        stateOpening1AtZ,\n                        stateOpening2AtZ,\n                        stateOpening3AtZ\n                    )\n\n                    addAssignRescueCustomGateLinearisationContributionWithV(\n                        QUERIES_AT_Z_1_X_SLOT,\n                        stateOpening0AtZ,\n                        stateOpening1AtZ,\n                        stateOpening2AtZ,\n                        stateOpening3AtZ\n                    )\n\n                    addAssignPermutationLinearisationContributionWithV(\n                        QUERIES_AT_Z_1_X_SLOT,\n                        stateOpening0AtZ,\n                        stateOpening1AtZ,\n                        stateOpening2AtZ,\n                        stateOpening3AtZ\n                    )\n\n                    addAssignLookupLinearisationContributionWithV(\n                        QUERIES_AT_Z_1_X_SLOT,\n                        stateOpening0AtZ,\n                        stateOpening1AtZ,\n                        stateOpening2AtZ\n                    )\n                }\n\n                // Also we should restore [t] for future computations\n                // [t] = [col_0] + eta*[col_1] + eta^2*[col_2] + eta^3*[col_3]\n                {\n                    mstore(QUERIES_T_POLY_AGGREGATED_X_SLOT, mload(VK_LOOKUP_TABLE_0_X_SLOT))\n                    mstore(QUERIES_T_POLY_AGGREGATED_Y_SLOT, mload(VK_LOOKUP_TABLE_0_Y_SLOT))\n\n                    let eta := mload(STATE_ETA_SLOT)\n                    let currentEta := eta\n\n                    pointMulAndAddIntoDest(VK_LOOKUP_TABLE_1_X_SLOT, currentEta, QUERIES_T_POLY_AGGREGATED_X_SLOT)\n                    currentEta := mulmod(currentEta, eta, R_MOD)\n\n                    pointMulAndAddIntoDest(VK_LOOKUP_TABLE_2_X_SLOT, currentEta, QUERIES_T_POLY_AGGREGATED_X_SLOT)\n                    currentEta := mulmod(currentEta, eta, R_MOD)\n\n                    pointMulAndAddIntoDest(VK_LOOKUP_TABLE_3_X_SLOT, currentEta, QUERIES_T_POLY_AGGREGATED_X_SLOT)\n                }\n            }\n\n            /*//////////////////////////////////////////////////////////////\n                                    5. Prepare aggregated commitment\n            //////////////////////////////////////////////////////////////*/\n\n            /// @dev Here we compute aggregated commitment for the final pairing\n            /// We use the formula:\n            /// [E] = ( t(z) + v * r(z)\n            ///       + v^2*a(z) + v^3*b(z) + v^4*c(z) + v^5*d(z)\n            ///       + v^6*main_gate_selector(z)\n            ///       + v^7*sigma_0(z) + v^8*sigma_1(z) + v^9*sigma_2(z)\n            ///       + v^10*t(z) + v^11*lookup_selector(z) + v^12*table_type(z)\n            ///       + u * (v^13*z_perm(z*omega) + v^14*d(z*omega)\n            ///           + v^15*s(z*omega) + v^16*z_lookup(z*omega) + v^17*t(z*omega)\n            ///       )\n            ///  ) * [1]\n            /// and\n            /// [F] = [D0] + v * [D1]\n            ///       + v^2*[a] + v^3*[b] + v^4*[c] + v^5*[d]\n            ///       + v^6*[main_gate_selector]\n            ///       + v^7*[sigma_0] + v^8*[sigma_1] + v^9*[sigma_2]\n            ///       + v^10*[t] + v^11*[lookup_selector] + v^12*[table_type]\n            ///       + u * ( v^13*[z_perm] + v^14*[d]\n            ///           + v^15*[s] + v^16*[z_lookup] + v^17*[t]\n            ///       )\n            function prepareAggregatedCommitment() {\n                // Here we compute parts of [E] and [F] without u multiplier\n                let aggregationChallenge := 1\n                let firstDCoeff\n                let firstTCoeff\n\n                mstore(AGGREGATED_AT_Z_X_SLOT, mload(QUERIES_AT_Z_0_X_SLOT))\n                mstore(AGGREGATED_AT_Z_Y_SLOT, mload(QUERIES_AT_Z_0_Y_SLOT))\n                let aggregatedOpeningAtZ := mload(PROOF_QUOTIENT_POLY_OPENING_AT_Z_SLOT)\n                {\n                    function updateAggregationChallenge(\n                        queriesCommitmentPoint,\n                        valueAtZ,\n                        curAggregationChallenge,\n                        curAggregatedOpeningAtZ\n                    ) -> newAggregationChallenge, newAggregatedOpeningAtZ {\n                        newAggregationChallenge := mulmod(curAggregationChallenge, mload(STATE_V_SLOT), R_MOD)\n                        pointMulAndAddIntoDest(queriesCommitmentPoint, newAggregationChallenge, AGGREGATED_AT_Z_X_SLOT)\n                        newAggregatedOpeningAtZ := addmod(\n                            curAggregatedOpeningAtZ,\n                            mulmod(newAggregationChallenge, mload(valueAtZ), R_MOD),\n                            R_MOD\n                        )\n                    }\n\n                    // We don't need to multiply by v, because we have already computed v * [D1]\n                    pointAddIntoDest(AGGREGATED_AT_Z_X_SLOT, QUERIES_AT_Z_1_X_SLOT, AGGREGATED_AT_Z_X_SLOT)\n                    aggregationChallenge := mulmod(aggregationChallenge, mload(STATE_V_SLOT), R_MOD)\n                    aggregatedOpeningAtZ := addmod(\n                        aggregatedOpeningAtZ,\n                        mulmod(aggregationChallenge, mload(PROOF_LINEARISATION_POLY_OPENING_AT_Z_SLOT), R_MOD),\n                        R_MOD\n                    )\n\n                    aggregationChallenge, aggregatedOpeningAtZ := updateAggregationChallenge(\n                        PROOF_STATE_POLYS_0_X_SLOT,\n                        PROOF_STATE_POLYS_0_OPENING_AT_Z_SLOT,\n                        aggregationChallenge,\n                        aggregatedOpeningAtZ\n                    )\n                    aggregationChallenge, aggregatedOpeningAtZ := updateAggregationChallenge(\n                        PROOF_STATE_POLYS_1_X_SLOT,\n                        PROOF_STATE_POLYS_1_OPENING_AT_Z_SLOT,\n                        aggregationChallenge,\n                        aggregatedOpeningAtZ\n                    )\n                    aggregationChallenge, aggregatedOpeningAtZ := updateAggregationChallenge(\n                        PROOF_STATE_POLYS_2_X_SLOT,\n                        PROOF_STATE_POLYS_2_OPENING_AT_Z_SLOT,\n                        aggregationChallenge,\n                        aggregatedOpeningAtZ\n                    )\n\n                    // Here we can optimize one scalar multiplication by aggregating coefficients near [d]\n                    // We will sum them and add and make one scalar multiplication: (coeff1 + coeff2) * [d]\n                    aggregationChallenge := mulmod(aggregationChallenge, mload(STATE_V_SLOT), R_MOD)\n                    firstDCoeff := aggregationChallenge\n                    aggregatedOpeningAtZ := addmod(\n                        aggregatedOpeningAtZ,\n                        mulmod(aggregationChallenge, mload(PROOF_STATE_POLYS_3_OPENING_AT_Z_SLOT), R_MOD),\n                        R_MOD\n                    )\n\n                    aggregationChallenge, aggregatedOpeningAtZ := updateAggregationChallenge(\n                        VK_GATE_SELECTORS_0_X_SLOT,\n                        PROOF_GATE_SELECTORS_0_OPENING_AT_Z_SLOT,\n                        aggregationChallenge,\n                        aggregatedOpeningAtZ\n                    )\n                    aggregationChallenge, aggregatedOpeningAtZ := updateAggregationChallenge(\n                        VK_PERMUTATION_0_X_SLOT,\n                        PROOF_COPY_PERMUTATION_POLYS_0_OPENING_AT_Z_SLOT,\n                        aggregationChallenge,\n                        aggregatedOpeningAtZ\n                    )\n                    aggregationChallenge, aggregatedOpeningAtZ := updateAggregationChallenge(\n                        VK_PERMUTATION_1_X_SLOT,\n                        PROOF_COPY_PERMUTATION_POLYS_1_OPENING_AT_Z_SLOT,\n                        aggregationChallenge,\n                        aggregatedOpeningAtZ\n                    )\n                    aggregationChallenge, aggregatedOpeningAtZ := updateAggregationChallenge(\n                        VK_PERMUTATION_2_X_SLOT,\n                        PROOF_COPY_PERMUTATION_POLYS_2_OPENING_AT_Z_SLOT,\n                        aggregationChallenge,\n                        aggregatedOpeningAtZ\n                    )\n\n                    // Here we can optimize one scalar multiplication by aggregating coefficients near [t]\n                    // We will sum them and add and make one scalar multiplication: (coeff1 + coeff2) * [t]\n                    aggregationChallenge := mulmod(aggregationChallenge, mload(STATE_V_SLOT), R_MOD)\n                    firstTCoeff := aggregationChallenge\n                    aggregatedOpeningAtZ := addmod(\n                        aggregatedOpeningAtZ,\n                        mulmod(aggregationChallenge, mload(PROOF_LOOKUP_T_POLY_OPENING_AT_Z_SLOT), R_MOD),\n                        R_MOD\n                    )\n\n                    aggregationChallenge, aggregatedOpeningAtZ := updateAggregationChallenge(\n                        VK_LOOKUP_SELECTOR_X_SLOT,\n                        PROOF_LOOKUP_SELECTOR_POLY_OPENING_AT_Z_SLOT,\n                        aggregationChallenge,\n                        aggregatedOpeningAtZ\n                    )\n                    aggregationChallenge, aggregatedOpeningAtZ := updateAggregationChallenge(\n                        VK_LOOKUP_TABLE_TYPE_X_SLOT,\n                        PROOF_LOOKUP_TABLE_TYPE_POLY_OPENING_AT_Z_SLOT,\n                        aggregationChallenge,\n                        aggregatedOpeningAtZ\n                    )\n                }\n                mstore(AGGREGATED_OPENING_AT_Z_SLOT, aggregatedOpeningAtZ)\n\n                // Here we compute parts of [E] and [F] with u multiplier\n                aggregationChallenge := mulmod(aggregationChallenge, mload(STATE_V_SLOT), R_MOD)\n\n                let copyPermutationCoeff := addmod(\n                    mload(COPY_PERMUTATION_FIRST_AGGREGATED_COMMITMENT_COEFF),\n                    mulmod(aggregationChallenge, mload(STATE_U_SLOT), R_MOD),\n                    R_MOD\n                )\n\n                pointMulIntoDest(\n                    PROOF_COPY_PERMUTATION_GRAND_PRODUCT_X_SLOT,\n                    copyPermutationCoeff,\n                    AGGREGATED_AT_Z_OMEGA_X_SLOT\n                )\n                let aggregatedOpeningAtZOmega := mulmod(\n                    mload(PROOF_COPY_PERMUTATION_GRAND_PRODUCT_OPENING_AT_Z_OMEGA_SLOT),\n                    aggregationChallenge,\n                    R_MOD\n                )\n\n                {\n                    function updateAggregationChallenge(\n                        queriesCommitmentPoint,\n                        valueAtZ_Omega,\n                        previousCoeff,\n                        curAggregationChallenge,\n                        curAggregatedOpeningAtZ_Omega\n                    ) -> newAggregationChallenge, newAggregatedOpeningAtZ_Omega {\n                        newAggregationChallenge := mulmod(curAggregationChallenge, mload(STATE_V_SLOT), R_MOD)\n                        let finalCoeff := addmod(\n                            previousCoeff,\n                            mulmod(newAggregationChallenge, mload(STATE_U_SLOT), R_MOD),\n                            R_MOD\n                        )\n                        pointMulAndAddIntoDest(queriesCommitmentPoint, finalCoeff, AGGREGATED_AT_Z_OMEGA_X_SLOT)\n                        newAggregatedOpeningAtZ_Omega := addmod(\n                            curAggregatedOpeningAtZ_Omega,\n                            mulmod(newAggregationChallenge, mload(valueAtZ_Omega), R_MOD),\n                            R_MOD\n                        )\n                    }\n\n                    aggregationChallenge, aggregatedOpeningAtZOmega := updateAggregationChallenge(\n                        PROOF_STATE_POLYS_3_X_SLOT,\n                        PROOF_STATE_POLYS_3_OPENING_AT_Z_OMEGA_SLOT,\n                        firstDCoeff,\n                        aggregationChallenge,\n                        aggregatedOpeningAtZOmega\n                    )\n                    aggregationChallenge, aggregatedOpeningAtZOmega := updateAggregationChallenge(\n                        PROOF_LOOKUP_S_POLY_X_SLOT,\n                        PROOF_LOOKUP_S_POLY_OPENING_AT_Z_OMEGA_SLOT,\n                        mload(LOOKUP_S_FIRST_AGGREGATED_COMMITMENT_COEFF),\n                        aggregationChallenge,\n                        aggregatedOpeningAtZOmega\n                    )\n                    aggregationChallenge, aggregatedOpeningAtZOmega := updateAggregationChallenge(\n                        PROOF_LOOKUP_GRAND_PRODUCT_X_SLOT,\n                        PROOF_LOOKUP_GRAND_PRODUCT_OPENING_AT_Z_OMEGA_SLOT,\n                        mload(LOOKUP_GRAND_PRODUCT_FIRST_AGGREGATED_COMMITMENT_COEFF),\n                        aggregationChallenge,\n                        aggregatedOpeningAtZOmega\n                    )\n                    aggregationChallenge, aggregatedOpeningAtZOmega := updateAggregationChallenge(\n                        QUERIES_T_POLY_AGGREGATED_X_SLOT,\n                        PROOF_LOOKUP_T_POLY_OPENING_AT_Z_OMEGA_SLOT,\n                        firstTCoeff,\n                        aggregationChallenge,\n                        aggregatedOpeningAtZOmega\n                    )\n                }\n                mstore(AGGREGATED_OPENING_AT_Z_OMEGA_SLOT, aggregatedOpeningAtZOmega)\n\n                // Now we can merge both parts and get [E] and [F]\n                let u := mload(STATE_U_SLOT)\n\n                // [F]\n                pointAddIntoDest(\n                    AGGREGATED_AT_Z_X_SLOT,\n                    AGGREGATED_AT_Z_OMEGA_X_SLOT,\n                    PAIRING_PAIR_WITH_GENERATOR_X_SLOT\n                )\n\n                // [E] = (aggregatedOpeningAtZ + u * aggregatedOpeningAtZOmega) * [1]\n                let aggregatedValue := addmod(\n                    mulmod(mload(AGGREGATED_OPENING_AT_Z_OMEGA_SLOT), u, R_MOD),\n                    mload(AGGREGATED_OPENING_AT_Z_SLOT),\n                    R_MOD\n                )\n\n                mstore(PAIRING_BUFFER_POINT_X_SLOT, 1)\n                mstore(PAIRING_BUFFER_POINT_Y_SLOT, 2)\n                pointMulIntoDest(PAIRING_BUFFER_POINT_X_SLOT, aggregatedValue, PAIRING_BUFFER_POINT_X_SLOT)\n            }\n\n            /*//////////////////////////////////////////////////////////////\n                                    5. Pairing\n            //////////////////////////////////////////////////////////////*/\n\n            /// @notice Checks the final pairing\n            /// @dev We should check the equation:\n            /// e([W] + u * [W'], [x]_2) = e(z * [W] + u * z * omega * [W'] + [F] - [E], [1]_2),\n            /// where [F] and [E] were computed previously\n            ///\n            /// Also we need to check that e([P1], [x]_2) = e([P2], [1]_2)\n            /// if we have the recursive part of the proof\n            /// where [P1] and [P2] are parts of the recursive proof\n            ///\n            /// We can aggregate both pairings into one for gas optimization:\n            /// e([W] + u * [W'] + u^2 * [P1], [x]_2) =\n            /// e(z * [W] + u * z * omega * [W'] + [F] - [E] + u^2 * [P2], [1]_2)\n            ///\n            /// u is a valid challenge for such aggregation,\n            /// because [P1] and [P2] are used in PI\n            function finalPairing() {\n                let u := mload(STATE_U_SLOT)\n                let z := mload(STATE_Z_SLOT)\n                let zOmega := mulmod(mload(STATE_Z_SLOT), OMEGA, R_MOD)\n\n                // [F] - [E]\n                pointSubAssign(PAIRING_PAIR_WITH_GENERATOR_X_SLOT, PAIRING_BUFFER_POINT_X_SLOT)\n\n                // +z * [W] + u * z * omega * [W']\n                pointMulAndAddIntoDest(PROOF_OPENING_PROOF_AT_Z_X_SLOT, z, PAIRING_PAIR_WITH_GENERATOR_X_SLOT)\n                pointMulAndAddIntoDest(\n                    PROOF_OPENING_PROOF_AT_Z_OMEGA_X_SLOT,\n                    mulmod(zOmega, u, R_MOD),\n                    PAIRING_PAIR_WITH_GENERATOR_X_SLOT\n                )\n\n                // [W] + u * [W']\n                mstore(PAIRING_PAIR_WITH_X_X_SLOT, mload(PROOF_OPENING_PROOF_AT_Z_X_SLOT))\n                mstore(PAIRING_PAIR_WITH_X_Y_SLOT, mload(PROOF_OPENING_PROOF_AT_Z_Y_SLOT))\n                pointMulAndAddIntoDest(PROOF_OPENING_PROOF_AT_Z_OMEGA_X_SLOT, u, PAIRING_PAIR_WITH_X_X_SLOT)\n                pointNegate(PAIRING_PAIR_WITH_X_X_SLOT)\n\n                // Add recursive proof part if needed\n                if mload(VK_RECURSIVE_FLAG_SLOT) {\n                    let uu := mulmod(u, u, R_MOD)\n                    pointMulAndAddIntoDest(PROOF_RECURSIVE_PART_P1_X_SLOT, uu, PAIRING_PAIR_WITH_GENERATOR_X_SLOT)\n                    pointMulAndAddIntoDest(PROOF_RECURSIVE_PART_P2_X_SLOT, uu, PAIRING_PAIR_WITH_X_X_SLOT)\n                }\n\n                // Calculate pairing\n                {\n                    mstore(0x000, mload(PAIRING_PAIR_WITH_GENERATOR_X_SLOT))\n                    mstore(0x020, mload(PAIRING_PAIR_WITH_GENERATOR_Y_SLOT))\n\n                    mstore(0x040, G2_ELEMENTS_0_X1)\n                    mstore(0x060, G2_ELEMENTS_0_X2)\n                    mstore(0x080, G2_ELEMENTS_0_Y1)\n                    mstore(0x0a0, G2_ELEMENTS_0_Y2)\n\n                    mstore(0x0c0, mload(PAIRING_PAIR_WITH_X_X_SLOT))\n                    mstore(0x0e0, mload(PAIRING_PAIR_WITH_X_Y_SLOT))\n\n                    mstore(0x100, G2_ELEMENTS_1_X1)\n                    mstore(0x120, G2_ELEMENTS_1_X2)\n                    mstore(0x140, G2_ELEMENTS_1_Y1)\n                    mstore(0x160, G2_ELEMENTS_1_Y2)\n\n                    let success := staticcall(gas(), 8, 0, 0x180, 0x00, 0x20)\n                    if iszero(success) {\n                        revertWithMessage(32, \"finalPairing: precompile failure\")\n                    }\n                    if iszero(mload(0)) {\n                        revertWithMessage(29, \"finalPairing: pairing failure\")\n                    }\n                }\n            }\n\n            /*//////////////////////////////////////////////////////////////\n                                    Verification\n            //////////////////////////////////////////////////////////////*/\n\n            // Step 1: Load the proof and check the correctness of its parts\n            loadProof()\n\n            // Step 2: Recompute all the challenges with the transcript\n            initializeTranscript()\n\n            // Step 3: Check the quotient equality\n            verifyQuotientEvaluation()\n\n            // Step 4: Compute queries [D0] and v * [D1]\n            prepareQueries()\n\n            // Step 5: Compute [E] and [F]\n            prepareAggregatedCommitment()\n\n            // Step 6: Check the final pairing with aggregated recursive proof\n            finalPairing()\n\n            mstore(0, true)\n            return(0, 32)\n        }\n    }\n}\n"
      },
      "contracts/state-transition/chain-deps/DiamondInit.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Diamond} from \"../libraries/Diamond.sol\";\nimport {ZKChainBase} from \"./facets/ZKChainBase.sol\";\nimport {L2_TO_L1_LOG_SERIALIZE_SIZE, MAX_GAS_PER_TRANSACTION} from \"../../common/Config.sol\";\nimport {InitializeData, IDiamondInit} from \"../chain-interfaces/IDiamondInit.sol\";\nimport {PriorityQueue} from \"../libraries/PriorityQueue.sol\";\nimport {PriorityTree} from \"../libraries/PriorityTree.sol\";\nimport {ZeroAddress, EmptyAssetId, TooMuchGas} from \"../../common/L1ContractErrors.sol\";\n\n/// @author Matter Labs\n/// @dev The contract is used only once to initialize the diamond proxy.\n/// @dev The deployment process takes care of this contract's initialization.\ncontract DiamondInit is ZKChainBase, IDiamondInit {\n    using PriorityQueue for PriorityQueue.Queue;\n    using PriorityTree for PriorityTree.Tree;\n\n    /// @dev Initialize the implementation to prevent any possibility of a Parity hack.\n    constructor() reentrancyGuardInitializer {}\n\n    /// @notice ZK chain diamond contract initialization\n    /// @return Magic 32 bytes, which indicates that the contract logic is expected to be used as a diamond proxy\n    /// initializer\n    function initialize(InitializeData calldata _initializeData) external reentrancyGuardInitializer returns (bytes32) {\n        if (address(_initializeData.verifier) == address(0)) {\n            revert ZeroAddress();\n        }\n        if (_initializeData.admin == address(0)) {\n            revert ZeroAddress();\n        }\n        if (_initializeData.validatorTimelock == address(0)) {\n            revert ZeroAddress();\n        }\n        if (_initializeData.priorityTxMaxGasLimit > MAX_GAS_PER_TRANSACTION) {\n            revert TooMuchGas();\n        }\n        if (_initializeData.bridgehub == address(0)) {\n            revert ZeroAddress();\n        }\n        if (_initializeData.chainTypeManager == address(0)) {\n            revert ZeroAddress();\n        }\n        if (_initializeData.baseTokenAssetId == bytes32(0)) {\n            revert EmptyAssetId();\n        }\n        if (_initializeData.blobVersionedHashRetriever == address(0)) {\n            revert ZeroAddress();\n        }\n\n        s.chainId = _initializeData.chainId;\n        s.bridgehub = _initializeData.bridgehub;\n        s.chainTypeManager = _initializeData.chainTypeManager;\n        s.baseTokenAssetId = _initializeData.baseTokenAssetId;\n        s.protocolVersion = _initializeData.protocolVersion;\n\n        s.verifier = _initializeData.verifier;\n        s.admin = _initializeData.admin;\n        s.validators[_initializeData.validatorTimelock] = true;\n\n        s.storedBatchHashes[0] = _initializeData.storedBatchZero;\n        s.__DEPRECATED_verifierParams = _initializeData.verifierParams;\n        s.l2BootloaderBytecodeHash = _initializeData.l2BootloaderBytecodeHash;\n        s.l2DefaultAccountBytecodeHash = _initializeData.l2DefaultAccountBytecodeHash;\n        s.priorityTxMaxGasLimit = _initializeData.priorityTxMaxGasLimit;\n        s.feeParams = _initializeData.feeParams;\n        s.blobVersionedHashRetriever = _initializeData.blobVersionedHashRetriever;\n        s.priorityTree.setup(s.priorityQueue.getTotalPriorityTxs());\n\n        // While this does not provide a protection in the production, it is needed for local testing\n        // Length of the L2Log encoding should not be equal to the length of other L2Logs' tree nodes preimages\n        assert(L2_TO_L1_LOG_SERIALIZE_SIZE != 2 * 32);\n\n        return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE;\n    }\n}\n"
      },
      "contracts/state-transition/chain-deps/DiamondProxy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\n// Note, that while we do try to make use of custom errors whenever possible,\n// we do not change it for `DiamondProxy`, since it is a contract that can not be\n// upgraded or changed, so we keep its code always consistent with the production version.\n// solhint-disable gas-custom-errors\n\nimport {Diamond} from \"../libraries/Diamond.sol\";\n\n/// @title Diamond Proxy Contract (EIP-2535)\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract DiamondProxy {\n    constructor(uint256 _chainId, Diamond.DiamondCutData memory _diamondCut) {\n        // Check that the contract is deployed on the expected chain.\n        // Thus, the contract deployed by the same Create2 factory on the different chain will have different addresses!\n        require(_chainId == block.chainid, \"pr\");\n        Diamond.diamondCut(_diamondCut);\n    }\n\n    /// @dev 1. Find the facet for the function that is called.\n    /// @dev 2. Delegate the execution to the found facet via `delegatecall`.\n    fallback() external payable {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n        // Check whether the data contains a \"full\" selector or it is empty.\n        // Required because Diamond proxy finds a facet by function signature,\n        // which is not defined for data length in range [1, 3].\n        require(msg.data.length >= 4 || msg.data.length == 0, \"Ut\");\n        // Get facet from function selector\n        Diamond.SelectorToFacet memory facet = diamondStorage.selectorToFacet[msg.sig];\n        address facetAddress = facet.facetAddress;\n\n        require(facetAddress != address(0), \"F\"); // Proxy has no facet for this selector\n        require(!diamondStorage.isFrozen || !facet.isFreezable, \"q1\"); // Facet is frozen\n\n        assembly {\n            // The pointer to the free memory slot\n            let ptr := mload(0x40)\n            // Copy function signature and arguments from calldata at zero position into memory at pointer position\n            calldatacopy(ptr, 0, calldatasize())\n            // Delegatecall method of the implementation contract returns 0 on error\n            let result := delegatecall(gas(), facetAddress, ptr, calldatasize(), 0, 0)\n            // Get the size of the last return data\n            let size := returndatasize()\n            // Copy the size length of bytes from return data at zero position to pointer position\n            returndatacopy(ptr, 0, size)\n            // Depending on the result value\n            switch result\n            case 0 {\n                // End execution and revert state changes\n                revert(ptr, size)\n            }\n            default {\n                // Return data with length of size at pointers position\n                return(ptr, size)\n            }\n        }\n    }\n}\n"
      },
      "contracts/state-transition/chain-deps/GatewayCTMDeployer.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {MailboxFacet} from \"./facets/Mailbox.sol\";\nimport {ExecutorFacet} from \"./facets/Executor.sol\";\nimport {GettersFacet} from \"./facets/Getters.sol\";\nimport {AdminFacet} from \"./facets/Admin.sol\";\nimport {Multicall3} from \"../../dev-contracts/Multicall3.sol\";\n\nimport {RollupDAManager} from \"../data-availability/RollupDAManager.sol\";\nimport {RelayedSLDAValidator} from \"../data-availability/RelayedSLDAValidator.sol\";\nimport {ValidiumL1DAValidator} from \"../data-availability/ValidiumL1DAValidator.sol\";\n\nimport {Verifier} from \"../Verifier.sol\";\nimport {VerifierParams, IVerifier} from \"../chain-interfaces/IVerifier.sol\";\nimport {TestnetVerifier} from \"../TestnetVerifier.sol\";\nimport {ValidatorTimelock} from \"../ValidatorTimelock.sol\";\nimport {FeeParams} from \"../chain-deps/ZKChainStorage.sol\";\n\nimport {DiamondInit} from \"./DiamondInit.sol\";\nimport {L1GenesisUpgrade} from \"../../upgrades/L1GenesisUpgrade.sol\";\nimport {Diamond} from \"../libraries/Diamond.sol\";\n\nimport {ChainTypeManager} from \"../ChainTypeManager.sol\";\n\nimport {L2_BRIDGEHUB_ADDR} from \"../../common/L2ContractAddresses.sol\";\n\nimport {ProxyAdmin} from \"@openzeppelin/contracts-v4/proxy/transparent/ProxyAdmin.sol\";\nimport {TransparentUpgradeableProxy} from \"@openzeppelin/contracts-v4/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport {InitializeDataNewChain as DiamondInitializeDataNewChain} from \"../chain-interfaces/IDiamondInit.sol\";\nimport {ChainTypeManagerInitializeData, ChainCreationParams, IChainTypeManager} from \"../IChainTypeManager.sol\";\n\n/// @notice Configuration parameters for deploying the GatewayCTMDeployer contract.\nstruct GatewayCTMDeployerConfig {\n    /// @notice Address of the aliased governance contract.\n    address aliasedGovernanceAddress;\n    /// @notice Salt used for deterministic deployments via CREATE2.\n    bytes32 salt;\n    /// @notice Chain ID of the Era chain.\n    uint256 eraChainId;\n    /// @notice Chain ID of the L1 chain.\n    uint256 l1ChainId;\n    /// @notice Address of the Rollup L2 Data Availability Validator.\n    address rollupL2DAValidatorAddress;\n    /// @notice Flag indicating whether to use the testnet verifier.\n    bool testnetVerifier;\n    /// @notice Array of function selectors for the Admin facet.\n    bytes4[] adminSelectors;\n    /// @notice Array of function selectors for the Executor facet.\n    bytes4[] executorSelectors;\n    /// @notice Array of function selectors for the Mailbox facet.\n    bytes4[] mailboxSelectors;\n    /// @notice Array of function selectors for the Getters facet.\n    bytes4[] gettersSelectors;\n    /// @notice Parameters for the verifier contract.\n    VerifierParams verifierParams;\n    /// @notice Parameters related to fees.\n    /// @dev They are mainly related to the L1->L2 transactions, fees for\n    /// which are not processed on Gateway. However, we still need these\n    /// values to deploy new chain's instances on Gateway.\n    FeeParams feeParams;\n    /// @notice Hash of the bootloader bytecode.\n    bytes32 bootloaderHash;\n    /// @notice Hash of the default account bytecode.\n    bytes32 defaultAccountHash;\n    /// @notice Maximum gas limit for priority transactions.\n    uint256 priorityTxMaxGasLimit;\n    /// @notice Root hash of the genesis state.\n    bytes32 genesisRoot;\n    /// @notice Leaf index in the genesis rollup.\n    uint256 genesisRollupLeafIndex;\n    /// @notice Commitment of the genesis batch.\n    bytes32 genesisBatchCommitment;\n    /// @notice Data for force deployments.\n    bytes forceDeploymentsData;\n    /// @notice The latest protocol version.\n    uint256 protocolVersion;\n}\n\n/// @notice Addresses of state transition related contracts.\n// solhint-disable-next-line gas-struct-packing\nstruct StateTransitionContracts {\n    /// @notice Address of the ChainTypeManager proxy contract.\n    address chainTypeManagerProxy;\n    /// @notice Address of the ChainTypeManager implementation contract.\n    address chainTypeManagerImplementation;\n    /// @notice Address of the Verifier contract.\n    address verifier;\n    /// @notice Address of the Admin facet contract.\n    address adminFacet;\n    /// @notice Address of the Mailbox facet contract.\n    address mailboxFacet;\n    /// @notice Address of the Executor facet contract.\n    address executorFacet;\n    /// @notice Address of the Getters facet contract.\n    address gettersFacet;\n    /// @notice Address of the DiamondInit contract.\n    address diamondInit;\n    /// @notice Address of the GenesisUpgrade contract.\n    address genesisUpgrade;\n    /// @notice Address of the ValidatorTimelock contract.\n    address validatorTimelock;\n    /// @notice Address of the ProxyAdmin for ChainTypeManager.\n    address chainTypeManagerProxyAdmin;\n}\n\n/// @notice Addresses of Data Availability (DA) related contracts.\n// solhint-disable-next-line gas-struct-packing\nstruct DAContracts {\n    /// @notice Address of the RollupDAManager contract.\n    address rollupDAManager;\n    /// @notice Address of the RelayedSLDAValidator contract.\n    address relayedSLDAValidator;\n    /// @notice Address of the ValidiumL1DAValidator contract.\n    address validiumDAValidator;\n}\n\n/// @notice Collection of all deployed contracts by the GatewayCTMDeployer.\nstruct DeployedContracts {\n    /// @notice Address of the Multicall3 contract.\n    address multicall3;\n    /// @notice Struct containing state transition related contracts.\n    StateTransitionContracts stateTransition;\n    /// @notice Struct containing Data Availability related contracts.\n    DAContracts daContracts;\n    /// @notice Encoded data for the diamond cut operation.\n    bytes diamondCutData;\n}\n\n/// @dev The constant address to be used for the blobHashRetriever inside the contracts.\n/// At the time of this writing the blob hash retriever is not used at all, but the zero-address\n/// check is still yet present, so we use address one as the substitution.\naddress constant BLOB_HASH_RETRIEVER_ADDR = address(uint160(1));\n\n/// @title GatewayCTMDeployer\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Contract responsible for deploying all the CTM-related contracts on top\n/// of the Gateway contract.\n/// @dev The expectation is that this contract will be deployed via the built-in L2 `Create2Factory`.\n/// This will achieve the fact that the address of this contract (and thus, the addresses of the\n/// contract it deploys are deterministic). An important role that this contract plays is in\n/// being the first owner of some of the contracts (e.g. ValidatorTimelock), which helps it to initialize it properly\n/// and transfer the ownership to the correct governance.\n/// @dev Note, that it is expected to be used in zkEVM environment only. Since all of the deployments\n/// are done by hash in zkEVM, this contract is actually quite small and cheap to execute in zkEVM environment.\ncontract GatewayCTMDeployer {\n    DeployedContracts internal deployedContracts;\n\n    /// @notice Returns deployed contracts.\n    /// @dev Just using `public` mode for the `deployedContracts` field did not work\n    /// due to internal issues during testing.\n    /// @return contracts The struct with information about the deployed contracts.\n    function getDeployedContracts() external view returns (DeployedContracts memory contracts) {\n        contracts = deployedContracts;\n    }\n\n    constructor(GatewayCTMDeployerConfig memory _config) {\n        // Caching some values\n        bytes32 salt = _config.salt;\n        uint256 eraChainId = _config.eraChainId;\n        uint256 l1ChainId = _config.l1ChainId;\n\n        DeployedContracts memory contracts;\n\n        contracts.multicall3 = address(new Multicall3{salt: salt}());\n\n        _deployFacetsAndUpgrades({\n            _salt: salt,\n            _eraChainId: eraChainId,\n            _l1ChainId: l1ChainId,\n            _rollupL2DAValidatorAddress: _config.rollupL2DAValidatorAddress,\n            _aliasedGovernanceAddress: _config.aliasedGovernanceAddress,\n            _deployedContracts: contracts\n        });\n        _deployVerifier(salt, _config.testnetVerifier, contracts);\n\n        ValidatorTimelock timelock = new ValidatorTimelock{salt: salt}(address(this), 0);\n        contracts.stateTransition.validatorTimelock = address(timelock);\n\n        _deployCTM(salt, _config, contracts);\n        _setChainTypeManagerInValidatorTimelock(_config.aliasedGovernanceAddress, timelock, contracts);\n\n        deployedContracts = contracts;\n    }\n\n    /// @notice Deploys facets and upgrade contracts.\n    /// @param _salt Salt used for CREATE2 deployments.\n    /// @param _eraChainId Era Chain ID.\n    /// @param _l1ChainId L1 Chain ID.\n    /// @param _rollupL2DAValidatorAddress The expected L2 DA Validator to be\n    /// used by permanent rollups.\n    /// @param _aliasedGovernanceAddress The aliased address of the governnace.\n    /// @param _deployedContracts The struct with deployed contracts, that will be mofiied\n    /// in the process of the execution of this function.\n    function _deployFacetsAndUpgrades(\n        bytes32 _salt,\n        uint256 _eraChainId,\n        uint256 _l1ChainId,\n        address _rollupL2DAValidatorAddress,\n        address _aliasedGovernanceAddress,\n        DeployedContracts memory _deployedContracts\n    ) internal {\n        _deployedContracts.stateTransition.mailboxFacet = address(\n            new MailboxFacet{salt: _salt}(_eraChainId, _l1ChainId)\n        );\n        _deployedContracts.stateTransition.executorFacet = address(new ExecutorFacet{salt: _salt}(_l1ChainId));\n        _deployedContracts.stateTransition.gettersFacet = address(new GettersFacet{salt: _salt}());\n\n        RollupDAManager rollupDAManager = _deployRollupDAContracts(\n            _salt,\n            _rollupL2DAValidatorAddress,\n            _aliasedGovernanceAddress,\n            _deployedContracts\n        );\n        _deployedContracts.stateTransition.adminFacet = address(\n            new AdminFacet{salt: _salt}(_l1ChainId, rollupDAManager)\n        );\n\n        _deployedContracts.stateTransition.diamondInit = address(new DiamondInit{salt: _salt}());\n        _deployedContracts.stateTransition.genesisUpgrade = address(new L1GenesisUpgrade{salt: _salt}());\n    }\n\n    /// @notice Deploys verifier.\n    /// @param _salt Salt used for CREATE2 deployments.\n    /// @param _testnetVerifier Whether testnet verifier should be used.\n    /// @param _deployedContracts The struct with deployed contracts, that will be mofiied\n    /// in the process of the execution of this function.\n    function _deployVerifier(\n        bytes32 _salt,\n        bool _testnetVerifier,\n        DeployedContracts memory _deployedContracts\n    ) internal {\n        if (_testnetVerifier) {\n            _deployedContracts.stateTransition.verifier = address(new TestnetVerifier{salt: _salt}());\n        } else {\n            _deployedContracts.stateTransition.verifier = address(new Verifier{salt: _salt}());\n        }\n    }\n\n    /// @notice Deploys DA-related contracts.\n    /// @param _salt Salt used for CREATE2 deployments.\n    /// @param _rollupL2DAValidatorAddress The expected L2 DA Validator to be\n    /// used by permanent rollups.\n    /// @param _aliasedGovernanceAddress The aliased address of the governnace.\n    /// @param _deployedContracts The struct with deployed contracts, that will be mofiied\n    /// in the process of the execution of this function.\n    function _deployRollupDAContracts(\n        bytes32 _salt,\n        address _rollupL2DAValidatorAddress,\n        address _aliasedGovernanceAddress,\n        DeployedContracts memory _deployedContracts\n    ) internal returns (RollupDAManager rollupDAManager) {\n        rollupDAManager = new RollupDAManager{salt: _salt}();\n\n        ValidiumL1DAValidator validiumDAValidator = new ValidiumL1DAValidator{salt: _salt}();\n\n        RelayedSLDAValidator relayedSLDAValidator = new RelayedSLDAValidator{salt: _salt}();\n        rollupDAManager.updateDAPair(address(relayedSLDAValidator), _rollupL2DAValidatorAddress, true);\n\n        // Note, that the governance still has to accept it.\n        // It will happen in a separate voting after the deployment is done.\n        rollupDAManager.transferOwnership(_aliasedGovernanceAddress);\n\n        _deployedContracts.daContracts.rollupDAManager = address(rollupDAManager);\n        _deployedContracts.daContracts.relayedSLDAValidator = address(relayedSLDAValidator);\n        _deployedContracts.daContracts.validiumDAValidator = address(validiumDAValidator);\n    }\n\n    /// @notice Deploys DA-related contracts.\n    /// @param _salt Salt used for CREATE2 deployments.\n    /// @param _config The deployment config.\n    /// @param _deployedContracts The struct with deployed contracts, that will be mofiied\n    /// in the process of the execution of this function.\n    function _deployCTM(\n        bytes32 _salt,\n        GatewayCTMDeployerConfig memory _config,\n        DeployedContracts memory _deployedContracts\n    ) internal {\n        _deployedContracts.stateTransition.chainTypeManagerImplementation = address(\n            new ChainTypeManager{salt: _salt}(L2_BRIDGEHUB_ADDR)\n        );\n        ProxyAdmin proxyAdmin = new ProxyAdmin{salt: _salt}();\n        proxyAdmin.transferOwnership(_config.aliasedGovernanceAddress);\n        _deployedContracts.stateTransition.chainTypeManagerProxyAdmin = address(proxyAdmin);\n\n        Diamond.FacetCut[] memory facetCuts = new Diamond.FacetCut[](4);\n        facetCuts[0] = Diamond.FacetCut({\n            facet: _deployedContracts.stateTransition.adminFacet,\n            action: Diamond.Action.Add,\n            isFreezable: false,\n            selectors: _config.adminSelectors\n        });\n        facetCuts[1] = Diamond.FacetCut({\n            facet: _deployedContracts.stateTransition.gettersFacet,\n            action: Diamond.Action.Add,\n            isFreezable: false,\n            selectors: _config.gettersSelectors\n        });\n        facetCuts[2] = Diamond.FacetCut({\n            facet: _deployedContracts.stateTransition.mailboxFacet,\n            action: Diamond.Action.Add,\n            isFreezable: true,\n            selectors: _config.mailboxSelectors\n        });\n        facetCuts[3] = Diamond.FacetCut({\n            facet: _deployedContracts.stateTransition.executorFacet,\n            action: Diamond.Action.Add,\n            isFreezable: true,\n            selectors: _config.executorSelectors\n        });\n\n        DiamondInitializeDataNewChain memory initializeData = DiamondInitializeDataNewChain({\n            verifier: IVerifier(_deployedContracts.stateTransition.verifier),\n            verifierParams: _config.verifierParams,\n            l2BootloaderBytecodeHash: _config.bootloaderHash,\n            l2DefaultAccountBytecodeHash: _config.defaultAccountHash,\n            priorityTxMaxGasLimit: _config.priorityTxMaxGasLimit,\n            feeParams: _config.feeParams,\n            blobVersionedHashRetriever: BLOB_HASH_RETRIEVER_ADDR\n        });\n\n        Diamond.DiamondCutData memory diamondCut = Diamond.DiamondCutData({\n            facetCuts: facetCuts,\n            initAddress: _deployedContracts.stateTransition.diamondInit,\n            initCalldata: abi.encode(initializeData)\n        });\n\n        _deployedContracts.diamondCutData = abi.encode(diamondCut);\n\n        ChainCreationParams memory chainCreationParams = ChainCreationParams({\n            genesisUpgrade: _deployedContracts.stateTransition.genesisUpgrade,\n            genesisBatchHash: _config.genesisRoot,\n            genesisIndexRepeatedStorageChanges: uint64(_config.genesisRollupLeafIndex),\n            genesisBatchCommitment: _config.genesisBatchCommitment,\n            diamondCut: diamondCut,\n            // Note, it is the same as for contracts that are based on L2\n            forceDeploymentsData: _config.forceDeploymentsData\n        });\n\n        ChainTypeManagerInitializeData memory diamondInitData = ChainTypeManagerInitializeData({\n            owner: _config.aliasedGovernanceAddress,\n            validatorTimelock: _deployedContracts.stateTransition.validatorTimelock,\n            chainCreationParams: chainCreationParams,\n            protocolVersion: _config.protocolVersion\n        });\n\n        _deployedContracts.stateTransition.chainTypeManagerProxy = address(\n            new TransparentUpgradeableProxy{salt: _salt}(\n                _deployedContracts.stateTransition.chainTypeManagerImplementation,\n                address(proxyAdmin),\n                abi.encodeCall(ChainTypeManager.initialize, (diamondInitData))\n            )\n        );\n    }\n\n    /// @notice Sets the previously deployed CTM inside the ValidatorTimelock\n    /// @param _aliasedGovernanceAddress The aliased address of the governnace.\n    /// @param _timelock The address of the validator timelock\n    /// @param _deployedContracts The struct with deployed contracts, that will be mofiied\n    /// in the process of the execution of this function.\n    function _setChainTypeManagerInValidatorTimelock(\n        address _aliasedGovernanceAddress,\n        ValidatorTimelock _timelock,\n        DeployedContracts memory _deployedContracts\n    ) internal {\n        _timelock.setChainTypeManager(IChainTypeManager(_deployedContracts.stateTransition.chainTypeManagerProxy));\n\n        // Note, that the governance still has to accept it.\n        // It will happen in a separate voting after the deployment is done.\n        _timelock.transferOwnership(_aliasedGovernanceAddress);\n    }\n}\n"
      },
      "contracts/state-transition/chain-deps/ZKChainStorage.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IVerifier, VerifierParams} from \"../chain-interfaces/IVerifier.sol\";\n// import {IChainTypeManager} from \"../IChainTypeManager.sol\";\nimport {PriorityQueue} from \"../../state-transition/libraries/PriorityQueue.sol\";\nimport {PriorityTree} from \"../../state-transition/libraries/PriorityTree.sol\";\n\n/// @notice Indicates whether an upgrade is initiated and if yes what type\n/// @param None Upgrade is NOT initiated\n/// @param Transparent Fully transparent upgrade is initiated, upgrade data is publicly known\n/// @param Shadow Shadow upgrade is initiated, upgrade data is hidden\nenum UpgradeState {\n    None,\n    Transparent,\n    Shadow\n}\n\n/// @dev Logically separated part of the storage structure, which is responsible for everything related to proxy\n/// upgrades and diamond cuts\n/// @param proposedUpgradeHash The hash of the current upgrade proposal, zero if there is no active proposal\n/// @param state Indicates whether an upgrade is initiated and if yes what type\n/// @param securityCouncil Address which has the permission to approve instant upgrades (expected to be a Gnosis\n/// multisig)\n/// @param approvedBySecurityCouncil Indicates whether the security council has approved the upgrade\n/// @param proposedUpgradeTimestamp The timestamp when the upgrade was proposed, zero if there are no active proposals\n/// @param currentProposalId The serial number of proposed upgrades, increments when proposing a new one\nstruct UpgradeStorage {\n    bytes32 proposedUpgradeHash;\n    UpgradeState state;\n    address securityCouncil;\n    bool approvedBySecurityCouncil;\n    uint40 proposedUpgradeTimestamp;\n    uint40 currentProposalId;\n}\n\n/// @notice The struct that describes whether users will be charged for pubdata for L1->L2 transactions.\n/// @param Rollup The users are charged for pubdata & it is priced based on the gas price on Ethereum.\n/// @param Validium The pubdata is considered free with regard to the L1 gas price.\nenum PubdataPricingMode {\n    Rollup,\n    Validium\n}\n\n/// @notice The fee params for L1->L2 transactions for the network.\n/// @param pubdataPricingMode How the users will charged for pubdata in L1->L2 transactions.\n/// @param batchOverheadL1Gas The amount of L1 gas required to process the batch (except for the calldata).\n/// @param maxPubdataPerBatch The maximal number of pubdata that can be emitted per batch.\n/// @param priorityTxMaxPubdata The maximal amount of pubdata a priority transaction is allowed to publish.\n/// It can be slightly less than maxPubdataPerBatch in order to have some margin for the bootloader execution.\n/// @param minimalL2GasPrice The minimal L2 gas price to be used by L1->L2 transactions. It should represent\n/// the price that a single unit of compute costs.\nstruct FeeParams {\n    PubdataPricingMode pubdataPricingMode;\n    uint32 batchOverheadL1Gas;\n    uint32 maxPubdataPerBatch;\n    uint32 maxL2GasPerBatch;\n    uint32 priorityTxMaxPubdata;\n    uint64 minimalL2GasPrice;\n}\n\n/// @dev storing all storage variables for ZK chain diamond facets\n/// NOTE: It is used in a proxy, so it is possible to add new variables to the end\n/// but NOT to modify already existing variables or change their order.\n/// NOTE: variables prefixed with '__DEPRECATED_' are deprecated and shouldn't be used.\n/// Their presence is maintained for compatibility and to prevent storage collision.\n// solhint-disable-next-line gas-struct-packing\nstruct ZKChainStorage {\n    /// @dev Storage of variables needed for deprecated diamond cut facet\n    uint256[7] __DEPRECATED_diamondCutStorage;\n    /// @notice Address which will exercise critical changes to the Diamond Proxy (upgrades, freezing & unfreezing). Replaced by CTM\n    address __DEPRECATED_governor;\n    /// @notice Address that the governor proposed as one that will replace it\n    address __DEPRECATED_pendingGovernor;\n    /// @notice List of permitted validators\n    mapping(address validatorAddress => bool isValidator) validators;\n    /// @dev Verifier contract. Used to verify aggregated proof for batches\n    IVerifier verifier;\n    /// @notice Total number of executed batches i.e. batches[totalBatchesExecuted] points at the latest executed batch\n    /// (batch 0 is genesis)\n    uint256 totalBatchesExecuted;\n    /// @notice Total number of proved batches i.e. batches[totalBatchesProved] points at the latest proved batch\n    uint256 totalBatchesVerified;\n    /// @notice Total number of committed batches i.e. batches[totalBatchesCommitted] points at the latest committed\n    /// batch\n    uint256 totalBatchesCommitted;\n    /// @dev Stored hashed StoredBatch for batch number\n    mapping(uint256 batchNumber => bytes32 batchHash) storedBatchHashes;\n    /// @dev Stored root hashes of L2 -> L1 logs\n    mapping(uint256 batchNumber => bytes32 l2LogsRootHash) l2LogsRootHashes;\n    /// @dev Container that stores transactions requested from L1\n    PriorityQueue.Queue priorityQueue;\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    address __DEPRECATED_allowList;\n    VerifierParams __DEPRECATED_verifierParams;\n    /// @notice Bytecode hash of bootloader program.\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2BootloaderBytecodeHash;\n    /// @notice Bytecode hash of default account (bytecode for EOA).\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2DefaultAccountBytecodeHash;\n    /// @dev Indicates that the porter may be touched on L2 transactions.\n    /// @dev Used as an input to zkp-circuit.\n    bool zkPorterIsAvailable;\n    /// @dev The maximum number of the L2 gas that a user can request for L1 -> L2 transactions\n    /// @dev This is the maximum number of L2 gas that is available for the \"body\" of the transaction, i.e.\n    /// without overhead for proving the batch.\n    uint256 priorityTxMaxGasLimit;\n    /// @dev Storage of variables needed for upgrade facet\n    UpgradeStorage __DEPRECATED_upgrades;\n    /// @dev A mapping L2 batch number => message number => flag.\n    /// @dev The L2 -> L1 log is sent for every withdrawal, so this mapping is serving as\n    /// a flag to indicate that the message was already processed.\n    /// @dev Used to indicate that eth withdrawal was already processed\n    mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized)) isEthWithdrawalFinalized;\n    /// @dev The most recent withdrawal time and amount reset\n    uint256 __DEPRECATED_lastWithdrawalLimitReset;\n    /// @dev The accumulated withdrawn amount during the withdrawal limit window\n    uint256 __DEPRECATED_withdrawnAmountInWindow;\n    /// @dev A mapping user address => the total deposited amount by the user\n    mapping(address => uint256) __DEPRECATED_totalDepositedAmountPerUser;\n    /// @dev Stores the protocol version. Note, that the protocol version may not only encompass changes to the\n    /// smart contracts, but also to the node behavior.\n    uint256 protocolVersion;\n    /// @dev Hash of the system contract upgrade transaction. If 0, then no upgrade transaction needs to be done.\n    bytes32 l2SystemContractsUpgradeTxHash;\n    /// @dev Batch number where the upgrade transaction has happened. If 0, then no upgrade transaction has happened\n    /// yet.\n    uint256 l2SystemContractsUpgradeBatchNumber;\n    /// @dev Address which will exercise non-critical changes to the Diamond Proxy (changing validator set & unfreezing)\n    address admin;\n    /// @notice Address that the admin proposed as one that will replace admin role\n    address pendingAdmin;\n    /// @dev Fee params used to derive gasPrice for the L1->L2 transactions. For L2 transactions,\n    /// the bootloader gives enough freedom to the operator.\n    /// @dev The value is only for the L1 deployment of the ZK Chain, since payment for all the priority transactions is\n    /// charged at that level.\n    FeeParams feeParams;\n    /// @dev Address of the blob versioned hash getter smart contract used for EIP-4844 versioned hashes.\n    /// @dev Used only for testing.\n    address blobVersionedHashRetriever;\n    /// @dev The chainId of the chain\n    uint256 chainId;\n    /// @dev The address of the bridgehub\n    address bridgehub;\n    /// @dev The address of the ChainTypeManager\n    address chainTypeManager;\n    /// @dev The address of the baseToken contract. Eth is address(1)\n    address __DEPRECATED_baseToken;\n    /// @dev The address of the baseTokenbridge. Eth also uses the shared bridge\n    address __DEPRECATED_baseTokenBridge;\n    /// @notice gasPriceMultiplier for each baseToken, so that each L1->L2 transaction pays for its transaction on the destination\n    /// we multiply by the nominator, and divide by the denominator\n    uint128 baseTokenGasPriceMultiplierNominator;\n    uint128 baseTokenGasPriceMultiplierDenominator;\n    /// @dev The optional address of the contract that has to be used for transaction filtering/whitelisting\n    address transactionFilterer;\n    /// @dev The address of the l1DAValidator contract.\n    /// This contract is responsible for the verification of the correctness of the DA on L1.\n    address l1DAValidator;\n    /// @dev The address of the contract on L2 that is responsible for the data availability verification.\n    /// This contract sends `l2DAValidatorOutputHash` to L1 via L2->L1 system log and it will routed to the `l1DAValidator` contract.\n    address l2DAValidator;\n    /// @dev the Asset Id of the baseToken\n    bytes32 baseTokenAssetId;\n    /// @dev If this ZKchain settles on this chain, then this is zero. Otherwise it is the address of the ZKchain that is a\n    /// settlement layer for this ZKchain. (think about it as a 'forwarding' address for the chain that migrated away).\n    address settlementLayer;\n    /// @dev Priority tree, the new data structure for priority queue\n    PriorityTree.Tree priorityTree;\n    /// @dev Whether the chain is a permanent rollup. Note, that it only enforces the DA validator pair, but\n    /// it does not enforce any other parameters, e.g. `pubdataPricingMode`\n    bool isPermanentRollup;\n}\n"
      },
      "contracts/state-transition/chain-deps/facets/Admin.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IAdmin} from \"../../chain-interfaces/IAdmin.sol\";\nimport {Diamond} from \"../../libraries/Diamond.sol\";\nimport {MAX_GAS_PER_TRANSACTION, ZKChainCommitment} from \"../../../common/Config.sol\";\nimport {FeeParams, PubdataPricingMode} from \"../ZKChainStorage.sol\";\nimport {PriorityTree} from \"../../../state-transition/libraries/PriorityTree.sol\";\nimport {PriorityQueue} from \"../../../state-transition/libraries/PriorityQueue.sol\";\nimport {ZKChainBase} from \"./ZKChainBase.sol\";\nimport {IChainTypeManager} from \"../../IChainTypeManager.sol\";\nimport {IL1GenesisUpgrade} from \"../../../upgrades/IL1GenesisUpgrade.sol\";\nimport {Unauthorized, TooMuchGas, PriorityTxPubdataExceedsMaxPubDataPerBatch, InvalidPubdataPricingMode, ProtocolIdMismatch, HashMismatch, ProtocolIdNotGreater, DenominatorIsZero, DiamondAlreadyFrozen, DiamondNotFrozen, InvalidDAForPermanentRollup, AlreadyPermanentRollup} from \"../../../common/L1ContractErrors.sol\";\nimport {NotL1, L1DAValidatorAddressIsZero, L2DAValidatorAddressIsZero, AlreadyMigrated, NotChainAdmin, ProtocolVersionNotUpToDate, ExecutedIsNotConsistentWithVerified, VerifiedIsNotConsistentWithCommitted, InvalidNumberOfBatchHashes, PriorityQueueNotReady, VerifiedIsNotConsistentWithCommitted, NotAllBatchesExecuted, OutdatedProtocolVersion, NotHistoricalRoot, ContractNotDeployed, NotMigrated} from \"../../L1StateTransitionErrors.sol\";\nimport {RollupDAManager} from \"../../data-availability/RollupDAManager.sol\";\n\n// While formally the following import is not used, it is needed to inherit documentation from it\nimport {IZKChainBase} from \"../../chain-interfaces/IZKChainBase.sol\";\n\n/// @title Admin Contract controls access rights for contract management.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract AdminFacet is ZKChainBase, IAdmin {\n    using PriorityTree for PriorityTree.Tree;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZKChainBase\n    string public constant override getName = \"AdminFacet\";\n\n    /// @notice The chain id of L1. This contract can be deployed on multiple layers, but this value is still equal to the\n    /// L1 that is at the most base layer.\n    uint256 internal immutable L1_CHAIN_ID;\n\n    /// @notice The address that is responsible for determining whether a certain DA pair is allowed for rollups.\n    RollupDAManager internal immutable ROLLUP_DA_MANAGER;\n\n    constructor(uint256 _l1ChainId, RollupDAManager _rollupDAManager) {\n        L1_CHAIN_ID = _l1ChainId;\n        ROLLUP_DA_MANAGER = _rollupDAManager;\n    }\n\n    modifier onlyL1() {\n        if (block.chainid != L1_CHAIN_ID) {\n            revert NotL1(block.chainid);\n        }\n        _;\n    }\n\n    /// @inheritdoc IAdmin\n    function setPendingAdmin(address _newPendingAdmin) external onlyAdmin {\n        // Save previous value into the stack to put it into the event later\n        address oldPendingAdmin = s.pendingAdmin;\n        // Change pending admin\n        s.pendingAdmin = _newPendingAdmin;\n        emit NewPendingAdmin(oldPendingAdmin, _newPendingAdmin);\n    }\n\n    /// @inheritdoc IAdmin\n    function acceptAdmin() external {\n        address pendingAdmin = s.pendingAdmin;\n        // Only proposed by current admin address can claim the admin rights\n        if (msg.sender != pendingAdmin) {\n            revert Unauthorized(msg.sender);\n        }\n\n        address previousAdmin = s.admin;\n        s.admin = pendingAdmin;\n        delete s.pendingAdmin;\n\n        emit NewPendingAdmin(pendingAdmin, address(0));\n        emit NewAdmin(previousAdmin, pendingAdmin);\n    }\n\n    /// @inheritdoc IAdmin\n    function setValidator(address _validator, bool _active) external onlyChainTypeManager {\n        s.validators[_validator] = _active;\n        emit ValidatorStatusUpdate(_validator, _active);\n    }\n\n    /// @inheritdoc IAdmin\n    function setPorterAvailability(bool _zkPorterIsAvailable) external onlyChainTypeManager {\n        // Change the porter availability\n        s.zkPorterIsAvailable = _zkPorterIsAvailable;\n        emit IsPorterAvailableStatusUpdate(_zkPorterIsAvailable);\n    }\n\n    /// @inheritdoc IAdmin\n    function setPriorityTxMaxGasLimit(uint256 _newPriorityTxMaxGasLimit) external onlyChainTypeManager onlyL1 {\n        if (_newPriorityTxMaxGasLimit > MAX_GAS_PER_TRANSACTION) {\n            revert TooMuchGas();\n        }\n\n        uint256 oldPriorityTxMaxGasLimit = s.priorityTxMaxGasLimit;\n        s.priorityTxMaxGasLimit = _newPriorityTxMaxGasLimit;\n        emit NewPriorityTxMaxGasLimit(oldPriorityTxMaxGasLimit, _newPriorityTxMaxGasLimit);\n    }\n\n    /// @inheritdoc IAdmin\n    function changeFeeParams(FeeParams calldata _newFeeParams) external onlyAdminOrChainTypeManager onlyL1 {\n        // Double checking that the new fee params are valid, i.e.\n        // the maximal pubdata per batch is not less than the maximal pubdata per priority transaction.\n        if (_newFeeParams.maxPubdataPerBatch < _newFeeParams.priorityTxMaxPubdata) {\n            revert PriorityTxPubdataExceedsMaxPubDataPerBatch();\n        }\n\n        FeeParams memory oldFeeParams = s.feeParams;\n\n        // we cannot change pubdata pricing mode\n        if (_newFeeParams.pubdataPricingMode != oldFeeParams.pubdataPricingMode) {\n            revert InvalidPubdataPricingMode();\n        }\n\n        s.feeParams = _newFeeParams;\n\n        emit NewFeeParams(oldFeeParams, _newFeeParams);\n    }\n\n    /// @inheritdoc IAdmin\n    function setTokenMultiplier(uint128 _nominator, uint128 _denominator) external onlyAdminOrChainTypeManager onlyL1 {\n        if (_denominator == 0) {\n            revert DenominatorIsZero();\n        }\n        uint128 oldNominator = s.baseTokenGasPriceMultiplierNominator;\n        uint128 oldDenominator = s.baseTokenGasPriceMultiplierDenominator;\n\n        s.baseTokenGasPriceMultiplierNominator = _nominator;\n        s.baseTokenGasPriceMultiplierDenominator = _denominator;\n\n        emit NewBaseTokenMultiplier(oldNominator, oldDenominator, _nominator, _denominator);\n    }\n\n    /// @inheritdoc IAdmin\n    function setPubdataPricingMode(PubdataPricingMode _pricingMode) external onlyAdmin onlyL1 {\n        s.feeParams.pubdataPricingMode = _pricingMode;\n        emit PubdataPricingModeUpdate(_pricingMode);\n    }\n\n    /// @inheritdoc IAdmin\n    function setTransactionFilterer(address _transactionFilterer) external onlyAdmin onlyL1 {\n        address oldTransactionFilterer = s.transactionFilterer;\n        s.transactionFilterer = _transactionFilterer;\n        emit NewTransactionFilterer(oldTransactionFilterer, _transactionFilterer);\n    }\n\n    /// @notice Sets the DA validator pair with the given addresses.\n    /// @dev It does not check for these addresses to be non-zero, since when migrating to a new settlement\n    /// layer, we set them to zero.\n    function _setDAValidatorPair(address _l1DAValidator, address _l2DAValidator) internal {\n        emit NewL1DAValidator(s.l1DAValidator, _l1DAValidator);\n        emit NewL2DAValidator(s.l2DAValidator, _l2DAValidator);\n\n        s.l1DAValidator = _l1DAValidator;\n        s.l2DAValidator = _l2DAValidator;\n    }\n\n    /// @inheritdoc IAdmin\n    function setDAValidatorPair(address _l1DAValidator, address _l2DAValidator) external onlyAdmin {\n        if (_l1DAValidator == address(0)) {\n            revert L1DAValidatorAddressIsZero();\n        }\n        if (_l2DAValidator == address(0)) {\n            revert L2DAValidatorAddressIsZero();\n        }\n\n        if (s.isPermanentRollup && !ROLLUP_DA_MANAGER.isPairAllowed(_l1DAValidator, _l2DAValidator)) {\n            revert InvalidDAForPermanentRollup();\n        }\n\n        _setDAValidatorPair(_l1DAValidator, _l2DAValidator);\n    }\n\n    /// @inheritdoc IAdmin\n    function makePermanentRollup() external onlyAdmin onlySettlementLayer {\n        if (s.isPermanentRollup) {\n            revert AlreadyPermanentRollup();\n        }\n\n        if (!ROLLUP_DA_MANAGER.isPairAllowed(s.l1DAValidator, s.l2DAValidator)) {\n            // The correct data availability pair should be set beforehand.\n            revert InvalidDAForPermanentRollup();\n        }\n\n        s.isPermanentRollup = true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            UPGRADE EXECUTION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IAdmin\n    function upgradeChainFromVersion(\n        uint256 _oldProtocolVersion,\n        Diamond.DiamondCutData calldata _diamondCut\n    ) external onlyAdminOrChainTypeManager {\n        bytes32 cutHashInput = keccak256(abi.encode(_diamondCut));\n        bytes32 upgradeCutHash = IChainTypeManager(s.chainTypeManager).upgradeCutHash(_oldProtocolVersion);\n        if (cutHashInput != upgradeCutHash) {\n            revert HashMismatch(upgradeCutHash, cutHashInput);\n        }\n\n        if (s.protocolVersion != _oldProtocolVersion) {\n            revert ProtocolIdMismatch(s.protocolVersion, _oldProtocolVersion);\n        }\n        Diamond.diamondCut(_diamondCut);\n        emit ExecuteUpgrade(_diamondCut);\n        if (s.protocolVersion <= _oldProtocolVersion) {\n            revert ProtocolIdNotGreater();\n        }\n    }\n\n    /// @inheritdoc IAdmin\n    function executeUpgrade(Diamond.DiamondCutData calldata _diamondCut) external onlyChainTypeManager {\n        Diamond.diamondCut(_diamondCut);\n        emit ExecuteUpgrade(_diamondCut);\n    }\n\n    /// @dev we have to set the chainId at genesis, as blockhashzero is the same for all chains with the same chainId\n    function genesisUpgrade(\n        address _l1GenesisUpgrade,\n        address _ctmDeployer,\n        bytes calldata _forceDeploymentData,\n        bytes[] calldata _factoryDeps\n    ) external onlyChainTypeManager {\n        Diamond.FacetCut[] memory emptyArray;\n        Diamond.DiamondCutData memory cutData = Diamond.DiamondCutData({\n            facetCuts: emptyArray,\n            initAddress: _l1GenesisUpgrade,\n            initCalldata: abi.encodeCall(\n                IL1GenesisUpgrade.genesisUpgrade,\n                (_l1GenesisUpgrade, s.chainId, s.protocolVersion, _ctmDeployer, _forceDeploymentData, _factoryDeps)\n            )\n        });\n\n        Diamond.diamondCut(cutData);\n        emit ExecuteUpgrade(cutData);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            CONTRACT FREEZING\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IAdmin\n    function freezeDiamond() external onlyChainTypeManager {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        // diamond proxy is frozen already\n        if (diamondStorage.isFrozen) {\n            revert DiamondAlreadyFrozen();\n        }\n        diamondStorage.isFrozen = true;\n\n        emit Freeze();\n    }\n\n    /// @inheritdoc IAdmin\n    function unfreezeDiamond() external onlyChainTypeManager {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        // diamond proxy is not frozen\n        if (!diamondStorage.isFrozen) {\n            revert DiamondNotFrozen();\n        }\n        diamondStorage.isFrozen = false;\n\n        emit Unfreeze();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            CHAIN MIGRATION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IAdmin\n    function forwardedBridgeBurn(\n        address _settlementLayer,\n        address _originalCaller,\n        bytes calldata _data\n    ) external payable override onlyBridgehub returns (bytes memory chainBridgeMintData) {\n        if (s.settlementLayer != address(0)) {\n            revert AlreadyMigrated();\n        }\n        if (_originalCaller != s.admin) {\n            revert NotChainAdmin(_originalCaller, s.admin);\n        }\n        // As of now all we need in this function is the chainId so we encode it and pass it down in the _chainData field\n        uint256 protocolVersion = abi.decode(_data, (uint256));\n\n        uint256 currentProtocolVersion = s.protocolVersion;\n\n        if (currentProtocolVersion != protocolVersion) {\n            revert ProtocolVersionNotUpToDate(currentProtocolVersion, protocolVersion);\n        }\n\n        if (block.chainid != L1_CHAIN_ID) {\n            // We assume that GW -> L1 transactions can never fail and provide no recovery mechanism from it.\n            // That's why we need to bound the gas that can be consumed during such a migration.\n            if (s.totalBatchesCommitted != s.totalBatchesExecuted) {\n                revert NotAllBatchesExecuted();\n            }\n        }\n\n        s.settlementLayer = _settlementLayer;\n        chainBridgeMintData = abi.encode(prepareChainCommitment());\n    }\n\n    /// @inheritdoc IAdmin\n    function forwardedBridgeMint(\n        bytes calldata _data,\n        bool _contractAlreadyDeployed\n    ) external payable override onlyBridgehub {\n        ZKChainCommitment memory _commitment = abi.decode(_data, (ZKChainCommitment));\n\n        IChainTypeManager ctm = IChainTypeManager(s.chainTypeManager);\n\n        uint256 currentProtocolVersion = s.protocolVersion;\n        uint256 protocolVersion = ctm.protocolVersion();\n        if (currentProtocolVersion != protocolVersion) {\n            revert OutdatedProtocolVersion(protocolVersion, currentProtocolVersion);\n        }\n        uint256 batchesExecuted = _commitment.totalBatchesExecuted;\n        uint256 batchesVerified = _commitment.totalBatchesVerified;\n        uint256 batchesCommitted = _commitment.totalBatchesCommitted;\n\n        s.totalBatchesCommitted = batchesCommitted;\n        s.totalBatchesVerified = batchesVerified;\n        s.totalBatchesExecuted = batchesExecuted;\n        s.isPermanentRollup = _commitment.isPermanentRollup;\n\n        // Some consistency checks just in case.\n        if (batchesExecuted > batchesVerified) {\n            revert ExecutedIsNotConsistentWithVerified(batchesExecuted, batchesVerified);\n        }\n        if (batchesVerified > batchesCommitted) {\n            revert VerifiedIsNotConsistentWithCommitted(batchesVerified, batchesCommitted);\n        }\n\n        // In the worst case, we may need to revert all the committed batches that were not executed.\n        // This means that the stored batch hashes should be stored for [batchesExecuted; batchesCommitted] batches, i.e.\n        // there should be batchesCommitted - batchesExecuted + 1 hashes.\n        if (_commitment.batchHashes.length != batchesCommitted - batchesExecuted + 1) {\n            revert InvalidNumberOfBatchHashes(_commitment.batchHashes.length, batchesCommitted - batchesExecuted + 1);\n        }\n\n        // Note that this part is done in O(N), i.e. it is the responsibility of the admin of the chain to ensure that the total number of\n        // outstanding committed batches is not too long.\n        uint256 length = _commitment.batchHashes.length;\n        for (uint256 i = 0; i < length; ++i) {\n            s.storedBatchHashes[batchesExecuted + i] = _commitment.batchHashes[i];\n        }\n\n        if (block.chainid == L1_CHAIN_ID) {\n            // L1 PTree contains all L1->L2 transactions.\n            if (\n                !s.priorityTree.isHistoricalRoot(\n                    _commitment.priorityTree.sides[_commitment.priorityTree.sides.length - 1]\n                )\n            ) {\n                revert NotHistoricalRoot();\n            }\n            if (!_contractAlreadyDeployed) {\n                revert ContractNotDeployed();\n            }\n            if (s.settlementLayer == address(0)) {\n                revert NotMigrated();\n            }\n            s.priorityTree.l1Reinit(_commitment.priorityTree);\n        } else if (_contractAlreadyDeployed) {\n            if (s.settlementLayer == address(0)) {\n                revert NotMigrated();\n            }\n            s.priorityTree.checkGWReinit(_commitment.priorityTree);\n            s.priorityTree.initFromCommitment(_commitment.priorityTree);\n        } else {\n            s.priorityTree.initFromCommitment(_commitment.priorityTree);\n        }\n        _forceDeactivateQueue();\n\n        s.l2SystemContractsUpgradeTxHash = _commitment.l2SystemContractsUpgradeTxHash;\n        s.l2SystemContractsUpgradeBatchNumber = _commitment.l2SystemContractsUpgradeBatchNumber;\n\n        // Set the settlement to 0 - as this is the current settlement chain.\n        s.settlementLayer = address(0);\n\n        _setDAValidatorPair(address(0), address(0));\n\n        emit MigrationComplete();\n    }\n\n    /// @inheritdoc IAdmin\n    function forwardedBridgeRecoverFailedTransfer(\n        uint256 /* _chainId */,\n        bytes32 /* _assetInfo */,\n        address /* _depositSender */,\n        bytes calldata _chainData\n    ) external payable override onlyBridgehub {\n        // As of now all we need in this function is the chainId so we encode it and pass it down in the _chainData field\n        uint256 protocolVersion = abi.decode(_chainData, (uint256));\n\n        if (s.settlementLayer == address(0)) {\n            revert NotMigrated();\n        }\n        uint256 currentProtocolVersion = s.protocolVersion;\n        if (currentProtocolVersion != protocolVersion) {\n            revert OutdatedProtocolVersion(protocolVersion, currentProtocolVersion);\n        }\n\n        s.settlementLayer = address(0);\n    }\n\n    /// @notice Returns the commitment for a chain.\n    /// @dev Note, that this is a getter method helpful for debugging and should not be relied upon by clients.\n    /// @return commitment The commitment for the chain.\n    function prepareChainCommitment() public view returns (ZKChainCommitment memory commitment) {\n        if (_isPriorityQueueActive()) {\n            revert PriorityQueueNotReady();\n        }\n\n        commitment.totalBatchesCommitted = s.totalBatchesCommitted;\n        commitment.totalBatchesVerified = s.totalBatchesVerified;\n        commitment.totalBatchesExecuted = s.totalBatchesExecuted;\n        commitment.l2SystemContractsUpgradeBatchNumber = s.l2SystemContractsUpgradeBatchNumber;\n        commitment.l2SystemContractsUpgradeTxHash = s.l2SystemContractsUpgradeTxHash;\n        commitment.priorityTree = s.priorityTree.getCommitment();\n        commitment.isPermanentRollup = s.isPermanentRollup;\n\n        // just in case\n        if (commitment.totalBatchesExecuted > commitment.totalBatchesVerified) {\n            revert ExecutedIsNotConsistentWithVerified(\n                commitment.totalBatchesExecuted,\n                commitment.totalBatchesVerified\n            );\n        }\n        if (commitment.totalBatchesVerified > commitment.totalBatchesCommitted) {\n            revert VerifiedIsNotConsistentWithCommitted(\n                commitment.totalBatchesVerified,\n                commitment.totalBatchesCommitted\n            );\n        }\n\n        uint256 blocksToRemember = commitment.totalBatchesCommitted - commitment.totalBatchesExecuted + 1;\n\n        bytes32[] memory batchHashes = new bytes32[](blocksToRemember);\n\n        for (uint256 i = 0; i < blocksToRemember; ++i) {\n            unchecked {\n                batchHashes[i] = s.storedBatchHashes[commitment.totalBatchesExecuted + i];\n            }\n        }\n\n        commitment.batchHashes = batchHashes;\n    }\n}\n"
      },
      "contracts/state-transition/chain-deps/facets/Executor.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {ZKChainBase} from \"./ZKChainBase.sol\";\nimport {IBridgehub} from \"../../../bridgehub/IBridgehub.sol\";\nimport {IMessageRoot} from \"../../../bridgehub/IMessageRoot.sol\";\nimport {COMMIT_TIMESTAMP_NOT_OLDER, COMMIT_TIMESTAMP_APPROXIMATION_DELTA, EMPTY_STRING_KECCAK, L2_TO_L1_LOG_SERIALIZE_SIZE, MAX_L2_TO_L1_LOGS_COMMITMENT_BYTES, PACKED_L2_BLOCK_TIMESTAMP_MASK, PUBLIC_INPUT_SHIFT} from \"../../../common/Config.sol\";\nimport {IExecutor, L2_LOG_ADDRESS_OFFSET, L2_LOG_KEY_OFFSET, L2_LOG_VALUE_OFFSET, SystemLogKey, LogProcessingOutput, TOTAL_BLOBS_IN_COMMITMENT} from \"../../chain-interfaces/IExecutor.sol\";\nimport {PriorityQueue, PriorityOperation} from \"../../libraries/PriorityQueue.sol\";\nimport {BatchDecoder} from \"../../libraries/BatchDecoder.sol\";\nimport {UncheckedMath} from \"../../../common/libraries/UncheckedMath.sol\";\nimport {UnsafeBytes} from \"../../../common/libraries/UnsafeBytes.sol\";\nimport {L2_BOOTLOADER_ADDRESS, L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR, L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR} from \"../../../common/L2ContractAddresses.sol\";\nimport {IChainTypeManager} from \"../../IChainTypeManager.sol\";\nimport {PriorityTree, PriorityOpsBatchInfo} from \"../../libraries/PriorityTree.sol\";\nimport {IL1DAValidator, L1DAValidatorOutput} from \"../../chain-interfaces/IL1DAValidator.sol\";\nimport {InvalidSystemLogsLength, MissingSystemLogs, BatchNumberMismatch, TimeNotReached, ValueMismatch, HashMismatch, NonIncreasingTimestamp, TimestampError, InvalidLogSender, TxHashMismatch, UnexpectedSystemLog, LogAlreadyProcessed, InvalidProtocolVersion, CanOnlyProcessOneBatch, BatchHashMismatch, UpgradeBatchNumberIsNotZero, NonSequentialBatch, CantExecuteUnprovenBatches, SystemLogsSizeTooBig, InvalidNumberOfBlobs, VerifiedBatchesExceedsCommittedBatches, InvalidProof, RevertedBatchNotAfterNewLastBatch, CantRevertExecutedBatch, L2TimestampTooBig, PriorityOperationsRollingHashMismatch} from \"../../../common/L1ContractErrors.sol\";\nimport {InvalidBatchesDataLength, MismatchL2DAValidator, MismatchNumberOfLayer1Txs, PriorityOpsDataLeftPathLengthIsNotZero, PriorityOpsDataRightPathLengthIsNotZero, PriorityOpsDataItemHashesLengthIsNotZero} from \"../../L1StateTransitionErrors.sol\";\n\n// While formally the following import is not used, it is needed to inherit documentation from it\nimport {IZKChainBase} from \"../../chain-interfaces/IZKChainBase.sol\";\n\n/// @title ZK chain Executor contract capable of processing events emitted in the ZK chain protocol.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract ExecutorFacet is ZKChainBase, IExecutor {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n    using PriorityTree for PriorityTree.Tree;\n\n    /// @inheritdoc IZKChainBase\n    string public constant override getName = \"ExecutorFacet\";\n\n    /// @notice The chain id of L1. This contract can be deployed on multiple layers, but this value is still equal to the\n    /// L1 that is at the most base layer.\n    uint256 internal immutable L1_CHAIN_ID;\n\n    constructor(uint256 _l1ChainId) {\n        L1_CHAIN_ID = _l1ChainId;\n    }\n\n    /// @dev Process one batch commit using the previous batch StoredBatchInfo\n    /// @dev returns new batch StoredBatchInfo\n    /// @notice Does not change storage\n    function _commitOneBatch(\n        StoredBatchInfo memory _previousBatch,\n        CommitBatchInfo memory _newBatch,\n        bytes32 _expectedSystemContractUpgradeTxHash\n    ) internal returns (StoredBatchInfo memory) {\n        // only commit next batch\n        if (_newBatch.batchNumber != _previousBatch.batchNumber + 1) {\n            revert BatchNumberMismatch(_previousBatch.batchNumber + 1, _newBatch.batchNumber);\n        }\n\n        // Check that batch contains all meta information for L2 logs.\n        // Get the chained hash of priority transaction hashes.\n        LogProcessingOutput memory logOutput = _processL2Logs(_newBatch, _expectedSystemContractUpgradeTxHash);\n\n        L1DAValidatorOutput memory daOutput = IL1DAValidator(s.l1DAValidator).checkDA({\n            _chainId: s.chainId,\n            _batchNumber: uint256(_newBatch.batchNumber),\n            _l2DAValidatorOutputHash: logOutput.l2DAValidatorOutputHash,\n            _operatorDAInput: _newBatch.operatorDAInput,\n            _maxBlobsSupported: TOTAL_BLOBS_IN_COMMITMENT\n        });\n\n        if (_previousBatch.batchHash != logOutput.previousBatchHash) {\n            revert HashMismatch(logOutput.previousBatchHash, _previousBatch.batchHash);\n        }\n        // Check that the priority operation hash in the L2 logs is as expected\n        if (logOutput.chainedPriorityTxsHash != _newBatch.priorityOperationsHash) {\n            revert HashMismatch(logOutput.chainedPriorityTxsHash, _newBatch.priorityOperationsHash);\n        }\n        // Check that the number of processed priority operations is as expected\n        if (logOutput.numberOfLayer1Txs != _newBatch.numberOfLayer1Txs) {\n            revert ValueMismatch(logOutput.numberOfLayer1Txs, _newBatch.numberOfLayer1Txs);\n        }\n\n        // Check the timestamp of the new batch\n        _verifyBatchTimestamp(logOutput.packedBatchAndL2BlockTimestamp, _newBatch.timestamp, _previousBatch.timestamp);\n\n        // Create batch commitment for the proof verification\n        bytes32 commitment = _createBatchCommitment(\n            _newBatch,\n            daOutput.stateDiffHash,\n            daOutput.blobsOpeningCommitments,\n            daOutput.blobsLinearHashes\n        );\n\n        return\n            StoredBatchInfo({\n                batchNumber: _newBatch.batchNumber,\n                batchHash: _newBatch.newStateRoot,\n                indexRepeatedStorageChanges: _newBatch.indexRepeatedStorageChanges,\n                numberOfLayer1Txs: _newBatch.numberOfLayer1Txs,\n                priorityOperationsHash: _newBatch.priorityOperationsHash,\n                l2LogsTreeRoot: logOutput.l2LogsTreeRoot,\n                timestamp: _newBatch.timestamp,\n                commitment: commitment\n            });\n    }\n\n    /// @notice checks that the timestamps of both the new batch and the new L2 block are correct.\n    /// @param _packedBatchAndL2BlockTimestamp - packed batch and L2 block timestamp in a format of batchTimestamp * 2**128 + l2BatchTimestamp\n    /// @param _expectedBatchTimestamp - expected batch timestamp\n    /// @param _previousBatchTimestamp - the timestamp of the previous batch\n    function _verifyBatchTimestamp(\n        uint256 _packedBatchAndL2BlockTimestamp,\n        uint256 _expectedBatchTimestamp,\n        uint256 _previousBatchTimestamp\n    ) internal view {\n        // Check that the timestamp that came from the system context is expected\n        uint256 batchTimestamp = _packedBatchAndL2BlockTimestamp >> 128;\n        if (batchTimestamp != _expectedBatchTimestamp) {\n            revert TimestampError();\n        }\n\n        // While the fact that _previousBatchTimestamp < batchTimestamp is already checked on L2,\n        // we double check it here for clarity\n        if (_previousBatchTimestamp >= batchTimestamp) {\n            revert NonIncreasingTimestamp();\n        }\n\n        uint256 lastL2BlockTimestamp = _packedBatchAndL2BlockTimestamp & PACKED_L2_BLOCK_TIMESTAMP_MASK;\n\n        // All L2 blocks have timestamps within the range of [batchTimestamp, lastL2BlockTimestamp].\n        // So here we need to only double check that:\n        // - The timestamp of the batch is not too small.\n        // - The timestamp of the last L2 block is not too big.\n        // New batch timestamp is too small\n        if (block.timestamp - COMMIT_TIMESTAMP_NOT_OLDER > batchTimestamp) {\n            revert TimeNotReached(batchTimestamp, block.timestamp - COMMIT_TIMESTAMP_NOT_OLDER);\n        }\n        // The last L2 block timestamp is too big\n        if (lastL2BlockTimestamp > block.timestamp + COMMIT_TIMESTAMP_APPROXIMATION_DELTA) {\n            revert L2TimestampTooBig();\n        }\n    }\n\n    /// @dev Check that L2 logs are proper and batch contain all meta information for them\n    /// @dev The logs processed here should line up such that only one log for each key from the\n    ///      SystemLogKey enum in Constants.sol is processed per new batch.\n    /// @dev Data returned from here will be used to form the batch commitment.\n    function _processL2Logs(\n        CommitBatchInfo memory _newBatch,\n        bytes32 _expectedSystemContractUpgradeTxHash\n    ) internal view returns (LogProcessingOutput memory logOutput) {\n        // Copy L2 to L1 logs into memory.\n        bytes memory emittedL2Logs = _newBatch.systemLogs;\n\n        // Used as bitmap to set/check log processing happens exactly once.\n        // See SystemLogKey enum in Constants.sol for ordering.\n        uint256 processedLogs = 0;\n\n        // linear traversal of the logs\n        uint256 logsLength = emittedL2Logs.length;\n\n        if (logsLength % L2_TO_L1_LOG_SERIALIZE_SIZE != 0) {\n            revert InvalidSystemLogsLength();\n        }\n\n        for (uint256 i = 0; i < logsLength; i = i.uncheckedAdd(L2_TO_L1_LOG_SERIALIZE_SIZE)) {\n            // Extract the values to be compared to/used such as the log sender, key, and value\n            // slither-disable-next-line unused-return\n            (address logSender, ) = UnsafeBytes.readAddress(emittedL2Logs, i + L2_LOG_ADDRESS_OFFSET);\n            // slither-disable-next-line unused-return\n            (uint256 logKey, ) = UnsafeBytes.readUint256(emittedL2Logs, i + L2_LOG_KEY_OFFSET);\n            // slither-disable-next-line unused-return\n            (bytes32 logValue, ) = UnsafeBytes.readBytes32(emittedL2Logs, i + L2_LOG_VALUE_OFFSET);\n\n            // Ensure that the log hasn't been processed already\n            if (_checkBit(processedLogs, uint8(logKey))) {\n                revert LogAlreadyProcessed(uint8(logKey));\n            }\n            processedLogs = _setBit(processedLogs, uint8(logKey));\n\n            // Need to check that each log was sent by the correct address.\n            if (logKey == uint256(SystemLogKey.L2_TO_L1_LOGS_TREE_ROOT_KEY)) {\n                if (logSender != L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR) {\n                    revert InvalidLogSender(logSender, logKey);\n                }\n                logOutput.l2LogsTreeRoot = logValue;\n            } else if (logKey == uint256(SystemLogKey.PACKED_BATCH_AND_L2_BLOCK_TIMESTAMP_KEY)) {\n                if (logSender != L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR) {\n                    revert InvalidLogSender(logSender, logKey);\n                }\n                logOutput.packedBatchAndL2BlockTimestamp = uint256(logValue);\n            } else if (logKey == uint256(SystemLogKey.PREV_BATCH_HASH_KEY)) {\n                if (logSender != L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR) {\n                    revert InvalidLogSender(logSender, logKey);\n                }\n                logOutput.previousBatchHash = logValue;\n            } else if (logKey == uint256(SystemLogKey.CHAINED_PRIORITY_TXN_HASH_KEY)) {\n                if (logSender != L2_BOOTLOADER_ADDRESS) {\n                    revert InvalidLogSender(logSender, logKey);\n                }\n                logOutput.chainedPriorityTxsHash = logValue;\n            } else if (logKey == uint256(SystemLogKey.NUMBER_OF_LAYER_1_TXS_KEY)) {\n                if (logSender != L2_BOOTLOADER_ADDRESS) {\n                    revert InvalidLogSender(logSender, logKey);\n                }\n                logOutput.numberOfLayer1Txs = uint256(logValue);\n            } else if (logKey == uint256(SystemLogKey.USED_L2_DA_VALIDATOR_ADDRESS_KEY)) {\n                if (logSender != L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR) {\n                    revert InvalidLogSender(logSender, logKey);\n                }\n                if (s.l2DAValidator != address(uint160(uint256(logValue)))) {\n                    revert MismatchL2DAValidator();\n                }\n            } else if (logKey == uint256(SystemLogKey.L2_DA_VALIDATOR_OUTPUT_HASH_KEY)) {\n                if (logSender != L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR) {\n                    revert InvalidLogSender(logSender, logKey);\n                }\n                logOutput.l2DAValidatorOutputHash = logValue;\n            } else if (logKey == uint256(SystemLogKey.EXPECTED_SYSTEM_CONTRACT_UPGRADE_TX_HASH_KEY)) {\n                if (logSender != L2_BOOTLOADER_ADDRESS) {\n                    revert InvalidLogSender(logSender, logKey);\n                }\n                if (_expectedSystemContractUpgradeTxHash != logValue) {\n                    revert TxHashMismatch();\n                }\n            } else if (logKey > uint256(SystemLogKey.EXPECTED_SYSTEM_CONTRACT_UPGRADE_TX_HASH_KEY)) {\n                revert UnexpectedSystemLog(logKey);\n            }\n        }\n\n        // We only require 7 logs to be checked, the 8th is if we are expecting a protocol upgrade\n        // Without the protocol upgrade we expect 7 logs: 2^7 - 1 = 127\n        // With the protocol upgrade we expect 8 logs: 2^8 - 1 = 255\n        if (_expectedSystemContractUpgradeTxHash == bytes32(0)) {\n            if (processedLogs != 127) {\n                revert MissingSystemLogs(127, processedLogs);\n            }\n        } else if (processedLogs != 255) {\n            revert MissingSystemLogs(255, processedLogs);\n        }\n    }\n\n    /// @inheritdoc IExecutor\n    function commitBatchesSharedBridge(\n        uint256, // _chainId\n        uint256 _processFrom,\n        uint256 _processTo,\n        bytes calldata _commitData\n    ) external nonReentrant onlyValidator onlySettlementLayer {\n        // check that we have the right protocol version\n        // three comments:\n        // 1. A chain has to keep their protocol version up to date, as processing a block requires the latest or previous protocol version\n        // to solve this we will need to add the feature to create batches with only the protocol upgrade tx, without any other txs.\n        // 2. A chain might become out of sync if it launches while we are in the middle of a protocol upgrade. This would mean they cannot process their genesis upgrade\n        // as their protocolversion would be outdated, and they also cannot process the protocol upgrade tx as they have a pending upgrade.\n        // 3. The protocol upgrade is increased in the BaseZkSyncUpgrade, in the executor only the systemContractsUpgradeTxHash is checked\n        if (!IChainTypeManager(s.chainTypeManager).protocolVersionIsActive(s.protocolVersion)) {\n            revert InvalidProtocolVersion();\n        }\n        (StoredBatchInfo memory lastCommittedBatchData, CommitBatchInfo[] memory newBatchesData) = BatchDecoder\n            .decodeAndCheckCommitData(_commitData, _processFrom, _processTo);\n        // With the new changes for EIP-4844, namely the restriction on number of blobs per block, we only allow for a single batch to be committed at a time.\n        // Note: Don't need to check that `_processFrom` == `_processTo` because there is only one batch,\n        // and so the range checked in the `decodeAndCheckCommitData` is enough.\n        if (newBatchesData.length != 1) {\n            revert CanOnlyProcessOneBatch();\n        }\n        // Check that we commit batches after last committed batch\n        if (s.storedBatchHashes[s.totalBatchesCommitted] != _hashStoredBatchInfo(lastCommittedBatchData)) {\n            // incorrect previous batch data\n            revert BatchHashMismatch(\n                s.storedBatchHashes[s.totalBatchesCommitted],\n                _hashStoredBatchInfo(lastCommittedBatchData)\n            );\n        }\n\n        bytes32 systemContractsUpgradeTxHash = s.l2SystemContractsUpgradeTxHash;\n        // Upgrades are rarely done so we optimize a case with no active system contracts upgrade.\n        if (systemContractsUpgradeTxHash == bytes32(0) || s.l2SystemContractsUpgradeBatchNumber != 0) {\n            _commitBatchesWithoutSystemContractsUpgrade(lastCommittedBatchData, newBatchesData);\n        } else {\n            _commitBatchesWithSystemContractsUpgrade(\n                lastCommittedBatchData,\n                newBatchesData,\n                systemContractsUpgradeTxHash\n            );\n        }\n\n        s.totalBatchesCommitted = s.totalBatchesCommitted + newBatchesData.length;\n    }\n\n    /// @dev Commits new batches without any system contracts upgrade.\n    /// @param _lastCommittedBatchData The data of the last committed batch.\n    /// @param _newBatchesData An array of batch data that needs to be committed.\n    function _commitBatchesWithoutSystemContractsUpgrade(\n        StoredBatchInfo memory _lastCommittedBatchData,\n        CommitBatchInfo[] memory _newBatchesData\n    ) internal {\n        // We disable this check because calldata array length is cheap.\n        // solhint-disable-next-line gas-length-in-loops\n        for (uint256 i = 0; i < _newBatchesData.length; i = i.uncheckedInc()) {\n            _lastCommittedBatchData = _commitOneBatch(_lastCommittedBatchData, _newBatchesData[i], bytes32(0));\n\n            s.storedBatchHashes[_lastCommittedBatchData.batchNumber] = _hashStoredBatchInfo(_lastCommittedBatchData);\n            emit BlockCommit(\n                _lastCommittedBatchData.batchNumber,\n                _lastCommittedBatchData.batchHash,\n                _lastCommittedBatchData.commitment\n            );\n        }\n    }\n\n    /// @dev Commits new batches with a system contracts upgrade transaction.\n    /// @param _lastCommittedBatchData The data of the last committed batch.\n    /// @param _newBatchesData An array of batch data that needs to be committed.\n    /// @param _systemContractUpgradeTxHash The transaction hash of the system contract upgrade.\n    function _commitBatchesWithSystemContractsUpgrade(\n        StoredBatchInfo memory _lastCommittedBatchData,\n        CommitBatchInfo[] memory _newBatchesData,\n        bytes32 _systemContractUpgradeTxHash\n    ) internal {\n        // The system contract upgrade is designed to be executed atomically with the new bootloader, a default account,\n        // ZKP verifier, and other system parameters. Hence, we ensure that the upgrade transaction is\n        // carried out within the first batch committed after the upgrade.\n\n        // While the logic of the contract ensures that the s.l2SystemContractsUpgradeBatchNumber is 0 when this function is called,\n        // this check is added just in case. Since it is a hot read, it does not incur noticeable gas cost.\n        if (s.l2SystemContractsUpgradeBatchNumber != 0) {\n            revert UpgradeBatchNumberIsNotZero();\n        }\n\n        // Save the batch number where the upgrade transaction was executed.\n        s.l2SystemContractsUpgradeBatchNumber = _newBatchesData[0].batchNumber;\n\n        // We disable this check because calldata array length is cheap.\n        // solhint-disable-next-line gas-length-in-loops\n        for (uint256 i = 0; i < _newBatchesData.length; i = i.uncheckedInc()) {\n            // The upgrade transaction must only be included in the first batch.\n            bytes32 expectedUpgradeTxHash = i == 0 ? _systemContractUpgradeTxHash : bytes32(0);\n            _lastCommittedBatchData = _commitOneBatch(\n                _lastCommittedBatchData,\n                _newBatchesData[i],\n                expectedUpgradeTxHash\n            );\n\n            s.storedBatchHashes[_lastCommittedBatchData.batchNumber] = _hashStoredBatchInfo(_lastCommittedBatchData);\n            emit BlockCommit(\n                _lastCommittedBatchData.batchNumber,\n                _lastCommittedBatchData.batchHash,\n                _lastCommittedBatchData.commitment\n            );\n        }\n    }\n\n    /// @dev Pops the priority operations from the priority queue and returns a rolling hash of operations\n    function _collectOperationsFromPriorityQueue(uint256 _nPriorityOps) internal returns (bytes32 concatHash) {\n        concatHash = EMPTY_STRING_KECCAK;\n\n        for (uint256 i = 0; i < _nPriorityOps; i = i.uncheckedInc()) {\n            PriorityOperation memory priorityOp = s.priorityQueue.popFront();\n            concatHash = keccak256(abi.encode(concatHash, priorityOp.canonicalTxHash));\n        }\n\n        s.priorityTree.skipUntil(s.priorityQueue.getFirstUnprocessedPriorityTx());\n    }\n\n    function _rollingHash(bytes32[] memory _hashes) internal pure returns (bytes32) {\n        bytes32 hash = EMPTY_STRING_KECCAK;\n        uint256 nHashes = _hashes.length;\n        for (uint256 i = 0; i < nHashes; i = i.uncheckedInc()) {\n            hash = keccak256(abi.encode(hash, _hashes[i]));\n        }\n        return hash;\n    }\n\n    /// @dev Checks that the data of the batch is correct and can be executed\n    /// @dev Verifies that batch number, batch hash and priority operations hash are correct\n    function _checkBatchData(\n        StoredBatchInfo memory _storedBatch,\n        uint256 _executedBatchIdx,\n        bytes32 _priorityOperationsHash\n    ) internal view {\n        uint256 currentBatchNumber = _storedBatch.batchNumber;\n        if (currentBatchNumber != s.totalBatchesExecuted + _executedBatchIdx + 1) {\n            revert NonSequentialBatch();\n        }\n        if (_hashStoredBatchInfo(_storedBatch) != s.storedBatchHashes[currentBatchNumber]) {\n            revert BatchHashMismatch(s.storedBatchHashes[currentBatchNumber], _hashStoredBatchInfo(_storedBatch));\n        }\n        if (_priorityOperationsHash != _storedBatch.priorityOperationsHash) {\n            revert PriorityOperationsRollingHashMismatch();\n        }\n    }\n\n    /// @dev Executes one batch\n    /// @dev 1. Processes all pending operations (Complete priority requests)\n    /// @dev 2. Finalizes batch on Ethereum\n    /// @dev _executedBatchIdx is an index in the array of the batches that we want to execute together\n    function _executeOneBatch(StoredBatchInfo memory _storedBatch, uint256 _executedBatchIdx) internal {\n        bytes32 priorityOperationsHash = _collectOperationsFromPriorityQueue(_storedBatch.numberOfLayer1Txs);\n        _checkBatchData(_storedBatch, _executedBatchIdx, priorityOperationsHash);\n\n        uint256 currentBatchNumber = _storedBatch.batchNumber;\n\n        // Save root hash of L2 -> L1 logs tree\n        s.l2LogsRootHashes[currentBatchNumber] = _storedBatch.l2LogsTreeRoot;\n        _appendMessageRoot(currentBatchNumber, _storedBatch.l2LogsTreeRoot);\n    }\n\n    /// @notice Executes one batch\n    /// @dev 1. Processes all pending operations (Complete priority requests)\n    /// @dev 2. Finalizes batch\n    /// @dev _executedBatchIdx is an index in the array of the batches that we want to execute together\n    function _executeOneBatch(\n        StoredBatchInfo memory _storedBatch,\n        PriorityOpsBatchInfo memory _priorityOpsData,\n        uint256 _executedBatchIdx\n    ) internal {\n        if (_priorityOpsData.itemHashes.length != _storedBatch.numberOfLayer1Txs) {\n            revert MismatchNumberOfLayer1Txs(_priorityOpsData.itemHashes.length, _storedBatch.numberOfLayer1Txs);\n        }\n        bytes32 priorityOperationsHash = _rollingHash(_priorityOpsData.itemHashes);\n        _checkBatchData(_storedBatch, _executedBatchIdx, priorityOperationsHash);\n        s.priorityTree.processBatch(_priorityOpsData);\n\n        uint256 currentBatchNumber = _storedBatch.batchNumber;\n\n        // Save root hash of L2 -> L1 logs tree\n        s.l2LogsRootHashes[currentBatchNumber] = _storedBatch.l2LogsTreeRoot;\n        _appendMessageRoot(currentBatchNumber, _storedBatch.l2LogsTreeRoot);\n    }\n\n    /// @notice Appends the batch message root to the global message.\n    /// @param _batchNumber The number of the batch\n    /// @param _messageRoot The root of the merkle tree of the messages to L1.\n    /// @dev The logic of this function depends on the settlement layer as we support\n    /// message root aggregation only on non-L1 settlement layers for ease for migration.\n    function _appendMessageRoot(uint256 _batchNumber, bytes32 _messageRoot) internal {\n        // During migration to the new protocol version, there will be a period when\n        // the bridgehub does not yet provide the `messageRoot` functionality.\n        // To ease up the migration, we never append messages to message root on L1.\n        if (block.chainid != L1_CHAIN_ID) {\n            // Once the batch is executed, we include its message to the message root.\n            IMessageRoot messageRootContract = IBridgehub(s.bridgehub).messageRoot();\n            messageRootContract.addChainBatchRoot(s.chainId, _batchNumber, _messageRoot);\n        }\n    }\n\n    /// @inheritdoc IExecutor\n    function executeBatchesSharedBridge(\n        uint256, // _chainId\n        uint256 _processFrom,\n        uint256 _processTo,\n        bytes calldata _executeData\n    ) external nonReentrant onlyValidator onlySettlementLayer {\n        (StoredBatchInfo[] memory batchesData, PriorityOpsBatchInfo[] memory priorityOpsData) = BatchDecoder\n            .decodeAndCheckExecuteData(_executeData, _processFrom, _processTo);\n        uint256 nBatches = batchesData.length;\n        if (batchesData.length != priorityOpsData.length) {\n            revert InvalidBatchesDataLength(batchesData.length, priorityOpsData.length);\n        }\n\n        for (uint256 i = 0; i < nBatches; i = i.uncheckedInc()) {\n            if (_isPriorityQueueActive()) {\n                if (priorityOpsData[i].leftPath.length != 0) {\n                    revert PriorityOpsDataLeftPathLengthIsNotZero();\n                }\n                if (priorityOpsData[i].rightPath.length != 0) {\n                    revert PriorityOpsDataRightPathLengthIsNotZero();\n                }\n                if (priorityOpsData[i].itemHashes.length != 0) {\n                    revert PriorityOpsDataItemHashesLengthIsNotZero();\n                }\n\n                _executeOneBatch(batchesData[i], i);\n            } else {\n                _executeOneBatch(batchesData[i], priorityOpsData[i], i);\n            }\n            emit BlockExecution(batchesData[i].batchNumber, batchesData[i].batchHash, batchesData[i].commitment);\n        }\n\n        uint256 newTotalBatchesExecuted = s.totalBatchesExecuted + nBatches;\n        s.totalBatchesExecuted = newTotalBatchesExecuted;\n        if (newTotalBatchesExecuted > s.totalBatchesVerified) {\n            revert CantExecuteUnprovenBatches();\n        }\n\n        uint256 batchWhenUpgradeHappened = s.l2SystemContractsUpgradeBatchNumber;\n        if (batchWhenUpgradeHappened != 0 && batchWhenUpgradeHappened <= newTotalBatchesExecuted) {\n            delete s.l2SystemContractsUpgradeTxHash;\n            delete s.l2SystemContractsUpgradeBatchNumber;\n        }\n    }\n\n    /// @inheritdoc IExecutor\n    function proveBatchesSharedBridge(\n        uint256, // _chainId\n        uint256 _processBatchFrom,\n        uint256 _processBatchTo,\n        bytes calldata _proofData\n    ) external nonReentrant onlyValidator onlySettlementLayer {\n        (\n            StoredBatchInfo memory prevBatch,\n            StoredBatchInfo[] memory committedBatches,\n            uint256[] memory proof\n        ) = BatchDecoder.decodeAndCheckProofData(_proofData, _processBatchFrom, _processBatchTo);\n\n        // Save the variables into the stack to save gas on reading them later\n        uint256 currentTotalBatchesVerified = s.totalBatchesVerified;\n        uint256 committedBatchesLength = committedBatches.length;\n\n        // Initialize the array, that will be used as public input to the ZKP\n        uint256[] memory proofPublicInput = new uint256[](committedBatchesLength);\n\n        // Check that the batch passed by the validator is indeed the first unverified batch\n        if (_hashStoredBatchInfo(prevBatch) != s.storedBatchHashes[currentTotalBatchesVerified]) {\n            revert BatchHashMismatch(s.storedBatchHashes[currentTotalBatchesVerified], _hashStoredBatchInfo(prevBatch));\n        }\n\n        bytes32 prevBatchCommitment = prevBatch.commitment;\n        for (uint256 i = 0; i < committedBatchesLength; i = i.uncheckedInc()) {\n            currentTotalBatchesVerified = currentTotalBatchesVerified.uncheckedInc();\n            if (_hashStoredBatchInfo(committedBatches[i]) != s.storedBatchHashes[currentTotalBatchesVerified]) {\n                revert BatchHashMismatch(\n                    s.storedBatchHashes[currentTotalBatchesVerified],\n                    _hashStoredBatchInfo(committedBatches[i])\n                );\n            }\n\n            bytes32 currentBatchCommitment = committedBatches[i].commitment;\n            proofPublicInput[i] = _getBatchProofPublicInput(prevBatchCommitment, currentBatchCommitment);\n\n            prevBatchCommitment = currentBatchCommitment;\n        }\n        if (currentTotalBatchesVerified > s.totalBatchesCommitted) {\n            revert VerifiedBatchesExceedsCommittedBatches();\n        }\n\n        _verifyProof(proofPublicInput, proof);\n\n        emit BlocksVerification(s.totalBatchesVerified, currentTotalBatchesVerified);\n        s.totalBatchesVerified = currentTotalBatchesVerified;\n    }\n\n    function _verifyProof(uint256[] memory proofPublicInput, uint256[] memory _proof) internal view {\n        // We can only process 1 batch proof at a time.\n        if (proofPublicInput.length != 1) {\n            revert CanOnlyProcessOneBatch();\n        }\n\n        bool successVerifyProof = s.verifier.verify(proofPublicInput, _proof);\n        if (!successVerifyProof) {\n            revert InvalidProof();\n        }\n    }\n\n    /// @dev Gets zk proof public input\n    function _getBatchProofPublicInput(\n        bytes32 _prevBatchCommitment,\n        bytes32 _currentBatchCommitment\n    ) internal pure returns (uint256) {\n        return\n            uint256(keccak256(abi.encodePacked(_prevBatchCommitment, _currentBatchCommitment))) >> PUBLIC_INPUT_SHIFT;\n    }\n\n    /// @inheritdoc IExecutor\n    function revertBatchesSharedBridge(\n        uint256,\n        uint256 _newLastBatch\n    ) external nonReentrant onlyValidatorOrChainTypeManager {\n        _revertBatches(_newLastBatch);\n    }\n\n    function _revertBatches(uint256 _newLastBatch) internal onlySettlementLayer {\n        if (s.totalBatchesCommitted <= _newLastBatch) {\n            revert RevertedBatchNotAfterNewLastBatch();\n        }\n        if (_newLastBatch < s.totalBatchesExecuted) {\n            revert CantRevertExecutedBatch();\n        }\n\n        if (_newLastBatch < s.totalBatchesVerified) {\n            s.totalBatchesVerified = _newLastBatch;\n        }\n        s.totalBatchesCommitted = _newLastBatch;\n\n        // Reset the batch number of the executed system contracts upgrade transaction if the batch\n        // where the system contracts upgrade was committed is among the reverted batches.\n        if (s.l2SystemContractsUpgradeBatchNumber > _newLastBatch) {\n            delete s.l2SystemContractsUpgradeBatchNumber;\n        }\n\n        emit BlocksRevert(s.totalBatchesCommitted, s.totalBatchesVerified, s.totalBatchesExecuted);\n    }\n\n    /// @dev Creates batch commitment from its data\n    function _createBatchCommitment(\n        CommitBatchInfo memory _newBatchData,\n        bytes32 _stateDiffHash,\n        bytes32[] memory _blobCommitments,\n        bytes32[] memory _blobHashes\n    ) internal view returns (bytes32) {\n        bytes32 passThroughDataHash = keccak256(_batchPassThroughData(_newBatchData));\n        bytes32 metadataHash = keccak256(_batchMetaParameters());\n        bytes32 auxiliaryOutputHash = keccak256(\n            _batchAuxiliaryOutput(_newBatchData, _stateDiffHash, _blobCommitments, _blobHashes)\n        );\n\n        return keccak256(abi.encode(passThroughDataHash, metadataHash, auxiliaryOutputHash));\n    }\n\n    function _batchPassThroughData(CommitBatchInfo memory _batch) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                // solhint-disable-next-line func-named-parameters\n                _batch.indexRepeatedStorageChanges,\n                _batch.newStateRoot,\n                uint64(0), // index repeated storage changes in zkPorter\n                bytes32(0) // zkPorter batch hash\n            );\n    }\n\n    function _batchMetaParameters() internal view returns (bytes memory) {\n        bytes32 l2DefaultAccountBytecodeHash = s.l2DefaultAccountBytecodeHash;\n        return\n            abi.encodePacked(\n                s.zkPorterIsAvailable,\n                s.l2BootloaderBytecodeHash,\n                l2DefaultAccountBytecodeHash,\n                // VM 1.5.0 requires us to pass the EVM simulator code hash. For now it is the same as the default account.\n                l2DefaultAccountBytecodeHash\n            );\n    }\n\n    function _batchAuxiliaryOutput(\n        CommitBatchInfo memory _batch,\n        bytes32 _stateDiffHash,\n        bytes32[] memory _blobCommitments,\n        bytes32[] memory _blobHashes\n    ) internal pure returns (bytes memory) {\n        if (_batch.systemLogs.length > MAX_L2_TO_L1_LOGS_COMMITMENT_BYTES) {\n            revert SystemLogsSizeTooBig();\n        }\n\n        bytes32 l2ToL1LogsHash = keccak256(_batch.systemLogs);\n\n        return\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(\n                l2ToL1LogsHash,\n                _stateDiffHash,\n                _batch.bootloaderHeapInitialContentsHash,\n                _batch.eventsQueueStateHash,\n                _encodeBlobAuxiliaryOutput(_blobCommitments, _blobHashes)\n            );\n    }\n\n    /// @dev Encodes the commitment to blobs to be used in the auxiliary output of the batch commitment\n    /// @param _blobCommitments - the commitments to the blobs\n    /// @param _blobHashes - the hashes of the blobs\n    /// @param blobAuxOutputWords - The circuit commitment to the blobs split into 32-byte words\n    function _encodeBlobAuxiliaryOutput(\n        bytes32[] memory _blobCommitments,\n        bytes32[] memory _blobHashes\n    ) internal pure returns (bytes32[] memory blobAuxOutputWords) {\n        // These invariants should be checked by the caller of this function, but we double check\n        // just in case.\n        if (_blobCommitments.length != TOTAL_BLOBS_IN_COMMITMENT || _blobHashes.length != TOTAL_BLOBS_IN_COMMITMENT) {\n            revert InvalidNumberOfBlobs(TOTAL_BLOBS_IN_COMMITMENT, _blobCommitments.length, _blobHashes.length);\n        }\n\n        // for each blob we have:\n        // linear hash (hash of preimage from system logs) and\n        // output hash of blob commitments: keccak(versioned hash || opening point || evaluation value)\n        // These values will all be bytes32(0) when we submit pubdata via calldata instead of blobs.\n        //\n        // For now, only up to 6 blobs are supported by the contract, while 16 are required by the circuits.\n        // All the unfilled blobs will have their commitment as 0, including the case when we use only 1 blob.\n\n        blobAuxOutputWords = new bytes32[](2 * TOTAL_BLOBS_IN_COMMITMENT);\n\n        for (uint256 i = 0; i < TOTAL_BLOBS_IN_COMMITMENT; ++i) {\n            blobAuxOutputWords[i * 2] = _blobHashes[i];\n            blobAuxOutputWords[i * 2 + 1] = _blobCommitments[i];\n        }\n    }\n\n    /// @notice Returns the keccak hash of the ABI-encoded StoredBatchInfo\n    function _hashStoredBatchInfo(StoredBatchInfo memory _storedBatchInfo) internal pure returns (bytes32) {\n        return keccak256(abi.encode(_storedBatchInfo));\n    }\n\n    /// @notice Returns true if the bit at index {_index} is 1\n    function _checkBit(uint256 _bitMap, uint8 _index) internal pure returns (bool) {\n        return (_bitMap & (1 << _index)) > 0;\n    }\n\n    /// @notice Sets the given bit in {_num} at index {_index} to 1.\n    function _setBit(uint256 _bitMap, uint8 _index) internal pure returns (uint256) {\n        return _bitMap | (1 << _index);\n    }\n}\n"
      },
      "contracts/state-transition/chain-deps/facets/Getters.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {SafeCast} from \"@openzeppelin/contracts-v4/utils/math/SafeCast.sol\";\n\nimport {ZKChainBase} from \"./ZKChainBase.sol\";\nimport {PubdataPricingMode} from \"../ZKChainStorage.sol\";\nimport {VerifierParams} from \"../../../state-transition/chain-interfaces/IVerifier.sol\";\nimport {Diamond} from \"../../libraries/Diamond.sol\";\nimport {PriorityQueue} from \"../../../state-transition/libraries/PriorityQueue.sol\";\nimport {PriorityTree} from \"../../../state-transition/libraries/PriorityTree.sol\";\nimport {IBridgehub} from \"../../../bridgehub/IBridgehub.sol\";\nimport {UncheckedMath} from \"../../../common/libraries/UncheckedMath.sol\";\nimport {IGetters} from \"../../chain-interfaces/IGetters.sol\";\nimport {ILegacyGetters} from \"../../chain-interfaces/ILegacyGetters.sol\";\nimport {SemVer} from \"../../../common/libraries/SemVer.sol\";\n\n// While formally the following import is not used, it is needed to inherit documentation from it\nimport {IZKChainBase} from \"../../chain-interfaces/IZKChainBase.sol\";\n\n/// @title Getters Contract implements functions for getting contract state from outside the blockchain.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract GettersFacet is ZKChainBase, IGetters, ILegacyGetters {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n    using PriorityTree for PriorityTree.Tree;\n\n    /// @inheritdoc IZKChainBase\n    string public constant override getName = \"GettersFacet\";\n\n    /*//////////////////////////////////////////////////////////////\n                            CUSTOM GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IGetters\n    function getVerifier() external view returns (address) {\n        return address(s.verifier);\n    }\n\n    /// @inheritdoc IGetters\n    function getAdmin() external view returns (address) {\n        return s.admin;\n    }\n\n    /// @inheritdoc IGetters\n    function getPendingAdmin() external view returns (address) {\n        return s.pendingAdmin;\n    }\n\n    /// @inheritdoc IGetters\n    function getBridgehub() external view returns (address) {\n        return s.bridgehub;\n    }\n\n    /// @inheritdoc IGetters\n    function getChainTypeManager() external view returns (address) {\n        return s.chainTypeManager;\n    }\n\n    /// @inheritdoc IGetters\n    function getChainId() external view returns (uint256) {\n        return s.chainId;\n    }\n\n    /// @inheritdoc IGetters\n    function getBaseToken() external view returns (address) {\n        return IBridgehub(s.bridgehub).baseToken(s.chainId);\n    }\n\n    /// @inheritdoc IGetters\n    function getBaseTokenAssetId() external view returns (bytes32) {\n        return s.baseTokenAssetId;\n    }\n\n    /// @inheritdoc IGetters\n    function baseTokenGasPriceMultiplierNominator() external view returns (uint128) {\n        return s.baseTokenGasPriceMultiplierNominator;\n    }\n\n    /// @inheritdoc IGetters\n    function baseTokenGasPriceMultiplierDenominator() external view returns (uint128) {\n        return s.baseTokenGasPriceMultiplierDenominator;\n    }\n\n    /// @inheritdoc IGetters\n    function getTotalBatchesCommitted() external view returns (uint256) {\n        return s.totalBatchesCommitted;\n    }\n\n    /// @inheritdoc IGetters\n    function getTotalBatchesVerified() external view returns (uint256) {\n        return s.totalBatchesVerified;\n    }\n\n    /// @inheritdoc IGetters\n    function getTotalBatchesExecuted() external view returns (uint256) {\n        return s.totalBatchesExecuted;\n    }\n\n    /// @inheritdoc IGetters\n    function getTransactionFilterer() external view returns (address) {\n        return s.transactionFilterer;\n    }\n\n    /// @inheritdoc IGetters\n    function getTotalPriorityTxs() external view returns (uint256) {\n        return _getTotalPriorityTxs();\n    }\n\n    /// @inheritdoc IGetters\n    function getPriorityTreeStartIndex() external view returns (uint256) {\n        return s.priorityTree.startIndex;\n    }\n\n    /// @inheritdoc IGetters\n    function getFirstUnprocessedPriorityTx() external view returns (uint256) {\n        if (_isPriorityQueueActive()) {\n            return s.priorityQueue.getFirstUnprocessedPriorityTx();\n        } else {\n            return s.priorityTree.getFirstUnprocessedPriorityTx();\n        }\n    }\n\n    /// @inheritdoc IGetters\n    function getPriorityTreeRoot() external view returns (bytes32) {\n        return s.priorityTree.getRoot();\n    }\n\n    /// @inheritdoc IGetters\n    function getPriorityQueueSize() external view returns (uint256) {\n        if (_isPriorityQueueActive()) {\n            return s.priorityQueue.getSize();\n        } else {\n            return s.priorityTree.getSize();\n        }\n    }\n\n    /// @inheritdoc IGetters\n    function isPriorityQueueActive() external view returns (bool) {\n        return _isPriorityQueueActive();\n    }\n\n    /// @inheritdoc IGetters\n    function isValidator(address _address) external view returns (bool) {\n        return s.validators[_address];\n    }\n\n    /// @inheritdoc IGetters\n    function l2LogsRootHash(uint256 _batchNumber) external view returns (bytes32) {\n        return s.l2LogsRootHashes[_batchNumber];\n    }\n\n    /// @inheritdoc IGetters\n    function storedBatchHash(uint256 _batchNumber) external view returns (bytes32) {\n        return s.storedBatchHashes[_batchNumber];\n    }\n\n    /// @inheritdoc IGetters\n    function getL2BootloaderBytecodeHash() external view returns (bytes32) {\n        return s.l2BootloaderBytecodeHash;\n    }\n\n    /// @inheritdoc IGetters\n    function getL2DefaultAccountBytecodeHash() external view returns (bytes32) {\n        return s.l2DefaultAccountBytecodeHash;\n    }\n\n    /// @inheritdoc IGetters\n    function getVerifierParams() external view returns (VerifierParams memory) {\n        return s.__DEPRECATED_verifierParams;\n    }\n\n    /// @inheritdoc IGetters\n    function getProtocolVersion() external view returns (uint256) {\n        return s.protocolVersion;\n    }\n\n    /// @inheritdoc IGetters\n    function getSemverProtocolVersion() external view returns (uint32, uint32, uint32) {\n        // slither-disable-next-line unused-return\n        return SemVer.unpackSemVer(SafeCast.toUint96(s.protocolVersion));\n    }\n\n    /// @inheritdoc IGetters\n    function getL2SystemContractsUpgradeTxHash() external view returns (bytes32) {\n        return s.l2SystemContractsUpgradeTxHash;\n    }\n\n    /// @inheritdoc IGetters\n    function getL2SystemContractsUpgradeBatchNumber() external view returns (uint256) {\n        return s.l2SystemContractsUpgradeBatchNumber;\n    }\n\n    /// @inheritdoc IGetters\n    function isDiamondStorageFrozen() external view returns (bool) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n        return ds.isFrozen;\n    }\n\n    /// @inheritdoc IGetters\n    function isFacetFreezable(address _facet) external view returns (bool isFreezable) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n\n        // There is no direct way to get whether the facet address is freezable,\n        // so we get it from one of the selectors that are associated with the facet.\n        uint256 selectorsArrayLen = ds.facetToSelectors[_facet].selectors.length;\n        if (selectorsArrayLen != 0) {\n            bytes4 selector0 = ds.facetToSelectors[_facet].selectors[0];\n            isFreezable = ds.selectorToFacet[selector0].isFreezable;\n        }\n    }\n\n    /// @inheritdoc IGetters\n    function getPriorityTxMaxGasLimit() external view returns (uint256) {\n        return s.priorityTxMaxGasLimit;\n    }\n\n    /// @inheritdoc IGetters\n    function isFunctionFreezable(bytes4 _selector) external view returns (bool) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n        if (ds.selectorToFacet[_selector].facetAddress == address(0)) {\n            // The function does not exist\n            return false;\n        }\n        return ds.selectorToFacet[_selector].isFreezable;\n    }\n\n    /// @inheritdoc IGetters\n    function isEthWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool) {\n        return s.isEthWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex];\n    }\n\n    /// @inheritdoc IGetters\n    function getPubdataPricingMode() external view returns (PubdataPricingMode) {\n        return s.feeParams.pubdataPricingMode;\n    }\n\n    /// @inheritdoc IGetters\n    function getSettlementLayer() external view returns (address) {\n        return s.settlementLayer;\n    }\n\n    function getDAValidatorPair() external view returns (address, address) {\n        return (s.l1DAValidator, s.l2DAValidator);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            DIAMOND LOUPE\n     //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IGetters\n    function facets() external view returns (Facet[] memory result) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n\n        uint256 facetsLen = ds.facets.length;\n        result = new Facet[](facetsLen);\n\n        for (uint256 i = 0; i < facetsLen; i = i.uncheckedInc()) {\n            address facetAddr = ds.facets[i];\n            Diamond.FacetToSelectors memory facetToSelectors = ds.facetToSelectors[facetAddr];\n\n            result[i] = Facet(facetAddr, facetToSelectors.selectors);\n        }\n    }\n\n    /// @inheritdoc IGetters\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n        return ds.facetToSelectors[_facet].selectors;\n    }\n\n    /// @inheritdoc IGetters\n    function facetAddresses() external view returns (address[] memory) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n        return ds.facets;\n    }\n\n    /// @inheritdoc IGetters\n    function facetAddress(bytes4 _selector) external view returns (address) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n        return ds.selectorToFacet[_selector].facetAddress;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPRECATED METHODS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ILegacyGetters\n    function getTotalBlocksCommitted() external view returns (uint256) {\n        return s.totalBatchesCommitted;\n    }\n\n    /// @inheritdoc ILegacyGetters\n    function getTotalBlocksVerified() external view returns (uint256) {\n        return s.totalBatchesVerified;\n    }\n\n    /// @inheritdoc ILegacyGetters\n    function getTotalBlocksExecuted() external view returns (uint256) {\n        return s.totalBatchesExecuted;\n    }\n\n    /// @inheritdoc ILegacyGetters\n    function storedBlockHash(uint256 _batchNumber) external view returns (bytes32) {\n        return s.storedBatchHashes[_batchNumber];\n    }\n\n    /// @inheritdoc ILegacyGetters\n    function getL2SystemContractsUpgradeBlockNumber() external view returns (uint256) {\n        return s.l2SystemContractsUpgradeBatchNumber;\n    }\n}\n"
      },
      "contracts/state-transition/chain-deps/facets/Mailbox.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Math} from \"@openzeppelin/contracts-v4/utils/math/Math.sol\";\n\nimport {IMailbox} from \"../../chain-interfaces/IMailbox.sol\";\nimport {IChainTypeManager} from \"../../IChainTypeManager.sol\";\nimport {IBridgehub} from \"../../../bridgehub/IBridgehub.sol\";\n\nimport {ITransactionFilterer} from \"../../chain-interfaces/ITransactionFilterer.sol\";\nimport {Merkle} from \"../../../common/libraries/Merkle.sol\";\nimport {PriorityQueue, PriorityOperation} from \"../../libraries/PriorityQueue.sol\";\nimport {PriorityTree} from \"../../libraries/PriorityTree.sol\";\nimport {TransactionValidator} from \"../../libraries/TransactionValidator.sol\";\nimport {WritePriorityOpParams, L2CanonicalTransaction, L2Message, L2Log, TxStatus, BridgehubL2TransactionRequest} from \"../../../common/Messaging.sol\";\nimport {MessageHashing} from \"../../../common/libraries/MessageHashing.sol\";\nimport {FeeParams, PubdataPricingMode} from \"../ZKChainStorage.sol\";\nimport {UncheckedMath} from \"../../../common/libraries/UncheckedMath.sol\";\nimport {L2ContractHelper} from \"../../../common/libraries/L2ContractHelper.sol\";\nimport {AddressAliasHelper} from \"../../../vendor/AddressAliasHelper.sol\";\nimport {ZKChainBase} from \"./ZKChainBase.sol\";\nimport {REQUIRED_L2_GAS_PRICE_PER_PUBDATA, L1_GAS_PER_PUBDATA_BYTE, L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, PRIORITY_OPERATION_L2_TX_TYPE, PRIORITY_EXPIRATION, MAX_NEW_FACTORY_DEPS, SETTLEMENT_LAYER_RELAY_SENDER, SUPPORTED_PROOF_METADATA_VERSION} from \"../../../common/Config.sol\";\nimport {L2_BOOTLOADER_ADDRESS, L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR, L2_BRIDGEHUB_ADDR} from \"../../../common/L2ContractAddresses.sol\";\n\nimport {IL1AssetRouter} from \"../../../bridge/asset-router/IL1AssetRouter.sol\";\n\nimport {MerklePathEmpty, OnlyEraSupported, BatchNotExecuted, HashedLogIsDefault, BaseTokenGasPriceDenominatorNotSet, TransactionNotAllowed, GasPerPubdataMismatch, TooManyFactoryDeps, MsgValueTooLow, InvalidProofLengthForFinalNode} from \"../../../common/L1ContractErrors.sol\";\nimport {NotL1, UnsupportedProofMetadataVersion, LocalRootIsZero, LocalRootMustBeZero, NotSettlementLayer, NotHyperchain} from \"../../L1StateTransitionErrors.sol\";\n\n// While formally the following import is not used, it is needed to inherit documentation from it\nimport {IZKChainBase} from \"../../chain-interfaces/IZKChainBase.sol\";\n\n/// @title ZKsync Mailbox contract providing interfaces for L1 <-> L2 interaction.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract MailboxFacet is ZKChainBase, IMailbox {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n    using PriorityTree for PriorityTree.Tree;\n\n    /// @inheritdoc IZKChainBase\n    string public constant override getName = \"MailboxFacet\";\n\n    /// @dev Era's chainID\n    uint256 internal immutable ERA_CHAIN_ID;\n\n    /// @notice The chain id of L1. This contract can be deployed on multiple layers, but this value is still equal to the\n    /// L1 that is at the most base layer.\n    uint256 internal immutable L1_CHAIN_ID;\n\n    modifier onlyL1() {\n        if (block.chainid != L1_CHAIN_ID) {\n            revert NotL1(block.chainid);\n        }\n        _;\n    }\n\n    constructor(uint256 _eraChainId, uint256 _l1ChainId) {\n        ERA_CHAIN_ID = _eraChainId;\n        L1_CHAIN_ID = _l1ChainId;\n    }\n\n    /// @inheritdoc IMailbox\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log calldata _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    function _parseProofMetadata(\n        bytes32[] calldata _proof\n    )\n        internal\n        pure\n        returns (uint256 proofStartIndex, uint256 logLeafProofLen, uint256 batchLeafProofLen, bool finalProofNode)\n    {\n        bytes32 proofMetadata = _proof[0];\n\n        // We support two formats of the proofs:\n        // 1. The old format, where `_proof` is just a plain Merkle proof.\n        // 2. The new format, where the first element of the `_proof` is encoded metadata, which consists of the following:\n        // - first byte: metadata version (0x01).\n        // - second byte: length of the log leaf proof (the proof that the log belongs to a batch).\n        // - third byte: length of the batch leaf proof (the proof that the batch belongs to another settlement layer, if any).\n        // - fourth byte: whether the current proof is the last in the links of recursive proofs for settlement layers.\n        // - the rest of the bytes are zeroes.\n        //\n        // In the future the old version will be disabled, and only the new version will be supported.\n        // For now, we need to support both for backwards compatibility. We distinguish between those based on whether the last 28 bytes are zeroes.\n        // It is safe, since the elements of the proof are hashes and are unlikely to have 28 zero bytes in them.\n\n        // We shift left by 4 bytes = 32 bits to remove the top 32 bits of the metadata.\n        uint256 metadataAsUint256 = (uint256(proofMetadata) << 32);\n\n        if (metadataAsUint256 == 0) {\n            // It is the new version\n            bytes1 metadataVersion = bytes1(proofMetadata);\n            if (uint256(uint8(metadataVersion)) != SUPPORTED_PROOF_METADATA_VERSION) {\n                revert UnsupportedProofMetadataVersion(uint256(uint8(metadataVersion)));\n            }\n\n            proofStartIndex = 1;\n            logLeafProofLen = uint256(uint8(proofMetadata[1]));\n            batchLeafProofLen = uint256(uint8(proofMetadata[2]));\n            finalProofNode = uint256(uint8(proofMetadata[3])) != 0;\n        } else {\n            // It is the old version\n\n            // The entire proof is a merkle path\n            proofStartIndex = 0;\n            logLeafProofLen = _proof.length;\n            batchLeafProofLen = 0;\n            finalProofNode = true;\n        }\n\n        if (finalProofNode && batchLeafProofLen != 0) {\n            revert InvalidProofLengthForFinalNode();\n        }\n    }\n\n    function extractSlice(\n        bytes32[] calldata _proof,\n        uint256 _left,\n        uint256 _right\n    ) internal pure returns (bytes32[] memory slice) {\n        slice = new bytes32[](_right - _left);\n        for (uint256 i = _left; i < _right; i = i.uncheckedInc()) {\n            slice[i - _left] = _proof[i];\n        }\n    }\n\n    /// @notice Extracts slice until the end of the array.\n    /// @dev It is used in one place in order to circumvent the stack too deep error.\n    function extractSliceUntilEnd(\n        bytes32[] calldata _proof,\n        uint256 _start\n    ) internal pure returns (bytes32[] memory slice) {\n        slice = extractSlice(_proof, _start, _proof.length);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LeafInclusion(\n        uint256 _batchNumber,\n        uint256 _leafProofMask,\n        bytes32 _leaf,\n        bytes32[] calldata _proof\n    ) external view override returns (bool) {\n        return _proveL2LeafInclusion(_batchNumber, _leafProofMask, _leaf, _proof);\n    }\n\n    function _proveL2LeafInclusion(\n        uint256 _batchNumber,\n        uint256 _leafProofMask,\n        bytes32 _leaf,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        if (_proof.length == 0) {\n            revert MerklePathEmpty();\n        }\n\n        uint256 ptr = 0;\n        bytes32 chainIdLeaf;\n        {\n            (\n                uint256 proofStartIndex,\n                uint256 logLeafProofLen,\n                uint256 batchLeafProofLen,\n                bool finalProofNode\n            ) = _parseProofMetadata(_proof);\n            ptr = proofStartIndex;\n\n            bytes32 batchSettlementRoot = Merkle.calculateRootMemory(\n                extractSlice(_proof, ptr, ptr + logLeafProofLen),\n                _leafProofMask,\n                _leaf\n            );\n            ptr += logLeafProofLen;\n\n            // If the `finalProofNode` is true, then we assume that this is L1 contract of the top-level\n            // in the aggregation, i.e. the batch root is stored here on L1.\n            if (finalProofNode) {\n                // Double checking that the batch has been executed.\n                if (_batchNumber > s.totalBatchesExecuted) {\n                    revert BatchNotExecuted(_batchNumber);\n                }\n\n                bytes32 correctBatchRoot = s.l2LogsRootHashes[_batchNumber];\n                if (correctBatchRoot == bytes32(0)) {\n                    revert LocalRootIsZero();\n                }\n                return correctBatchRoot == batchSettlementRoot;\n            }\n\n            if (s.l2LogsRootHashes[_batchNumber] != bytes32(0)) {\n                revert LocalRootMustBeZero();\n            }\n\n            // Now, we'll have to check that the Gateway included the message.\n            bytes32 batchLeafHash = MessageHashing.batchLeafHash(batchSettlementRoot, _batchNumber);\n\n            uint256 batchLeafProofMask = uint256(bytes32(_proof[ptr]));\n            ++ptr;\n\n            bytes32 chainIdRoot = Merkle.calculateRootMemory(\n                extractSlice(_proof, ptr, ptr + batchLeafProofLen),\n                batchLeafProofMask,\n                batchLeafHash\n            );\n            ptr += batchLeafProofLen;\n\n            chainIdLeaf = MessageHashing.chainIdLeafHash(chainIdRoot, s.chainId);\n        }\n\n        uint256 settlementLayerBatchNumber;\n        uint256 settlementLayerBatchRootMask;\n        address settlementLayerAddress;\n\n        // Preventing stack too deep error\n        {\n            // Now, we just need to double check whether this chainId leaf was present in the tree.\n            uint256 settlementLayerPackedBatchInfo = uint256(_proof[ptr]);\n            ++ptr;\n            settlementLayerBatchNumber = uint256(settlementLayerPackedBatchInfo >> 128);\n            settlementLayerBatchRootMask = uint256(settlementLayerPackedBatchInfo & ((1 << 128) - 1));\n\n            uint256 settlementLayerChainId = uint256(_proof[ptr]);\n            ++ptr;\n\n            // Assuming that `settlementLayerChainId` is an honest chain, the `chainIdLeaf` should belong\n            // to a chain's message root only if the chain has indeed executed its batch on top of it.\n            //\n            // We trust all chains whitelisted by the Bridgehub governance.\n            if (!IBridgehub(s.bridgehub).whitelistedSettlementLayers(settlementLayerChainId)) {\n                revert NotSettlementLayer();\n            }\n\n            settlementLayerAddress = IBridgehub(s.bridgehub).getZKChain(settlementLayerChainId);\n        }\n\n        return\n            IMailbox(settlementLayerAddress).proveL2LeafInclusion(\n                settlementLayerBatchNumber,\n                settlementLayerBatchRootMask,\n                chainIdLeaf,\n                extractSliceUntilEnd(_proof, ptr)\n            );\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        bytes32 hashedLog = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        if (hashedLog == L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH) {\n            revert HashedLogIsDefault();\n        }\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        // We can use `index` as a mask, since the `localMessageRoot` is on the left part of the tree.\n\n        return _proveL2LeafInclusion(_batchNumber, _index, hashedLog, _proof);\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message calldata _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in base token to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in the base token\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        if (s.baseTokenGasPriceMultiplierDenominator == 0) {\n            revert BaseTokenGasPriceDenominatorNotSet();\n        }\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            // slither-disable-next-line divide-before-multiply\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        // slither-disable-next-line divide-before-multiply\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function requestL2TransactionToGatewayMailbox(\n        uint256 _chainId,\n        bytes32 _canonicalTxHash,\n        uint64 _expirationTimestamp\n    ) external override onlyL1 returns (bytes32 canonicalTxHash) {\n        if (!IBridgehub(s.bridgehub).whitelistedSettlementLayers(s.chainId)) {\n            revert NotSettlementLayer();\n        }\n        if (IChainTypeManager(s.chainTypeManager).getZKChain(_chainId) != msg.sender) {\n            revert NotHyperchain();\n        }\n\n        BridgehubL2TransactionRequest memory wrappedRequest = _wrapRequest({\n            _chainId: _chainId,\n            _canonicalTxHash: _canonicalTxHash,\n            _expirationTimestamp: _expirationTimestamp\n        });\n        canonicalTxHash = _requestL2TransactionToGatewayFree(wrappedRequest);\n    }\n\n    /// @inheritdoc IMailbox\n    function bridgehubRequestL2TransactionOnGateway(\n        bytes32 _canonicalTxHash,\n        uint64 _expirationTimestamp\n    ) external override onlyBridgehub {\n        _writePriorityOpHash(_canonicalTxHash, _expirationTimestamp);\n        emit NewRelayedPriorityTransaction(_getTotalPriorityTxs(), _canonicalTxHash, _expirationTimestamp);\n    }\n\n    function _wrapRequest(\n        uint256 _chainId,\n        bytes32 _canonicalTxHash,\n        uint64 _expirationTimestamp\n    ) internal view returns (BridgehubL2TransactionRequest memory) {\n        // solhint-disable-next-line func-named-parameters\n        bytes memory data = abi.encodeCall(\n            IBridgehub.forwardTransactionOnGateway,\n            (_chainId, _canonicalTxHash, _expirationTimestamp)\n        );\n        return\n            BridgehubL2TransactionRequest({\n                /// There is no sender for the wrapping, we use a virtual address.\n                sender: SETTLEMENT_LAYER_RELAY_SENDER,\n                contractL2: L2_BRIDGEHUB_ADDR,\n                mintValue: 0,\n                l2Value: 0,\n                // Very large amount\n                l2GasLimit: 72_000_000,\n                l2Calldata: data,\n                l2GasPerPubdataByteLimit: REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n                factoryDeps: new bytes[](0),\n                // Tx is free, no so refund recipient needed\n                refundRecipient: address(0)\n            });\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Check that the transaction is allowed by the filterer (if the filterer is set).\n        if (s.transactionFilterer != address(0)) {\n            if (\n                !ITransactionFilterer(s.transactionFilterer).isTransactionAllowed({\n                    sender: _request.sender,\n                    contractL2: _request.contractL2,\n                    mintValue: _request.mintValue,\n                    l2Value: _request.l2Value,\n                    l2Calldata: _request.l2Calldata,\n                    refundRecipient: _request.refundRecipient\n                })\n            ) {\n                revert TransactionNotAllowed();\n            }\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using \"exotic\" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        if (_request.l2GasPerPubdataByteLimit != REQUIRED_L2_GAS_PRICE_PER_PUBDATA) {\n            revert GasPerPubdataMismatch();\n        }\n\n        WritePriorityOpParams memory params;\n        params.request = _request;\n\n        canonicalTxHash = _requestL2Transaction(params);\n    }\n\n    function _requestL2Transaction(WritePriorityOpParams memory _params) internal returns (bytes32 canonicalTxHash) {\n        BridgehubL2TransactionRequest memory request = _params.request;\n\n        if (request.factoryDeps.length > MAX_NEW_FACTORY_DEPS) {\n            revert TooManyFactoryDeps();\n        }\n        _params.txId = _nextPriorityTxId();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, request.l2GasPerPubdataByteLimit);\n        uint256 baseCost = _params.l2GasPrice * request.l2GasLimit;\n        if (request.mintValue < baseCost + request.l2Value) {\n            revert MsgValueTooLow(baseCost + request.l2Value, request.mintValue);\n        }\n\n        request.refundRecipient = AddressAliasHelper.actualRefundRecipient(request.refundRecipient, request.sender);\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently ZKsync address derivation is different from Ethereum one, but it may be changed in the future.\n        // solhint-disable avoid-tx-origin\n        // slither-disable-next-line tx-origin\n        if (request.sender != tx.origin) {\n            request.sender = AddressAliasHelper.applyL1ToL2Alias(request.sender);\n        }\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n\n        L2CanonicalTransaction memory transaction;\n        (transaction, canonicalTxHash) = _validateTx(_params);\n\n        _writePriorityOp(transaction, _params.request.factoryDeps, canonicalTxHash, _params.expirationTimestamp);\n        if (s.settlementLayer != address(0)) {\n            // slither-disable-next-line unused-return\n            IMailbox(s.settlementLayer).requestL2TransactionToGatewayMailbox({\n                _chainId: s.chainId,\n                _canonicalTxHash: canonicalTxHash,\n                _expirationTimestamp: _params.expirationTimestamp\n            });\n        }\n    }\n\n    function _nextPriorityTxId() internal view returns (uint256) {\n        if (_isPriorityQueueActive()) {\n            return s.priorityQueue.getTotalPriorityTxs();\n        } else {\n            return s.priorityTree.getTotalPriorityTxs();\n        }\n    }\n\n    function _requestL2TransactionToGatewayFree(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        WritePriorityOpParams memory params = WritePriorityOpParams({\n            request: _request,\n            txId: _nextPriorityTxId(),\n            l2GasPrice: 0,\n            expirationTimestamp: uint64(block.timestamp + PRIORITY_EXPIRATION)\n        });\n\n        L2CanonicalTransaction memory transaction;\n        (transaction, canonicalTxHash) = _validateTx(params);\n        _writePriorityOp(transaction, params.request.factoryDeps, canonicalTxHash, params.expirationTimestamp);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        BridgehubL2TransactionRequest memory request = _priorityOpParams.request;\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(request.sender)),\n            to: uint256(uint160(request.contractL2)),\n            gasLimit: request.l2GasLimit,\n            gasPerPubdataByteLimit: request.l2GasPerPubdataByteLimit,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as \"nonce\" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: request.l2Value,\n            reserved: [request.mintValue, uint256(uint160(request.refundRecipient)), 0, 0],\n            data: request.l2Calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(request.factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    function _validateTx(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal view returns (L2CanonicalTransaction memory transaction, bytes32 canonicalTxHash) {\n        transaction = _serializeL2Transaction(_priorityOpParams);\n        bytes memory transactionEncoding = abi.encode(transaction);\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n        canonicalTxHash = keccak256(transactionEncoding);\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        L2CanonicalTransaction memory _transaction,\n        bytes[] memory _factoryDeps,\n        bytes32 _canonicalTxHash,\n        uint64 _expirationTimestamp\n    ) internal {\n        _writePriorityOpHash(_canonicalTxHash, _expirationTimestamp);\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        // solhint-disable-next-line func-named-parameters\n        emit NewPriorityRequest(_transaction.nonce, _canonicalTxHash, _expirationTimestamp, _transaction, _factoryDeps);\n    }\n\n    function _writePriorityOpHash(bytes32 _canonicalTxHash, uint64 _expirationTimestamp) internal {\n        if (_isPriorityQueueActive()) {\n            s.priorityQueue.pushBack(\n                PriorityOperation({\n                    canonicalTxHash: _canonicalTxHash,\n                    expirationTimestamp: _expirationTimestamp,\n                    layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n                })\n            );\n        }\n        s.priorityTree.push(_canonicalTxHash);\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n\n    ///////////////////////////////////////////////////////\n    //////// Legacy Era functions\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant onlyL1 {\n        if (s.chainId != ERA_CHAIN_ID) {\n            revert OnlyEraSupported();\n        }\n        address sharedBridge = IBridgehub(s.bridgehub).sharedBridge();\n        IL1AssetRouter(sharedBridge).finalizeWithdrawal({\n            _chainId: ERA_CHAIN_ID,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable onlyL1 returns (bytes32 canonicalTxHash) {\n        if (s.chainId != ERA_CHAIN_ID) {\n            revert OnlyEraSupported();\n        }\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        address sharedBridge = IBridgehub(s.bridgehub).sharedBridge();\n        IL1AssetRouter(sharedBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            s.baseTokenAssetId,\n            msg.sender,\n            msg.value\n        );\n    }\n}\n"
      },
      "contracts/state-transition/chain-deps/facets/ZKChainBase.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {ZKChainStorage} from \"../ZKChainStorage.sol\";\nimport {ReentrancyGuard} from \"../../../common/ReentrancyGuard.sol\";\nimport {PriorityQueue} from \"../../libraries/PriorityQueue.sol\";\nimport {PriorityTree} from \"../../libraries/PriorityTree.sol\";\nimport {Unauthorized, NotSettlementLayer} from \"../../../common/L1ContractErrors.sol\";\n\n/// @title Base contract containing functions accessible to the other facets.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract ZKChainBase is ReentrancyGuard {\n    using PriorityQueue for PriorityQueue.Queue;\n    using PriorityTree for PriorityTree.Tree;\n\n    // slither-disable-next-line uninitialized-state\n    ZKChainStorage internal s;\n\n    /// @notice Checks that the message sender is an active admin\n    modifier onlyAdmin() {\n        if (msg.sender != s.admin) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Checks if validator is active\n    modifier onlyValidator() {\n        if (!s.validators[msg.sender]) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    modifier onlyChainTypeManager() {\n        if (msg.sender != s.chainTypeManager) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    modifier onlyBridgehub() {\n        if (msg.sender != s.bridgehub) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    modifier onlyAdminOrChainTypeManager() {\n        if (msg.sender != s.admin && msg.sender != s.chainTypeManager) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    modifier onlyValidatorOrChainTypeManager() {\n        if (!s.validators[msg.sender] && msg.sender != s.chainTypeManager) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    modifier onlySettlementLayer() {\n        if (s.settlementLayer != address(0)) {\n            revert NotSettlementLayer();\n        }\n        _;\n    }\n\n    /// @notice Returns whether the priority queue is still active, i.e.\n    /// the chain has not processed all transactions from it\n    function _isPriorityQueueActive() internal view returns (bool) {\n        return s.priorityQueue.getFirstUnprocessedPriorityTx() < s.priorityTree.startIndex;\n    }\n\n    /// @notice Ensures that the queue is deactivated. Should be invoked\n    /// whenever the chain migrates to another settlement layer.\n    function _forceDeactivateQueue() internal {\n        // We double check whether it is still active mainly to prevent\n        // overriding `tail`/`head` on L1 deployment.\n        if (_isPriorityQueueActive()) {\n            uint256 startIndex = s.priorityTree.startIndex;\n            s.priorityQueue.head = startIndex;\n            s.priorityQueue.tail = startIndex;\n        }\n    }\n\n    function _getTotalPriorityTxs() internal view returns (uint256) {\n        if (_isPriorityQueueActive()) {\n            return s.priorityQueue.getTotalPriorityTxs();\n        } else {\n            return s.priorityTree.getTotalPriorityTxs();\n        }\n    }\n}\n"
      },
      "contracts/state-transition/chain-interfaces/IAdmin.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {IZKChainBase} from \"../chain-interfaces/IZKChainBase.sol\";\n\nimport {Diamond} from \"../libraries/Diamond.sol\";\nimport {FeeParams, PubdataPricingMode} from \"../chain-deps/ZKChainStorage.sol\";\nimport {ZKChainCommitment} from \"../../common/Config.sol\";\n\n/// @title The interface of the Admin Contract that controls access rights for contract management.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IAdmin is IZKChainBase {\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// @notice Change validator status (active or not active)\n    /// @param _validator Validator address\n    /// @param _active Active flag\n    function setValidator(address _validator, bool _active) external;\n\n    /// @notice Change zk porter availability\n    /// @param _zkPorterIsAvailable The availability of zk porter shard\n    function setPorterAvailability(bool _zkPorterIsAvailable) external;\n\n    /// @notice Change the max L2 gas limit for L1 -> L2 transactions\n    /// @param _newPriorityTxMaxGasLimit The maximum number of L2 gas that a user can request for L1 -> L2 transactions\n    function setPriorityTxMaxGasLimit(uint256 _newPriorityTxMaxGasLimit) external;\n\n    /// @notice Change the fee params for L1->L2 transactions\n    /// @param _newFeeParams The new fee params\n    function changeFeeParams(FeeParams calldata _newFeeParams) external;\n\n    /// @notice Change the token multiplier for L1->L2 transactions\n    function setTokenMultiplier(uint128 _nominator, uint128 _denominator) external;\n\n    /// @notice Change the pubdata pricing mode before the first batch is processed\n    /// @param _pricingMode The new pubdata pricing mode\n    function setPubdataPricingMode(PubdataPricingMode _pricingMode) external;\n\n    /// @notice Set the transaction filterer\n    function setTransactionFilterer(address _transactionFilterer) external;\n\n    /// @notice Perform the upgrade from the current protocol version with the corresponding upgrade data\n    /// @param _protocolVersion The current protocol version from which upgrade is executed\n    /// @param _cutData The diamond cut parameters that is executed in the upgrade\n    function upgradeChainFromVersion(uint256 _protocolVersion, Diamond.DiamondCutData calldata _cutData) external;\n\n    /// @notice Executes a proposed governor upgrade\n    /// @dev Only the ChainTypeManager contract can execute the upgrade\n    /// @param _diamondCut The diamond cut parameters to be executed\n    function executeUpgrade(Diamond.DiamondCutData calldata _diamondCut) external;\n\n    /// @notice Instantly pause the functionality of all freezable facets & their selectors\n    /// @dev Only the governance mechanism may freeze Diamond Proxy\n    function freezeDiamond() external;\n\n    /// @notice Unpause the functionality of all freezable facets & their selectors\n    /// @dev Only the CTM can unfreeze Diamond Proxy\n    function unfreezeDiamond() external;\n\n    function genesisUpgrade(\n        address _l1GenesisUpgrade,\n        address _ctmDeployer,\n        bytes calldata _forceDeploymentData,\n        bytes[] calldata _factoryDeps\n    ) external;\n\n    /// @notice Set the L1 DA validator address as well as the L2 DA validator address.\n    /// @dev While in principle it is possible that updating only one of the addresses is needed,\n    /// usually these should work in pair and L1 validator typically expects a specific input from the L2 Validator.\n    /// That's why we change those together to prevent admins of chains from shooting themselves in the foot.\n    /// @param _l1DAValidator The address of the L1 DA validator\n    /// @param _l2DAValidator The address of the L2 DA validator\n    function setDAValidatorPair(address _l1DAValidator, address _l2DAValidator) external;\n\n    /// @notice Makes the chain as permanent rollup.\n    /// @dev This is a security feature needed for chains that should be\n    /// trusted to keep their data available even if the chain admin becomes malicious\n    /// and tries to set the DA validator pair to something which does not publish DA to Ethereum.\n    /// @dev DANGEROUS: once activated, there is no way back!\n    function makePermanentRollup() external;\n\n    /// @notice Porter availability status changes\n    event IsPorterAvailableStatusUpdate(bool isPorterAvailable);\n\n    /// @notice Validator's status changed\n    event ValidatorStatusUpdate(address indexed validatorAddress, bool isActive);\n\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Priority transaction max L2 gas limit changed\n    event NewPriorityTxMaxGasLimit(uint256 oldPriorityTxMaxGasLimit, uint256 newPriorityTxMaxGasLimit);\n\n    /// @notice Fee params for L1->L2 transactions changed\n    event NewFeeParams(FeeParams oldFeeParams, FeeParams newFeeParams);\n\n    /// @notice Validium mode status changed\n    event PubdataPricingModeUpdate(PubdataPricingMode validiumMode);\n\n    /// @notice The transaction filterer has been updated\n    event NewTransactionFilterer(address oldTransactionFilterer, address newTransactionFilterer);\n\n    /// @notice BaseToken multiplier for L1->L2 transactions changed\n    event NewBaseTokenMultiplier(\n        uint128 oldNominator,\n        uint128 oldDenominator,\n        uint128 newNominator,\n        uint128 newDenominator\n    );\n\n    /// @notice Emitted when an upgrade is executed.\n    event ExecuteUpgrade(Diamond.DiamondCutData diamondCut);\n\n    /// @notice Emitted when the migration to the new settlement layer is complete.\n    event MigrationComplete();\n\n    /// @notice Emitted when the contract is frozen.\n    event Freeze();\n\n    /// @notice Emitted when the contract is unfrozen.\n    event Unfreeze();\n\n    /// @notice New pair of DA validators set\n    event NewL2DAValidator(address indexed oldL2DAValidator, address indexed newL2DAValidator);\n    event NewL1DAValidator(address indexed oldL1DAValidator, address indexed newL1DAValidator);\n\n    event BridgeMint(address indexed _account, uint256 _amount);\n\n    /// @dev Similar to IL1AssetHandler interface, used to send chains.\n    function forwardedBridgeBurn(\n        address _settlementLayer,\n        address _originalCaller,\n        bytes calldata _data\n    ) external payable returns (bytes memory _bridgeMintData);\n\n    /// @dev Similar to IL1AssetHandler interface, used to claim failed chain transfers.\n    function forwardedBridgeRecoverFailedTransfer(\n        uint256 _chainId,\n        bytes32 _assetInfo,\n        address _originalCaller,\n        bytes calldata _chainData\n    ) external payable;\n\n    /// @dev Similar to IL1AssetHandler interface, used to receive chains.\n    function forwardedBridgeMint(bytes calldata _data, bool _contractAlreadyDeployed) external payable;\n\n    function prepareChainCommitment() external view returns (ZKChainCommitment memory commitment);\n}\n"
      },
      "contracts/state-transition/chain-interfaces/IDiamondInit.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {IVerifier, VerifierParams} from \"./IVerifier.sol\";\nimport {FeeParams} from \"../chain-deps/ZKChainStorage.sol\";\n\n/// @param chainId the id of the chain\n/// @param bridgehub the address of the bridgehub contract\n/// @param chainTypeManager contract's address\n/// @param protocolVersion initial protocol version\n/// @param validatorTimelock address of the validator timelock that delays execution\n/// @param admin address who can manage the contract\n/// @param baseTokenAssetId asset id of the base token of the chain\n/// @param storedBatchZero hash of the initial genesis batch\n/// @param verifier address of Verifier contract\n/// @param verifierParams Verifier config parameters that describes the circuit to be verified\n/// @param l2BootloaderBytecodeHash The hash of bootloader L2 bytecode\n/// @param l2DefaultAccountBytecodeHash The hash of default account L2 bytecode\n/// @param priorityTxMaxGasLimit maximum number of the L2 gas that a user can request for L1 -> L2 transactions\n/// @param feeParams Fee parameters to be used for L1->L2 transactions\n/// @param blobVersionedHashRetriever Address of contract used to pull the blob versioned hash for a transaction.\n// solhint-disable-next-line gas-struct-packing\nstruct InitializeData {\n    uint256 chainId;\n    address bridgehub;\n    address chainTypeManager;\n    uint256 protocolVersion;\n    address admin;\n    address validatorTimelock;\n    bytes32 baseTokenAssetId;\n    bytes32 storedBatchZero;\n    IVerifier verifier;\n    VerifierParams verifierParams;\n    bytes32 l2BootloaderBytecodeHash;\n    bytes32 l2DefaultAccountBytecodeHash;\n    uint256 priorityTxMaxGasLimit;\n    FeeParams feeParams;\n    address blobVersionedHashRetriever;\n}\n\n/// @param verifier address of Verifier contract\n/// @param verifierParams Verifier config parameters that describes the circuit to be verified\n/// @param l2BootloaderBytecodeHash The hash of bootloader L2 bytecode\n/// @param l2DefaultAccountBytecodeHash The hash of default account L2 bytecode\n/// @param priorityTxMaxGasLimit maximum number of the L2 gas that a user can request for L1 -> L2 transactions\n/// @param feeParams Fee parameters to be used for L1->L2 transactions\n/// @param blobVersionedHashRetriever Address of contract used to pull the blob versioned hash for a transaction.\nstruct InitializeDataNewChain {\n    IVerifier verifier;\n    VerifierParams verifierParams;\n    bytes32 l2BootloaderBytecodeHash;\n    bytes32 l2DefaultAccountBytecodeHash;\n    uint256 priorityTxMaxGasLimit;\n    FeeParams feeParams;\n    address blobVersionedHashRetriever;\n}\n\ninterface IDiamondInit {\n    function initialize(InitializeData calldata _initData) external returns (bytes32);\n}\n"
      },
      "contracts/state-transition/chain-interfaces/IExecutor.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {IZKChainBase} from \"./IZKChainBase.sol\";\n\n/// @dev Enum used by L2 System Contracts to differentiate logs.\nenum SystemLogKey {\n    L2_TO_L1_LOGS_TREE_ROOT_KEY,\n    PACKED_BATCH_AND_L2_BLOCK_TIMESTAMP_KEY,\n    CHAINED_PRIORITY_TXN_HASH_KEY,\n    NUMBER_OF_LAYER_1_TXS_KEY,\n    // Note, that it is important that `PREV_BATCH_HASH_KEY` has position\n    // `4` since it is the same as it was in the previous protocol version and\n    // it is the only one that is emitted before the system contracts are upgraded.\n    PREV_BATCH_HASH_KEY,\n    L2_DA_VALIDATOR_OUTPUT_HASH_KEY,\n    USED_L2_DA_VALIDATOR_ADDRESS_KEY,\n    EXPECTED_SYSTEM_CONTRACT_UPGRADE_TX_HASH_KEY\n}\n\nstruct LogProcessingOutput {\n    uint256 numberOfLayer1Txs;\n    bytes32 chainedPriorityTxsHash;\n    bytes32 previousBatchHash;\n    bytes32 pubdataHash;\n    bytes32 stateDiffHash;\n    bytes32 l2LogsTreeRoot;\n    uint256 packedBatchAndL2BlockTimestamp;\n    bytes32 l2DAValidatorOutputHash;\n}\n\n/// @dev Offset used to pull Address From Log. Equal to 4 (bytes for isService)\nuint256 constant L2_LOG_ADDRESS_OFFSET = 4;\n\n/// @dev Offset used to pull Key From Log. Equal to 4 (bytes for isService) + 20 (bytes for address)\nuint256 constant L2_LOG_KEY_OFFSET = 24;\n\n/// @dev Offset used to pull Value From Log. Equal to 4 (bytes for isService) + 20 (bytes for address) + 32 (bytes for key)\nuint256 constant L2_LOG_VALUE_OFFSET = 56;\n\n/// @dev Max number of blobs currently supported\nuint256 constant MAX_NUMBER_OF_BLOBS = 6;\n\n/// @dev The number of blobs that must be present in the commitment to a batch.\n/// It represents the maximal number of blobs that circuits can support and can be larger\n/// than the maximal number of blobs supported by the contract (`MAX_NUMBER_OF_BLOBS`).\nuint256 constant TOTAL_BLOBS_IN_COMMITMENT = 16;\n\n/// @title The interface of the ZKsync Executor contract capable of processing events emitted in the ZKsync protocol.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IExecutor is IZKChainBase {\n    /// @notice Rollup batch stored data\n    /// @param batchNumber Rollup batch number\n    /// @param batchHash Hash of L2 batch\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\n    /// @param priorityOperationsHash Hash of all priority operations from this batch\n    /// @param l2LogsTreeRoot Root hash of tree that contains L2 -> L1 messages from this batch\n    /// @param timestamp Rollup batch timestamp, have the same format as Ethereum batch constant\n    /// @param commitment Verified input for the ZKsync circuit\n    // solhint-disable-next-line gas-struct-packing\n    struct StoredBatchInfo {\n        uint64 batchNumber;\n        bytes32 batchHash;\n        uint64 indexRepeatedStorageChanges;\n        uint256 numberOfLayer1Txs;\n        bytes32 priorityOperationsHash;\n        bytes32 l2LogsTreeRoot;\n        uint256 timestamp;\n        bytes32 commitment;\n    }\n\n    /// @notice Data needed to commit new batch\n    /// @param batchNumber Number of the committed batch\n    /// @param timestamp Unix timestamp denoting the start of the batch execution\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\n    /// @param newStateRoot The state root of the full state tree\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\n    /// @param priorityOperationsHash Hash of all priority operations from this batch\n    /// @param bootloaderHeapInitialContentsHash Hash of the initial contents of the bootloader heap. In practice it serves as the commitment to the transactions in the batch.\n    /// @param eventsQueueStateHash Hash of the events queue state. In practice it serves as the commitment to the events in the batch.\n    /// @param systemLogs concatenation of all L2 -> L1 system logs in the batch\n    /// @param operatorDAInput Packed pubdata commitments/data.\n    /// @dev pubdataCommitments format: This will always start with a 1 byte pubdataSource flag. Current allowed values are 0 (calldata) or 1 (blobs)\n    ///                             kzg: list of: opening point (16 bytes) || claimed value (32 bytes) || commitment (48 bytes) || proof (48 bytes) = 144 bytes\n    ///                             calldata: pubdataCommitments.length - 1 - 32 bytes of pubdata\n    ///                                       and 32 bytes appended to serve as the blob commitment part for the aux output part of the batch commitment\n    /// @dev For 2 blobs we will be sending 288 bytes of calldata instead of the full amount for pubdata.\n    /// @dev When using calldata, we only need to send one blob commitment since the max number of bytes in calldata fits in a single blob and we can pull the\n    ///     linear hash from the system logs\n    struct CommitBatchInfo {\n        uint64 batchNumber;\n        uint64 timestamp;\n        uint64 indexRepeatedStorageChanges;\n        bytes32 newStateRoot;\n        uint256 numberOfLayer1Txs;\n        bytes32 priorityOperationsHash;\n        bytes32 bootloaderHeapInitialContentsHash;\n        bytes32 eventsQueueStateHash;\n        bytes systemLogs;\n        bytes operatorDAInput;\n    }\n\n    /// @notice Function called by the operator to commit new batches. It is responsible for:\n    /// - Verifying the correctness of their timestamps.\n    /// - Processing their L2->L1 logs.\n    /// - Storing batch commitments.\n    /// @param _chainId Chain ID of the chain.\n    /// @param _processFrom The batch number from which the processing starts.\n    /// @param _processTo The batch number at which the processing ends.\n    /// @param _commitData The encoded data of the new batches to be committed.\n    function commitBatchesSharedBridge(\n        uint256 _chainId,\n        uint256 _processFrom,\n        uint256 _processTo,\n        bytes calldata _commitData\n    ) external;\n\n    /// @notice Batches commitment verification.\n    /// @dev Only verifies batch commitments without any other processing.\n    /// @param _chainId Chain ID of the chain.\n    /// @param _processBatchFrom The batch number from which the verification starts.\n    /// @param _processBatchTo The batch number at which the verification ends.\n    /// @param _proofData The encoded data of the new batches to be verified.\n    function proveBatchesSharedBridge(\n        uint256 _chainId,\n        uint256 _processBatchFrom,\n        uint256 _processBatchTo,\n        bytes calldata _proofData\n    ) external;\n\n    /// @notice The function called by the operator to finalize (execute) batches. It is responsible for:\n    /// - Processing all pending operations (commpleting priority requests).\n    /// - Finalizing this batch (i.e. allowing to withdraw funds from the system)\n    /// @param _chainId Chain ID of the chain.\n    /// @param _processFrom The batch number from which the execution starts.\n    /// @param _processTo The batch number at which the execution ends.\n    /// @param _executeData The encoded data of the new batches to be executed.\n    function executeBatchesSharedBridge(\n        uint256 _chainId,\n        uint256 _processFrom,\n        uint256 _processTo,\n        bytes calldata _executeData\n    ) external;\n\n    /// @notice Reverts unexecuted batches\n    /// @param _chainId Chain ID of the chain\n    /// @param _newLastBatch batch number after which batches should be reverted\n    /// NOTE: Doesn't delete the stored data about batches, but only decreases\n    /// counters that are responsible for the number of batches\n    function revertBatchesSharedBridge(uint256 _chainId, uint256 _newLastBatch) external;\n\n    /// @notice Event emitted when a batch is committed\n    /// @param batchNumber Number of the batch committed\n    /// @param batchHash Hash of the L2 batch\n    /// @param commitment Calculated input for the ZKsync circuit\n    /// @dev It has the name \"BlockCommit\" and not \"BatchCommit\" due to backward compatibility considerations\n    event BlockCommit(uint256 indexed batchNumber, bytes32 indexed batchHash, bytes32 indexed commitment);\n\n    /// @notice Event emitted when batches are verified\n    /// @param previousLastVerifiedBatch Batch number of the previous last verified batch\n    /// @param currentLastVerifiedBatch Batch number of the current last verified batch\n    /// @dev It has the name \"BlocksVerification\" and not \"BatchesVerification\" due to backward compatibility considerations\n    event BlocksVerification(uint256 indexed previousLastVerifiedBatch, uint256 indexed currentLastVerifiedBatch);\n\n    /// @notice Event emitted when a batch is executed\n    /// @param batchNumber Number of the batch executed\n    /// @param batchHash Hash of the L2 batch\n    /// @param commitment Verified input for the ZKsync circuit\n    /// @dev It has the name \"BlockExecution\" and not \"BatchExecution\" due to backward compatibility considerations\n    event BlockExecution(uint256 indexed batchNumber, bytes32 indexed batchHash, bytes32 indexed commitment);\n\n    /// @notice Event emitted when batches are reverted\n    /// @param totalBatchesCommitted Total number of committed batches after the revert\n    /// @param totalBatchesVerified Total number of verified batches after the revert\n    /// @param totalBatchesExecuted Total number of executed batches\n    /// @dev It has the name \"BlocksRevert\" and not \"BatchesRevert\" due to backward compatibility considerations\n    event BlocksRevert(uint256 totalBatchesCommitted, uint256 totalBatchesVerified, uint256 totalBatchesExecuted);\n}\n"
      },
      "contracts/state-transition/chain-interfaces/IGetters.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {VerifierParams} from \"../chain-interfaces/IVerifier.sol\";\nimport {PubdataPricingMode} from \"../chain-deps/ZKChainStorage.sol\";\nimport {IZKChainBase} from \"./IZKChainBase.sol\";\n\n/// @title The interface of the Getters Contract that implements functions for getting contract state from outside the blockchain.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev Most of the methods simply return the values that correspond to the current diamond proxy and possibly\n/// not to the ZK Chain as a whole. For example, if the chain is migrated to another settlement layer, the values returned\n/// by this facet will correspond to the values stored on this chain and possilbly not the canonical state of the chain.\ninterface IGetters is IZKChainBase {\n    /*//////////////////////////////////////////////////////////////\n                            CUSTOM GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @return The address of the verifier smart contract\n    function getVerifier() external view returns (address);\n\n    /// @return The address of the current admin\n    function getAdmin() external view returns (address);\n\n    /// @return The address of the pending admin\n    function getPendingAdmin() external view returns (address);\n\n    /// @return The address of the bridgehub\n    function getBridgehub() external view returns (address);\n\n    /// @return The address of the state transition\n    function getChainTypeManager() external view returns (address);\n\n    /// @return The chain ID\n    function getChainId() external view returns (uint256);\n\n    /// @return The address of the base token\n    function getBaseToken() external view returns (address);\n\n    /// @return The address of the base token\n    function getBaseTokenAssetId() external view returns (bytes32);\n\n    /// @return The total number of batches that were committed\n    function getTotalBatchesCommitted() external view returns (uint256);\n\n    /// @return The total number of batches that were committed & verified\n    function getTotalBatchesVerified() external view returns (uint256);\n\n    /// @return The total number of batches that were committed & verified & executed\n    function getTotalBatchesExecuted() external view returns (uint256);\n\n    // @return Address of transaction filterer\n    function getTransactionFilterer() external view returns (address);\n\n    /// @return The total number of priority operations that were added to the priority queue, including all processed ones\n    function getTotalPriorityTxs() external view returns (uint256);\n\n    /// @return The start index of the priority tree, i.e. the index of the first priority operation that\n    /// was included into the priority tree.\n    function getPriorityTreeStartIndex() external view returns (uint256);\n\n    /// @return The root hash of the priority tree\n    function getPriorityTreeRoot() external view returns (bytes32);\n\n    /// @return Whether the priority queue is active, i.e. whether new priority operations are appended to it.\n    /// Once the chain processes all the transaction that were present in the priority queue, all the L1->L2 related\n    /// operations will start to get done using the priority tree.\n    function isPriorityQueueActive() external view returns (bool);\n\n    /// @notice The function that returns the first unprocessed priority transaction.\n    /// @dev Returns zero if and only if no operations were processed from the queue.\n    /// @dev If all the transactions were processed, it will return the last processed index, so\n    /// in case exactly *unprocessed* transactions are needed, one should check that getPriorityQueueSize() is greater than 0.\n    /// @return Index of the oldest priority operation that wasn't processed yet\n    function getFirstUnprocessedPriorityTx() external view returns (uint256);\n\n    /// @return The number of priority operations currently in the queue\n    function getPriorityQueueSize() external view returns (uint256);\n\n    /// @return Whether the address has a validator access\n    function isValidator(address _address) external view returns (bool);\n\n    /// @return merkleRoot Merkle root of the tree with L2 logs for the selected batch\n    function l2LogsRootHash(uint256 _batchNumber) external view returns (bytes32 merkleRoot);\n\n    /// @notice For unfinalized (non executed) batches may change\n    /// @dev returns zero for non-committed batches\n    /// @return The hash of committed L2 batch.\n    function storedBatchHash(uint256 _batchNumber) external view returns (bytes32);\n\n    /// @return Bytecode hash of bootloader program.\n    function getL2BootloaderBytecodeHash() external view returns (bytes32);\n\n    /// @return Bytecode hash of default account (bytecode for EOA).\n    function getL2DefaultAccountBytecodeHash() external view returns (bytes32);\n\n    /// @return Verifier parameters.\n    /// @dev This function is deprecated and will soon be removed.\n    function getVerifierParams() external view returns (VerifierParams memory);\n\n    /// @return Whether the diamond is frozen or not\n    function isDiamondStorageFrozen() external view returns (bool);\n\n    /// @return The current packed protocol version. To access human-readable version, use `getSemverProtocolVersion` function.\n    function getProtocolVersion() external view returns (uint256);\n\n    /// @return The tuple of (major, minor, patch) protocol version.\n    function getSemverProtocolVersion() external view returns (uint32, uint32, uint32);\n\n    /// @return The upgrade system contract transaction hash, 0 if the upgrade is not initialized\n    function getL2SystemContractsUpgradeTxHash() external view returns (bytes32);\n\n    /// @return The L2 batch number in which the upgrade transaction was processed.\n    /// @dev It is equal to 0 in the following two cases:\n    /// - No upgrade transaction has ever been processed.\n    /// - The upgrade transaction has been processed and the batch with such transaction has been\n    /// executed (i.e. finalized).\n    function getL2SystemContractsUpgradeBatchNumber() external view returns (uint256);\n\n    /// @return The maximum number of L2 gas that a user can request for L1 -> L2 transactions\n    function getPriorityTxMaxGasLimit() external view returns (uint256);\n\n    /// @return Whether a withdrawal has been finalized.\n    /// @param _l2BatchNumber The L2 batch number within which the withdrawal happened.\n    /// @param _l2MessageIndex The index of the L2->L1 message denoting the withdrawal.\n    function isEthWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    /// @return The pubdata pricing mode.\n    function getPubdataPricingMode() external view returns (PubdataPricingMode);\n\n    /// @return the baseTokenGasPriceMultiplierNominator, used to compare the baseTokenPrice to ether for L1->L2 transactions\n    function baseTokenGasPriceMultiplierNominator() external view returns (uint128);\n\n    /// @return the baseTokenGasPriceMultiplierDenominator, used to compare the baseTokenPrice to ether for L1->L2 transactions\n    function baseTokenGasPriceMultiplierDenominator() external view returns (uint128);\n\n    /*//////////////////////////////////////////////////////////////\n                            DIAMOND LOUPE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Faсet structure compatible with the EIP-2535 diamond loupe\n    /// @param addr The address of the facet contract\n    /// @param selectors The NON-sorted array with selectors associated with facet\n    struct Facet {\n        address addr;\n        bytes4[] selectors;\n    }\n\n    /// @return result All facet addresses and their function selectors\n    function facets() external view returns (Facet[] memory);\n\n    /// @return NON-sorted array with function selectors supported by a specific facet\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory);\n\n    /// @return facets NON-sorted array of facet addresses supported on diamond\n    function facetAddresses() external view returns (address[] memory facets);\n\n    /// @return facet The facet address associated with a selector. Zero if the selector is not added to the diamond\n    function facetAddress(bytes4 _selector) external view returns (address facet);\n\n    /// @return Whether the selector can be frozen by the admin or always accessible\n    function isFunctionFreezable(bytes4 _selector) external view returns (bool);\n\n    /// @return isFreezable Whether the facet can be frozen by the admin or always accessible\n    function isFacetFreezable(address _facet) external view returns (bool isFreezable);\n\n    /// @return The address of the current settlement layer.\n    function getSettlementLayer() external view returns (address);\n}\n"
      },
      "contracts/state-transition/chain-interfaces/IL1DAValidator.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\n/// @dev Enum used to determine the source of pubdata. At first we will support calldata and blobs but this can be extended.\nenum PubdataSource {\n    Calldata,\n    Blob\n}\n\nstruct L1DAValidatorOutput {\n    /// @dev The hash of the uncompressed state diff.\n    bytes32 stateDiffHash;\n    /// @dev The hashes of the blobs on L1. The array is dynamic to account for forward compatibility.\n    /// The length of it must be equal to `maxBlobsSupported`.\n    bytes32[] blobsLinearHashes;\n    /// @dev The commitments to the blobs on L1. The array is dynamic to account for forward compatibility.\n    /// Its length must be equal to the length of blobsLinearHashes.\n    /// @dev If the system supports more blobs than returned, the rest of the array should be filled with zeros.\n    bytes32[] blobsOpeningCommitments;\n}\n\ninterface IL1DAValidator {\n    /// @notice The function that checks the data availability for the given batch input.\n    /// @param _chainId The chain id of the chain that is being committed.\n    /// @param _batchNumber The batch number for which the data availability is being checked.\n    /// @param _l2DAValidatorOutputHash The hash of that was returned by the l2DAValidator.\n    /// @param _operatorDAInput The DA input by the operator provided on L1.\n    /// @param _maxBlobsSupported The maximal number of blobs supported by the chain.\n    /// We provide this value for future compatibility.\n    /// This is needed because the corresponding `blobsLinearHashes`/`blobsOpeningCommitments`\n    /// in the `L1DAValidatorOutput` struct will have to have this length as it is required\n    /// to be static by the circuits.\n    function checkDA(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        bytes32 _l2DAValidatorOutputHash,\n        bytes calldata _operatorDAInput,\n        uint256 _maxBlobsSupported\n    ) external returns (L1DAValidatorOutput memory output);\n}\n"
      },
      "contracts/state-transition/chain-interfaces/ILegacyGetters.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {IZKChainBase} from \"./IZKChainBase.sol\";\n\n/// @author Matter Labs\n/// @dev This interface contains getters for the ZKsync contract that should not be used,\n/// but still are kept for backward compatibility.\n/// @custom:security-contact security@matterlabs.dev\ninterface ILegacyGetters is IZKChainBase {\n    /// @return The total number of batches that were committed\n    /// @dev It is a *deprecated* method, please use `getTotalBatchesCommitted` instead\n    function getTotalBlocksCommitted() external view returns (uint256);\n\n    /// @return The total number of batches that were committed & verified\n    /// @dev It is a *deprecated* method, please use `getTotalBatchesVerified` instead.\n    function getTotalBlocksVerified() external view returns (uint256);\n\n    /// @return The total number of batches that were committed & verified & executed\n    /// @dev It is a *deprecated* method, please use `getTotalBatchesExecuted` instead.\n    function getTotalBlocksExecuted() external view returns (uint256);\n\n    /// @notice For unfinalized (non executed) batches may change\n    /// @dev It is a *deprecated* method, please use `storedBatchHash` instead.\n    /// @dev returns zero for non-committed batches\n    /// @return The hash of committed L2 batch.\n    function storedBlockHash(uint256 _batchNumber) external view returns (bytes32);\n\n    /// @return The L2 batch number in which the upgrade transaction was processed.\n    /// @dev It is a *deprecated* method, please use `getL2SystemContractsUpgradeBatchNumber` instead.\n    /// @dev It is equal to 0 in the following two cases:\n    /// - No upgrade transaction has ever been processed.\n    /// - The upgrade transaction has been processed and the batch with such transaction has been\n    /// executed (i.e. finalized).\n    function getL2SystemContractsUpgradeBlockNumber() external view returns (uint256);\n}\n"
      },
      "contracts/state-transition/chain-interfaces/IMailbox.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {IZKChainBase} from \"./IZKChainBase.sol\";\nimport {L2CanonicalTransaction, L2Log, L2Message, TxStatus, BridgehubL2TransactionRequest} from \"../../common/Messaging.sol\";\n\n/// @title The interface of the ZKsync Mailbox contract that provides interfaces for L1 <-> L2 interaction.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IMailbox is IZKChainBase {\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _batchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 batch\n    /// @param _batchNumber The executed L2 batch number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    /// @return Whether the proof is correct and L2 log is included in batch\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn't mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds are controllable,\n    /// since address aliasing to the from address for the L2 tx will be applied if the L1 `msg.sender` is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external returns (bytes32 canonicalTxHash);\n\n    /// @dev On the Gateway the chain's mailbox receives the tx from the bridgehub.\n    function bridgehubRequestL2TransactionOnGateway(bytes32 _canonicalTxHash, uint64 _expirationTimestamp) external;\n\n    /// @dev On L1 we have to forward to the Gateway's mailbox which sends to the Bridgehub on the Gw\n    /// @param _chainId the chainId of the chain\n    /// @param _canonicalTxHash the canonical transaction hash\n    /// @param _expirationTimestamp the expiration timestamp\n    function requestL2TransactionToGatewayMailbox(\n        uint256 _chainId,\n        bytes32 _canonicalTxHash,\n        uint64 _expirationTimestamp\n    ) external returns (bytes32 canonicalTxHash);\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    /// Proves that a certain leaf was included as part of the log merkle tree.\n    function proveL2LeafInclusion(\n        uint256 _batchNumber,\n        uint256 _batchRootMask,\n        bytes32 _leaf,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice transfer Eth to shared bridge as part of migration process\n    // function transferEthToSharedBridge() external;\n\n    // function relayTxSL(\n    //     address _to,\n    //     L2CanonicalTransaction memory _transaction,\n    //     bytes[] memory _factoryDeps,\n    //     bytes32 _canonicalTxHash,\n    //     uint64 _expirationTimestamp\n    // ) external;\n\n    // function freeAcceptTx(\n    //     L2CanonicalTransaction memory _transaction,\n    //     bytes[] memory _factoryDeps,\n    //     bytes32 _canonicalTxHash,\n    //     uint64 _expirationTimestamp\n    // ) external;\n\n    // function acceptFreeRequestFromBridgehub(BridgehubL2TransactionRequest calldata _request) external;\n\n    /// @notice New priority request event. Emitted when a request is placed into the priority queue\n    /// @param txId Serial number of the priority operation\n    /// @param txHash keccak256 hash of encoded transaction representation\n    /// @param expirationTimestamp Timestamp up to which priority request should be processed\n    /// @param transaction The whole transaction structure that is requested to be executed on L2\n    /// @param factoryDeps An array of bytecodes that were shown in the L1 public data.\n    /// Will be marked as known bytecodes in L2\n    event NewPriorityRequest(\n        uint256 txId,\n        bytes32 txHash,\n        uint64 expirationTimestamp,\n        L2CanonicalTransaction transaction,\n        bytes[] factoryDeps\n    );\n\n    /// @notice New relayed priority request event. It is emitted on a chain that is deployed\n    /// on top of the gateway when it receives a request relayed via the Bridgehub.\n    /// @dev IMPORTANT: this event most likely will be removed in the future, so\n    /// no one should rely on it for indexing purposes.\n    /// @param txId Serial number of the priority operation\n    /// @param txHash keccak256 hash of encoded transaction representation\n    /// @param expirationTimestamp Timestamp up to which priority request should be processed\n    event NewRelayedPriorityTransaction(uint256 txId, bytes32 txHash, uint64 expirationTimestamp);\n}\n"
      },
      "contracts/state-transition/chain-interfaces/ITransactionFilterer.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\n/// @title The interface of the L1 -> L2 transaction filterer.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface ITransactionFilterer {\n    /// @notice Check if the transaction is allowed\n    /// @param sender The sender of the transaction\n    /// @param contractL2 The L2 receiver address\n    /// @param mintValue The value of the L1 transaction\n    /// @param l2Value The msg.value of the L2 transaction\n    /// @param l2Calldata The calldata of the L2 transaction\n    /// @param refundRecipient The address to refund the excess value\n    /// @return Whether the transaction is allowed\n    function isTransactionAllowed(\n        address sender,\n        address contractL2,\n        uint256 mintValue,\n        uint256 l2Value,\n        bytes memory l2Calldata,\n        address refundRecipient\n    ) external view returns (bool);\n}\n"
      },
      "contracts/state-transition/chain-interfaces/IVerifier.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\n/// @notice Part of the configuration parameters of ZKP circuits\nstruct VerifierParams {\n    bytes32 recursionNodeLevelVkHash;\n    bytes32 recursionLeafLevelVkHash;\n    bytes32 recursionCircuitsSetVksHash;\n}\n\n/// @title The interface of the Verifier contract, responsible for the zero knowledge proof verification.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IVerifier {\n    /// @dev Verifies a zk-SNARK proof.\n    /// @return A boolean value indicating whether the zk-SNARK proof is valid.\n    /// Note: The function may revert execution instead of returning false in some cases.\n    function verify(uint256[] calldata _publicInputs, uint256[] calldata _proof) external view returns (bool);\n\n    /// @notice Calculates a keccak256 hash of the runtime loaded verification keys.\n    /// @return vkHash The keccak256 hash of the loaded verification keys.\n    function verificationKeyHash() external pure returns (bytes32);\n}\n"
      },
      "contracts/state-transition/chain-interfaces/IZKChain.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {IAdmin} from \"./IAdmin.sol\";\nimport {IExecutor} from \"./IExecutor.sol\";\nimport {IGetters} from \"./IGetters.sol\";\nimport {IMailbox} from \"./IMailbox.sol\";\n\nimport {Diamond} from \"../libraries/Diamond.sol\";\n\ninterface IZKChain is IAdmin, IExecutor, IGetters, IMailbox {\n    // We need this structure for the server for now\n    event ProposeTransparentUpgrade(\n        Diamond.DiamondCutData diamondCut,\n        uint256 indexed proposalId,\n        bytes32 proposalSalt\n    );\n}\n"
      },
      "contracts/state-transition/chain-interfaces/IZKChainBase.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\n/// @title The interface of the ZKsync contract, responsible for the main ZKsync logic.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IZKChainBase {\n    /// @return Returns facet name.\n    function getName() external view returns (string memory);\n}\n"
      },
      "contracts/state-transition/data-availability/CalldataDA.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {OperatorDAInputTooSmall, InvalidNumberOfBlobs, InvalidL2DAOutputHash, OnlyOneBlobWithCalldataAllowed, PubdataInputTooSmall, PubdataLengthTooBig, InvalidPubdataHash} from \"../L1StateTransitionErrors.sol\";\n\n/// @dev Total number of bytes in a blob. Blob = 4096 field elements * 31 bytes per field element\n/// @dev EIP-4844 defines it as 131_072 but we use 4096 * 31 within our circuits to always fit within a field element\n/// @dev Our circuits will prove that a EIP-4844 blob and our internal blob are the same.\nuint256 constant BLOB_SIZE_BYTES = 126_976;\n\n/// @dev The state diff hash, hash of pubdata + the number of blobs.\nuint256 constant BLOB_DATA_OFFSET = 65;\n\n/// @dev The size of the commitment for a single blob.\nuint256 constant BLOB_COMMITMENT_SIZE = 32;\n\n/// @notice Contract that contains the functionality for process the calldata DA.\n/// @dev The expected l2DAValidator that should be used with it `RollupL2DAValidator`.\nabstract contract CalldataDA {\n    /// @notice Parses the input that the L2 DA validator has provided to the contract.\n    /// @param _l2DAValidatorOutputHash The hash of the output of the L2 DA validator.\n    /// @param _maxBlobsSupported The maximal number of blobs supported by the chain.\n    /// @param _operatorDAInput The DA input by the operator provided on L1.\n    function _processL2RollupDAValidatorOutputHash(\n        bytes32 _l2DAValidatorOutputHash,\n        uint256 _maxBlobsSupported,\n        bytes calldata _operatorDAInput\n    )\n        internal\n        pure\n        returns (\n            bytes32 stateDiffHash,\n            bytes32 fullPubdataHash,\n            bytes32[] memory blobsLinearHashes,\n            uint256 blobsProvided,\n            bytes calldata l1DaInput\n        )\n    {\n        // The preimage under the hash `_l2DAValidatorOutputHash` is expected to be in the following format:\n        // - First 32 bytes are the hash of the uncompressed state diff.\n        // - Then, there is a 32-byte hash of the full pubdata.\n        // - Then, there is the 1-byte number of blobs published.\n        // - Then, there are linear hashes of the published blobs, 32 bytes each.\n\n        // Check that it accommodates enough pubdata for the state diff hash, hash of pubdata + the number of blobs.\n        if (_operatorDAInput.length < BLOB_DATA_OFFSET) {\n            revert OperatorDAInputTooSmall(_operatorDAInput.length, BLOB_DATA_OFFSET);\n        }\n\n        stateDiffHash = bytes32(_operatorDAInput[:32]);\n        fullPubdataHash = bytes32(_operatorDAInput[32:64]);\n        blobsProvided = uint256(uint8(_operatorDAInput[64]));\n\n        if (blobsProvided > _maxBlobsSupported) {\n            revert InvalidNumberOfBlobs(blobsProvided, _maxBlobsSupported);\n        }\n\n        // Note that the API of the contract requires that the returned blobs linear hashes have length of\n        // the `_maxBlobsSupported`\n        blobsLinearHashes = new bytes32[](_maxBlobsSupported);\n\n        if (_operatorDAInput.length < BLOB_DATA_OFFSET + 32 * blobsProvided) {\n            revert OperatorDAInputTooSmall(_operatorDAInput.length, BLOB_DATA_OFFSET + 32 * blobsProvided);\n        }\n\n        _cloneCalldata(blobsLinearHashes, _operatorDAInput[BLOB_DATA_OFFSET:], blobsProvided);\n\n        uint256 ptr = BLOB_DATA_OFFSET + 32 * blobsProvided;\n\n        // Now, we need to double check that the provided input was indeed returned by the L2 DA validator.\n        if (keccak256(_operatorDAInput[:ptr]) != _l2DAValidatorOutputHash) {\n            revert InvalidL2DAOutputHash(_l2DAValidatorOutputHash);\n        }\n\n        // The rest of the output was provided specifically by the operator\n        l1DaInput = _operatorDAInput[ptr:];\n    }\n\n    /// @notice Verify that the calldata DA was correctly provided.\n    /// @param _blobsProvided The number of blobs provided.\n    /// @param _fullPubdataHash Hash of the pubdata preimage.\n    /// @param _maxBlobsSupported Maximum number of blobs supported.\n    /// @param _pubdataInput Full pubdata + an additional 32 bytes containing the blob commitment for the pubdata.\n    /// @dev We supply the blob commitment as part of the pubdata because even with calldata the prover will check these values.\n    function _processCalldataDA(\n        uint256 _blobsProvided,\n        bytes32 _fullPubdataHash,\n        uint256 _maxBlobsSupported,\n        bytes calldata _pubdataInput\n    ) internal pure virtual returns (bytes32[] memory blobCommitments, bytes calldata _pubdata) {\n        if (_blobsProvided != 1) {\n            revert OnlyOneBlobWithCalldataAllowed();\n        }\n        if (_pubdataInput.length < BLOB_COMMITMENT_SIZE) {\n            revert PubdataInputTooSmall(_pubdataInput.length, BLOB_COMMITMENT_SIZE);\n        }\n\n        // We typically do not know whether we'll use calldata or blobs at the time when\n        // we start proving the batch. That's why the blob commitment for a single blob is still present in the case of calldata.\n\n        blobCommitments = new bytes32[](_maxBlobsSupported);\n\n        _pubdata = _pubdataInput[:_pubdataInput.length - BLOB_COMMITMENT_SIZE];\n\n        if (_pubdata.length > BLOB_SIZE_BYTES) {\n            revert PubdataLengthTooBig(_pubdata.length, BLOB_SIZE_BYTES);\n        }\n        if (_fullPubdataHash != keccak256(_pubdata)) {\n            revert InvalidPubdataHash(_fullPubdataHash, keccak256(_pubdata));\n        }\n        blobCommitments[0] = bytes32(_pubdataInput[_pubdataInput.length - BLOB_COMMITMENT_SIZE:_pubdataInput.length]);\n    }\n\n    /// @notice Method that clones a slice of calldata into a bytes32[] memory array.\n    /// @param _dst The destination array.\n    /// @param _input The input calldata.\n    /// @param _len The length of the slice in 32-byte words to clone.\n    function _cloneCalldata(bytes32[] memory _dst, bytes calldata _input, uint256 _len) internal pure {\n        assembly {\n            // The pointer to the allocated memory above. We skip 32 bytes to avoid overwriting the length.\n            let dstPtr := add(_dst, 0x20)\n            let inputPtr := _input.offset\n            calldatacopy(dstPtr, inputPtr, mul(_len, 32))\n        }\n    }\n}\n"
      },
      "contracts/state-transition/data-availability/CalldataDAGateway.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {CalldataDA, BLOB_COMMITMENT_SIZE, BLOB_SIZE_BYTES} from \"./CalldataDA.sol\";\nimport {PubdataInputTooSmall, PubdataLengthTooBig, InvalidPubdataHash} from \"../L1StateTransitionErrors.sol\";\n\n/// @notice Contract that contains the functionality for processing the calldata DA.\n/// @dev The expected l2DAValidator that should be used with it `RollupL2DAValidator`.\nabstract contract CalldataDAGateway is CalldataDA {\n    /// @inheritdoc CalldataDA\n    function _processCalldataDA(\n        uint256 _blobsProvided,\n        bytes32 _fullPubdataHash,\n        uint256 _maxBlobsSupported,\n        bytes calldata _pubdataInput\n    ) internal pure override returns (bytes32[] memory blobCommitments, bytes calldata _pubdata) {\n        if (_pubdataInput.length < _blobsProvided * BLOB_COMMITMENT_SIZE) {\n            revert PubdataInputTooSmall(_pubdataInput.length, _blobsProvided * BLOB_COMMITMENT_SIZE);\n        }\n\n        // We typically do not know whether we'll use calldata or blobs at the time when\n        // we start proving the batch. That's why the blob commitment for a single blob is still present in the case of calldata.\n        blobCommitments = new bytes32[](_maxBlobsSupported);\n\n        _pubdata = _pubdataInput[:_pubdataInput.length - _blobsProvided * BLOB_COMMITMENT_SIZE];\n\n        if (_pubdata.length > _blobsProvided * BLOB_SIZE_BYTES) {\n            revert PubdataLengthTooBig(_pubdata.length, _blobsProvided * BLOB_SIZE_BYTES);\n        }\n        if (_fullPubdataHash != keccak256(_pubdata)) {\n            revert InvalidPubdataHash(_fullPubdataHash, keccak256(_pubdata));\n        }\n\n        bytes calldata providedCommitments = _pubdataInput[_pubdataInput.length -\n            _blobsProvided *\n            BLOB_COMMITMENT_SIZE:];\n\n        _cloneCalldata(blobCommitments, providedCommitments, _blobsProvided);\n    }\n}\n"
      },
      "contracts/state-transition/data-availability/RelayedSLDAValidator.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IL1DAValidator, L1DAValidatorOutput, PubdataSource} from \"../chain-interfaces/IL1DAValidator.sol\";\nimport {IL1Messenger} from \"../../common/interfaces/IL1Messenger.sol\";\n\nimport {CalldataDAGateway} from \"./CalldataDAGateway.sol\";\n\nimport {IBridgehub} from \"../../bridgehub/IBridgehub.sol\";\nimport {L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR, L2_BRIDGEHUB_ADDR} from \"../../common/L2ContractAddresses.sol\";\nimport {BlobHashBlobCommitmentMismatchValue, L1DAValidatorInvalidSender, InvalidPubdataSource} from \"../L1StateTransitionErrors.sol\";\n\n/// @notice The DA validator intended to be used in Era-environment.\n/// @dev For compatibility reasons it accepts calldata in the same format as the `RollupL1DAValidator`, but unlike the latter it\n/// does not support blobs.\n/// @dev Note that it does not provide any compression whatsoever.\ncontract RelayedSLDAValidator is IL1DAValidator, CalldataDAGateway {\n    /// @dev Ensures that the sender is the chain that is supposed to send the message.\n    /// @param _chainId The chain id of the chain that is supposed to send the message.\n    function _ensureOnlyChainSender(uint256 _chainId) internal view {\n        // Note that this contract is only supposed to be deployed on L2, where the\n        // bridgehub is predeployed at `L2_BRIDGEHUB_ADDR` address.\n        if (IBridgehub(L2_BRIDGEHUB_ADDR).getZKChain(_chainId) != msg.sender) {\n            revert L1DAValidatorInvalidSender(msg.sender);\n        }\n    }\n\n    /// @dev Relays the calldata to L1.\n    /// @param _chainId The chain id of the chain that is supposed to send the message.\n    /// @param _batchNumber The batch number for which the data availability is being checked.\n    /// @param _pubdata The pubdata to be relayed to L1.\n    function _relayCalldata(uint256 _chainId, uint256 _batchNumber, bytes calldata _pubdata) internal {\n        // Re-sending all the pubdata in pure form to L1.\n        // slither-disable-next-line unused-return\n        IL1Messenger(L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR).sendToL1(abi.encode(_chainId, _batchNumber, _pubdata));\n    }\n\n    /// @inheritdoc IL1DAValidator\n    function checkDA(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        bytes32 _l2DAValidatorOutputHash,\n        bytes calldata _operatorDAInput,\n        uint256 _maxBlobsSupported\n    ) external returns (L1DAValidatorOutput memory output) {\n        // Unfortunately we have to use a method call instead of a modifier\n        // because of the stack-too-deep error caused by it.\n        _ensureOnlyChainSender(_chainId);\n\n        // Preventing \"stack too deep\" error\n        uint256 blobsProvided;\n        bytes32 fullPubdataHash;\n        bytes calldata l1DaInput;\n        {\n            bytes32 stateDiffHash;\n            bytes32[] memory blobsLinearHashes;\n            (\n                stateDiffHash,\n                fullPubdataHash,\n                blobsLinearHashes,\n                blobsProvided,\n                l1DaInput\n            ) = _processL2RollupDAValidatorOutputHash(_l2DAValidatorOutputHash, _maxBlobsSupported, _operatorDAInput);\n\n            output.stateDiffHash = stateDiffHash;\n            output.blobsLinearHashes = blobsLinearHashes;\n        }\n\n        uint8 pubdataSource = uint8(l1DaInput[0]);\n\n        // Note, that the blobs are not supported in the RelayedSLDAValidator.\n        if (pubdataSource == uint8(PubdataSource.Calldata)) {\n            bytes calldata pubdata;\n            bytes32[] memory blobCommitments;\n\n            (blobCommitments, pubdata) = _processCalldataDA(\n                blobsProvided,\n                fullPubdataHash,\n                _maxBlobsSupported,\n                l1DaInput[1:]\n            );\n\n            _relayCalldata(_chainId, _batchNumber, pubdata);\n\n            output.blobsOpeningCommitments = blobCommitments;\n        } else {\n            revert InvalidPubdataSource(pubdataSource);\n        }\n\n        // We verify that for each set of blobHash/blobCommitment are either both empty\n        // or there are values for both.\n        // This is mostly a sanity check and it is not strictly required.\n        for (uint256 i = 0; i < _maxBlobsSupported; ++i) {\n            if (\n                (output.blobsLinearHashes[i] != bytes32(0) || output.blobsOpeningCommitments[i] != bytes32(0)) &&\n                (output.blobsLinearHashes[i] == bytes32(0) || output.blobsOpeningCommitments[i] == bytes32(0))\n            ) {\n                revert BlobHashBlobCommitmentMismatchValue();\n            }\n        }\n    }\n}\n"
      },
      "contracts/state-transition/data-availability/RollupDAManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {Ownable2Step} from \"@openzeppelin/contracts-v4/access/Ownable2Step.sol\";\nimport {ZeroAddress} from \"../../common/L1ContractErrors.sol\";\n\n/// @title The RollupManager contract\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Responsible for determining which DA pairs are allowed to be used\n/// for permanent rollups.\ncontract RollupDAManager is Ownable2Step {\n    /// @dev Mapping to track the status (enabled/disabled) of each DAPair.\n    mapping(address l1DAValidator => mapping(address l2DAValidator => bool)) public allowedDAPairs;\n\n    /// @dev Emitted when a DAPair is added or updated.\n    /// @param l1DAValidator Address of the L1 data availability validator.\n    /// @param l2DAValidator Address of the L2 data availability validator.\n    /// @param status Boolean representing the state of the DAPair.\n    event DAPairUpdated(address indexed l1DAValidator, address indexed l2DAValidator, bool status);\n\n    /// @dev Modifier to ensure addresses in DAPair are not zero addresses.\n    /// @param l1DAValidator Address of the L1 data availability validator.\n    /// @param l2DAValidator Address of the L2 data availability validator.\n    modifier validAddresses(address l1DAValidator, address l2DAValidator) {\n        if (l1DAValidator == address(0) || l2DAValidator == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    /// @dev Adds or updates a DAPair in the `allowedDAPairs` mapping. Only callable by the contract owner.\n    ///\n    /// Emits a {DAPairUpdated} event.\n    ///\n    /// @param _l1DAValidator Address of the L1 data availability validator.\n    /// @param _l2DAValidator Address of the L2 data availability validator.\n    /// @param _status Boolean representing whether the DAPair is active or not.\n    ///\n    /// Requirements:\n    ///\n    /// - The `l1DAValidator` and `l2DAValidator` must be valid addresses (non-zero).\n    /// - Only the owner of the contract can call this function.\n    function updateDAPair(\n        address _l1DAValidator,\n        address _l2DAValidator,\n        bool _status\n    ) external onlyOwner validAddresses(_l1DAValidator, _l2DAValidator) {\n        allowedDAPairs[_l1DAValidator][_l2DAValidator] = _status;\n\n        emit DAPairUpdated(_l1DAValidator, _l2DAValidator, _status);\n    }\n\n    /// @notice Returns whether the DA pair is allowed.\n    ///\n    /// @param _l1DAValidator Address of the L1 data availability validator.\n    /// @param _l2DAValidator Address of the L2 data availability validator.\n    /// @return bool indicating if the DA pair is allowed.\n    function isPairAllowed(address _l1DAValidator, address _l2DAValidator) external view returns (bool) {\n        return allowedDAPairs[_l1DAValidator][_l2DAValidator];\n    }\n}\n"
      },
      "contracts/state-transition/data-availability/ValidiumL1DAValidator.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IL1DAValidator, L1DAValidatorOutput} from \"../chain-interfaces/IL1DAValidator.sol\";\nimport {ValL1DAWrongInputLength} from \"../L1StateTransitionErrors.sol\";\n\ncontract ValidiumL1DAValidator is IL1DAValidator {\n    function checkDA(\n        uint256, // _chainId\n        uint256, // _batchNumber\n        bytes32, // _l2DAValidatorOutputHash\n        bytes calldata _operatorDAInput,\n        uint256 maxBlobsSupported\n    ) external override returns (L1DAValidatorOutput memory output) {\n        // For Validiums, we expect the operator to just provide the data for us.\n        // We don't need to do any checks with regard to the l2DAValidatorOutputHash.\n        if (_operatorDAInput.length != 32) {\n            revert ValL1DAWrongInputLength(_operatorDAInput.length, 32);\n        }\n        bytes32 stateDiffHash = abi.decode(_operatorDAInput, (bytes32));\n\n        // The rest of the fields that relate to blobs are empty.\n        output.stateDiffHash = stateDiffHash;\n\n        output.blobsLinearHashes = new bytes32[](maxBlobsSupported);\n        output.blobsOpeningCommitments = new bytes32[](maxBlobsSupported);\n    }\n}\n"
      },
      "contracts/state-transition/l2-deps/IComplexUpgrader.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IComplexUpgrader {\n    function upgrade(address _delegateTo, bytes calldata _calldata) external payable;\n}\n"
      },
      "contracts/state-transition/l2-deps/IL2GatewayUpgrade.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IL2ContractDeployer} from \"../../common/interfaces/IL2ContractDeployer.sol\";\n\ninterface IL2GatewayUpgrade {\n    function upgrade(\n        IL2ContractDeployer.ForceDeployment[] calldata _forceDeployments,\n        address _ctmDeployer,\n        bytes calldata _fixedForceDeploymentsData,\n        bytes calldata _additionalForceDeploymentsData\n    ) external payable;\n}\n"
      },
      "contracts/state-transition/l2-deps/IL2GenesisUpgrade.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/// @notice A struct that describes a forced deployment on an address\nstruct ForceDeployment {\n    // The bytecode hash to put on an address\n    bytes32 bytecodeHash;\n    // The address on which to deploy the bytecodehash to\n    address newAddress;\n    // Whether to run the constructor on the force deployment\n    bool callConstructor;\n    // The value with which to initialize a contract\n    uint256 value;\n    // The constructor calldata\n    bytes input;\n}\n\n// solhint-disable-next-line gas-struct-packing\nstruct ZKChainSpecificForceDeploymentsData {\n    bytes32 baseTokenAssetId;\n    address l2LegacySharedBridge;\n    address predeployedL2WethAddress;\n    address baseTokenL1Address;\n    /// @dev Some info about the base token, it is\n    /// needed to deploy weth token in case it is not present\n    string baseTokenName;\n    string baseTokenSymbol;\n}\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IL2GenesisUpgrade {\n    event UpgradeComplete(uint256 _chainId);\n\n    function genesisUpgrade(\n        uint256 _chainId,\n        address _ctmDeployer,\n        bytes calldata _fixedForceDeploymentsData,\n        bytes calldata _additionalForceDeploymentsData\n    ) external payable;\n}\n"
      },
      "contracts/state-transition/l2-deps/ISystemContext.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface ISystemContext {\n    function setChainId(uint256 _newChainId) external;\n}\n"
      },
      "contracts/state-transition/libraries/BatchDecoder.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {IExecutor} from \"../chain-interfaces/IExecutor.sol\";\nimport {PriorityOpsBatchInfo} from \"./PriorityTree.sol\";\nimport {IncorrectBatchBounds, EmptyData, UnsupportedCommitBatchEncoding, UnsupportedProofBatchEncoding, UnsupportedExecuteBatchEncoding} from \"../../common/L1ContractErrors.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Utility library for decoding and validating batch data.\n/// @dev This library decodes commit, proof, and execution batch data and verifies batch number bounds.\n///      It reverts with custom errors when the data is invalid or unsupported encoding is used.\nlibrary BatchDecoder {\n    /// @notice The currently supported encoding version.\n    uint8 internal constant SUPPORTED_ENCODING_VERSION = 0;\n\n    /// @notice Decodes commit data from a calldata bytes into the last committed batch data and an array of new batch data.\n    /// @param _commitData The calldata byte array containing the data for committing batches.\n    /// @return lastCommittedBatchData The data for the batch before newly committed batches.\n    /// @return newBatchesData An array containing the newly committed batches.\n    function _decodeCommitData(\n        bytes calldata _commitData\n    )\n        private\n        pure\n        returns (\n            IExecutor.StoredBatchInfo memory lastCommittedBatchData,\n            IExecutor.CommitBatchInfo[] memory newBatchesData\n        )\n    {\n        if (_commitData.length == 0) {\n            revert EmptyData();\n        }\n\n        uint8 encodingVersion = uint8(_commitData[0]);\n        if (encodingVersion == SUPPORTED_ENCODING_VERSION) {\n            (lastCommittedBatchData, newBatchesData) = abi.decode(\n                _commitData[1:],\n                (IExecutor.StoredBatchInfo, IExecutor.CommitBatchInfo[])\n            );\n        } else {\n            revert UnsupportedCommitBatchEncoding(encodingVersion);\n        }\n    }\n\n    /// @notice Decodes the commit data and checks that the provided batch bounds are correct.\n    /// @dev Note that it only checks that the last and the first batches in the array correspond to the provided bounds.\n    /// The fact that the batches inside the array are provided in the correct order should be checked by the caller.\n    /// @param _commitData The calldata byte array containing the data for committing batches.\n    /// @param _processBatchFrom The expected batch number of the first commit batch in the array.\n    /// @param _processBatchTo The expected batch number of the last commit batch in the array.\n    /// @return lastCommittedBatchData The data for the batch before newly committed batches.\n    /// @return newBatchesData An array containing the newly committed batches.\n    function decodeAndCheckCommitData(\n        bytes calldata _commitData,\n        uint256 _processBatchFrom,\n        uint256 _processBatchTo\n    )\n        internal\n        pure\n        returns (\n            IExecutor.StoredBatchInfo memory lastCommittedBatchData,\n            IExecutor.CommitBatchInfo[] memory newBatchesData\n        )\n    {\n        (lastCommittedBatchData, newBatchesData) = _decodeCommitData(_commitData);\n\n        if (newBatchesData.length == 0) {\n            revert EmptyData();\n        }\n\n        if (\n            newBatchesData[0].batchNumber != _processBatchFrom ||\n            newBatchesData[newBatchesData.length - 1].batchNumber != _processBatchTo\n        ) {\n            revert IncorrectBatchBounds(\n                _processBatchFrom,\n                _processBatchTo,\n                newBatchesData[0].batchNumber,\n                newBatchesData[newBatchesData.length - 1].batchNumber\n            );\n        }\n    }\n\n    /// @notice Decodes proof data from a calldata byte array into the previous batch, an array of proved batches, and a proof array.\n    /// @param _proofData The calldata byte array containing the data for proving batches.\n    /// @return prevBatch The batch information before the batches to be verified.\n    /// @return provedBatches An array containing the the batches to be verified.\n    /// @return proof An array containing the proof for the verifier.\n    function _decodeProofData(\n        bytes calldata _proofData\n    )\n        private\n        pure\n        returns (\n            IExecutor.StoredBatchInfo memory prevBatch,\n            IExecutor.StoredBatchInfo[] memory provedBatches,\n            uint256[] memory proof\n        )\n    {\n        uint8 encodingVersion = uint8(_proofData[0]);\n        if (encodingVersion == SUPPORTED_ENCODING_VERSION) {\n            (prevBatch, provedBatches, proof) = abi.decode(\n                _proofData[1:],\n                (IExecutor.StoredBatchInfo, IExecutor.StoredBatchInfo[], uint256[])\n            );\n        } else {\n            revert UnsupportedProofBatchEncoding(encodingVersion);\n        }\n    }\n\n    /// @notice Decodes the commit data and checks that the provided batch bounds are correct.\n    /// @dev Note that it only checks that the last and the first batches in the array correspond to the provided bounds.\n    /// The fact that the batches inside the array are provided in the correct order should be checked by the caller.\n    /// @param _proofData The commit data to decode.\n    /// @param _processBatchFrom The expected batch number of the first batch in the array.\n    /// @param _processBatchTo The expected batch number of the last batch in the array.\n    /// @return prevBatch The batch information before the batches to be verified.\n    /// @return provedBatches An array containing the the batches to be verified.\n    /// @return proof An array containing the proof for the verifier.\n    function decodeAndCheckProofData(\n        bytes calldata _proofData,\n        uint256 _processBatchFrom,\n        uint256 _processBatchTo\n    )\n        internal\n        pure\n        returns (\n            IExecutor.StoredBatchInfo memory prevBatch,\n            IExecutor.StoredBatchInfo[] memory provedBatches,\n            uint256[] memory proof\n        )\n    {\n        (prevBatch, provedBatches, proof) = _decodeProofData(_proofData);\n\n        if (provedBatches.length == 0) {\n            revert EmptyData();\n        }\n\n        if (\n            provedBatches[0].batchNumber != _processBatchFrom ||\n            provedBatches[provedBatches.length - 1].batchNumber != _processBatchTo\n        ) {\n            revert IncorrectBatchBounds(\n                _processBatchFrom,\n                _processBatchTo,\n                provedBatches[0].batchNumber,\n                provedBatches[provedBatches.length - 1].batchNumber\n            );\n        }\n    }\n\n    /// @notice Decodes execution data from a calldata byte array into an array of stored batch information.\n    /// @param _executeData The calldata byte array containing the execution data to decode.\n    /// @return executeData An array containing the stored batch information for execution.\n    /// @return priorityOpsData Merkle proofs of the priority operations for each batch.\n    function _decodeExecuteData(\n        bytes calldata _executeData\n    )\n        private\n        pure\n        returns (IExecutor.StoredBatchInfo[] memory executeData, PriorityOpsBatchInfo[] memory priorityOpsData)\n    {\n        if (_executeData.length == 0) {\n            revert EmptyData();\n        }\n\n        uint8 encodingVersion = uint8(_executeData[0]);\n        if (encodingVersion == SUPPORTED_ENCODING_VERSION) {\n            (executeData, priorityOpsData) = abi.decode(\n                _executeData[1:],\n                (IExecutor.StoredBatchInfo[], PriorityOpsBatchInfo[])\n            );\n        } else {\n            revert UnsupportedExecuteBatchEncoding(encodingVersion);\n        }\n    }\n\n    /// @notice Decodes the execute data and checks that the provided batch bounds are correct.\n    /// @dev Note that it only checks that the last and the first batches in the array correspond to the provided bounds.\n    /// The fact that the batches inside the array are provided in the correct order should be checked by the caller.\n    /// @param _executeData The calldata byte array containing the execution data to decode.\n    /// @param _processBatchFrom The expected batch number of the first batch in the array.\n    /// @param _processBatchTo The expected batch number of the last batch in the array.\n    /// @return executeData An array containing the stored batch information for execution.\n    /// @return priorityOpsData Merkle proofs of the priority operations for each batch.\n    function decodeAndCheckExecuteData(\n        bytes calldata _executeData,\n        uint256 _processBatchFrom,\n        uint256 _processBatchTo\n    )\n        internal\n        pure\n        returns (IExecutor.StoredBatchInfo[] memory executeData, PriorityOpsBatchInfo[] memory priorityOpsData)\n    {\n        (executeData, priorityOpsData) = _decodeExecuteData(_executeData);\n\n        if (executeData.length == 0) {\n            revert EmptyData();\n        }\n\n        if (\n            executeData[0].batchNumber != _processBatchFrom ||\n            executeData[executeData.length - 1].batchNumber != _processBatchTo\n        ) {\n            revert IncorrectBatchBounds(\n                _processBatchFrom,\n                _processBatchTo,\n                executeData[0].batchNumber,\n                executeData[executeData.length - 1].batchNumber\n            );\n        }\n    }\n}\n"
      },
      "contracts/state-transition/libraries/Diamond.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {SafeCast} from \"@openzeppelin/contracts-v4/utils/math/SafeCast.sol\";\nimport {UncheckedMath} from \"../../common/libraries/UncheckedMath.sol\";\nimport {NoFunctionsForDiamondCut, UndefinedDiamondCutAction, AddressHasNoCode, FacetExists, RemoveFunctionFacetAddressZero, SelectorsMustAllHaveSameFreezability, NonEmptyCalldata, ReplaceFunctionFacetAddressZero, RemoveFunctionFacetAddressNotZero, DelegateCallFailed} from \"../../common/L1ContractErrors.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The helper library for managing the EIP-2535 diamond proxy.\nlibrary Diamond {\n    using UncheckedMath for uint256;\n    using SafeCast for uint256;\n\n    /// @dev Magic value that should be returned by diamond cut initialize contracts.\n    /// @dev Used to distinguish calls to contracts that were supposed to be used as diamond initializer from other contracts.\n    bytes32 internal constant DIAMOND_INIT_SUCCESS_RETURN_VALUE =\n        0x33774e659306e47509050e97cb651e731180a42d458212294d30751925c551a2; // keccak256(\"diamond.zksync.init\") - 1\n\n    /// @dev Storage position of `DiamondStorage` structure.\n    bytes32 private constant DIAMOND_STORAGE_POSITION =\n        0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131b; // keccak256(\"diamond.standard.diamond.storage\") - 1;\n\n    event DiamondCut(FacetCut[] facetCuts, address initAddress, bytes initCalldata);\n\n    /// @dev Utility struct that contains associated facet & meta information of selector\n    /// @param facetAddress address of the facet which is connected with selector\n    /// @param selectorPosition index in `FacetToSelectors.selectors` array, where is selector stored\n    /// @param isFreezable denotes whether the selector can be frozen.\n    struct SelectorToFacet {\n        address facetAddress;\n        uint16 selectorPosition;\n        bool isFreezable;\n    }\n\n    /// @dev Utility struct that contains associated selectors & meta information of facet\n    /// @param selectors list of all selectors that belong to the facet\n    /// @param facetPosition index in `DiamondStorage.facets` array, where is facet stored\n    struct FacetToSelectors {\n        bytes4[] selectors;\n        uint16 facetPosition;\n    }\n\n    /// @notice The structure that holds all diamond proxy associated parameters\n    /// @dev According to the EIP-2535 should be stored on a special storage key - `DIAMOND_STORAGE_POSITION`\n    /// @param selectorToFacet A mapping from the selector to the facet address and its meta information\n    /// @param facetToSelectors A mapping from facet address to its selectors with meta information\n    /// @param facets The array of all unique facet addresses that belong to the diamond proxy\n    /// @param isFrozen Denotes whether the diamond proxy is frozen and all freezable facets are not accessible\n    struct DiamondStorage {\n        mapping(bytes4 selector => SelectorToFacet selectorInfo) selectorToFacet;\n        mapping(address facetAddress => FacetToSelectors facetInfo) facetToSelectors;\n        address[] facets;\n        bool isFrozen;\n    }\n\n    /// @dev Parameters for diamond changes that touch one of the facets\n    /// @param facet The address of facet that's affected by the cut\n    /// @param action The action that is made on the facet\n    /// @param isFreezable Denotes whether the facet & all their selectors can be frozen\n    /// @param selectors An array of unique selectors that belongs to the facet address\n    // solhint-disable-next-line gas-struct-packing\n    struct FacetCut {\n        address facet;\n        Action action;\n        bool isFreezable;\n        bytes4[] selectors;\n    }\n\n    /// @dev Structure of the diamond proxy changes\n    /// @param facetCuts The set of changes (adding/removing/replacement) of implementation contracts\n    /// @param initAddress The address that's delegate called after setting up new facet changes\n    /// @param initCalldata Calldata for the delegate call to `initAddress`\n    struct DiamondCutData {\n        FacetCut[] facetCuts;\n        address initAddress;\n        bytes initCalldata;\n    }\n\n    /// @dev Type of change over diamond: add/replace/remove facets\n    enum Action {\n        Add,\n        Replace,\n        Remove\n    }\n\n    /// @return diamondStorage The pointer to the storage where all specific diamond proxy parameters stored\n    function getDiamondStorage() internal pure returns (DiamondStorage storage diamondStorage) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            diamondStorage.slot := position\n        }\n    }\n\n    /// @dev Add/replace/remove any number of selectors and optionally execute a function with delegatecall\n    /// @param _diamondCut Diamond's facet changes and the parameters to optional initialization delegatecall\n    function diamondCut(DiamondCutData memory _diamondCut) internal {\n        FacetCut[] memory facetCuts = _diamondCut.facetCuts;\n        address initAddress = _diamondCut.initAddress;\n        bytes memory initCalldata = _diamondCut.initCalldata;\n        uint256 facetCutsLength = facetCuts.length;\n        for (uint256 i = 0; i < facetCutsLength; i = i.uncheckedInc()) {\n            Action action = facetCuts[i].action;\n            address facet = facetCuts[i].facet;\n            bool isFacetFreezable = facetCuts[i].isFreezable;\n            bytes4[] memory selectors = facetCuts[i].selectors;\n\n            if (selectors.length == 0) {\n                revert NoFunctionsForDiamondCut();\n            }\n\n            if (action == Action.Add) {\n                _addFunctions(facet, selectors, isFacetFreezable);\n            } else if (action == Action.Replace) {\n                _replaceFunctions(facet, selectors, isFacetFreezable);\n            } else if (action == Action.Remove) {\n                _removeFunctions(facet, selectors);\n            } else {\n                revert UndefinedDiamondCutAction();\n            }\n        }\n\n        _initializeDiamondCut(initAddress, initCalldata);\n        emit DiamondCut(facetCuts, initAddress, initCalldata);\n    }\n\n    /// @dev Add new functions to the diamond proxy\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\n    function _addFunctions(address _facet, bytes4[] memory _selectors, bool _isFacetFreezable) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        // Facet with no code cannot be added.\n        // This check also verifies that the facet does not have zero address, since it is the\n        // address with which 0x00000000 selector is associated.\n        if (_facet.code.length == 0) {\n            revert AddressHasNoCode(_facet);\n        }\n\n        // Add facet to the list of facets if the facet address is new one\n        _saveFacetIfNew(_facet);\n\n        uint256 selectorsLength = _selectors.length;\n        for (uint256 i = 0; i < selectorsLength; i = i.uncheckedInc()) {\n            bytes4 selector = _selectors[i];\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\n            if (oldFacet.facetAddress != address(0)) {\n                revert FacetExists(selector, oldFacet.facetAddress);\n            }\n\n            _addOneFunction(_facet, selector, _isFacetFreezable);\n        }\n    }\n\n    /// @dev Change associated facets to already known function selectors\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\n    function _replaceFunctions(address _facet, bytes4[] memory _selectors, bool _isFacetFreezable) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        // Facet with no code cannot be added.\n        // This check also verifies that the facet does not have zero address, since it is the\n        // address with which 0x00000000 selector is associated.\n        if (_facet.code.length == 0) {\n            revert AddressHasNoCode(_facet);\n        }\n\n        uint256 selectorsLength = _selectors.length;\n        for (uint256 i = 0; i < selectorsLength; i = i.uncheckedInc()) {\n            bytes4 selector = _selectors[i];\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\n            // it is impossible to replace the facet with zero address\n            if (oldFacet.facetAddress == address(0)) {\n                revert ReplaceFunctionFacetAddressZero();\n            }\n\n            _removeOneFunction(oldFacet.facetAddress, selector);\n            // Add facet to the list of facets if the facet address is a new one\n            _saveFacetIfNew(_facet);\n            _addOneFunction(_facet, selector, _isFacetFreezable);\n        }\n    }\n\n    /// @dev Remove association with function and facet\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\n    function _removeFunctions(address _facet, bytes4[] memory _selectors) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        // facet address must be zero\n        if (_facet != address(0)) {\n            revert RemoveFunctionFacetAddressNotZero(_facet);\n        }\n\n        uint256 selectorsLength = _selectors.length;\n        for (uint256 i = 0; i < selectorsLength; i = i.uncheckedInc()) {\n            bytes4 selector = _selectors[i];\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\n            // Can't delete a non-existent facet\n            if (oldFacet.facetAddress == address(0)) {\n                revert RemoveFunctionFacetAddressZero();\n            }\n\n            _removeOneFunction(oldFacet.facetAddress, selector);\n        }\n    }\n\n    /// @dev Add address to the list of known facets if it is not on the list yet\n    /// NOTE: should be called ONLY before adding a new selector associated with the address\n    function _saveFacetIfNew(address _facet) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        uint256 selectorsLength = ds.facetToSelectors[_facet].selectors.length;\n        // If there are no selectors associated with facet then save facet as new one\n        if (selectorsLength == 0) {\n            ds.facetToSelectors[_facet].facetPosition = ds.facets.length.toUint16();\n            ds.facets.push(_facet);\n        }\n    }\n\n    /// @dev Add one function to the already known facet\n    /// NOTE: It is expected but NOT enforced that:\n    /// - `_facet` is NON-ZERO address\n    /// - `_facet` is already stored address in `DiamondStorage.facets`\n    /// - `_selector` is NOT associated by another facet\n    function _addOneFunction(address _facet, bytes4 _selector, bool _isSelectorFreezable) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        uint16 selectorPosition = (ds.facetToSelectors[_facet].selectors.length).toUint16();\n\n        // if selectorPosition is nonzero, it means it is not a new facet\n        // so the freezability of the first selector must be matched to _isSelectorFreezable\n        // so all the selectors in a facet will have the same freezability\n        if (selectorPosition != 0) {\n            bytes4 selector0 = ds.facetToSelectors[_facet].selectors[0];\n            if (_isSelectorFreezable != ds.selectorToFacet[selector0].isFreezable) {\n                revert SelectorsMustAllHaveSameFreezability();\n            }\n        }\n\n        ds.selectorToFacet[_selector] = SelectorToFacet({\n            facetAddress: _facet,\n            selectorPosition: selectorPosition,\n            isFreezable: _isSelectorFreezable\n        });\n        ds.facetToSelectors[_facet].selectors.push(_selector);\n    }\n\n    /// @dev Remove one associated function with facet\n    /// NOTE: It is expected but NOT enforced that `_facet` is NON-ZERO address\n    function _removeOneFunction(address _facet, bytes4 _selector) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        // Get index of `FacetToSelectors.selectors` of the selector and last element of array\n        uint256 selectorPosition = ds.selectorToFacet[_selector].selectorPosition;\n        uint256 lastSelectorPosition = ds.facetToSelectors[_facet].selectors.length - 1;\n\n        // If the selector is not at the end of the array then move the last element to the selector position\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetToSelectors[_facet].selectors[lastSelectorPosition];\n\n            ds.facetToSelectors[_facet].selectors[selectorPosition] = lastSelector;\n            ds.selectorToFacet[lastSelector].selectorPosition = selectorPosition.toUint16();\n        }\n\n        // Remove last element from the selectors array\n        ds.facetToSelectors[_facet].selectors.pop();\n\n        // Finally, clean up the association with facet\n        delete ds.selectorToFacet[_selector];\n\n        // If there are no selectors for facet then remove the facet from the list of known facets\n        if (lastSelectorPosition == 0) {\n            _removeFacet(_facet);\n        }\n    }\n\n    /// @dev remove facet from the list of known facets\n    /// NOTE: It is expected but NOT enforced that there are no selectors associated with `_facet`\n    function _removeFacet(address _facet) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        // Get index of `DiamondStorage.facets` of the facet and last element of array\n        uint256 facetPosition = ds.facetToSelectors[_facet].facetPosition;\n        uint256 lastFacetPosition = ds.facets.length - 1;\n\n        // If the facet is not at the end of the array then move the last element to the facet position\n        if (facetPosition != lastFacetPosition) {\n            address lastFacet = ds.facets[lastFacetPosition];\n\n            ds.facets[facetPosition] = lastFacet;\n            ds.facetToSelectors[lastFacet].facetPosition = facetPosition.toUint16();\n        }\n\n        // Remove last element from the facets array\n        ds.facets.pop();\n    }\n\n    /// @dev Delegates call to the initialization address with provided calldata\n    /// @dev Used as a final step of diamond cut to execute the logic of the initialization for changed facets\n    function _initializeDiamondCut(address _init, bytes memory _calldata) private {\n        if (_init == address(0)) {\n            // Non-empty calldata for zero address\n            if (_calldata.length != 0) {\n                revert NonEmptyCalldata();\n            }\n        } else {\n            // Do not check whether `_init` is a contract since later we check that it returns data.\n            (bool success, bytes memory data) = _init.delegatecall(_calldata);\n            if (!success) {\n                // If the returndata is too small, we still want to produce some meaningful error\n\n                if (data.length < 4) {\n                    revert DelegateCallFailed(data);\n                }\n\n                assembly {\n                    revert(add(data, 0x20), mload(data))\n                }\n            }\n\n            // Check that called contract returns magic value to make sure that contract logic\n            // supposed to be used as diamond cut initializer.\n            if (data.length != 32) {\n                revert DelegateCallFailed(data);\n            }\n            if (abi.decode(data, (bytes32)) != DIAMOND_INIT_SUCCESS_RETURN_VALUE) {\n                revert DelegateCallFailed(data);\n            }\n        }\n    }\n}\n"
      },
      "contracts/state-transition/libraries/LibMap.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\n/// @notice Library for storage of packed unsigned integers.\n/// @author Matter Labs\n/// @dev This library is an adaptation of the corresponding Solady library (https://github.com/vectorized/solady/blob/main/src/utils/LibMap.sol)\n/// @custom:security-contact security@matterlabs.dev\nlibrary LibMap {\n    /// @dev A uint32 map in storage.\n    struct Uint32Map {\n        mapping(uint256 packedIndex => uint256 eightPackedValues) map;\n    }\n\n    /// @dev Retrieves the uint32 value at a specific index from the Uint32Map.\n    /// @param _map The Uint32Map instance containing the packed uint32 values.\n    /// @param _index The index of the uint32 value to retrieve.\n    /// @return result The uint32 value at the specified index.\n    function get(Uint32Map storage _map, uint256 _index) internal view returns (uint32 result) {\n        unchecked {\n            // Each storage slot can store 256 bits of data.\n            // As uint32 is 32 bits long, 8 uint32s can be packed into one storage slot.\n            // Hence, `_index / 8` is done to find the storage slot that contains the required uint32.\n            uint256 mapValue = _map.map[_index / 8];\n\n            // First three bits of the original `_index` denotes the position of the uint32 in that slot.\n            // So, '(_index & 7) * 32' is done to find the bit position of the uint32 in that storage slot.\n            uint256 bitOffset = (_index & 7) * 32;\n\n            // Shift the bits to the right and retrieve the uint32 value.\n            result = uint32(mapValue >> bitOffset);\n        }\n    }\n\n    /// @dev Updates the uint32 value at `_index` in `map`.\n    /// @param _map The Uint32Map instance containing the packed uint32 values.\n    /// @param _index The index of the uint32 value to set.\n    /// @param _value The new value at the specified index.\n    function set(Uint32Map storage _map, uint256 _index, uint32 _value) internal {\n        unchecked {\n            // Each storage slot can store 256 bits of data.\n            // As uint32 is 32 bits long, 8 uint32s can be packed into one storage slot.\n            // Hence, `_index / 8` is done to find the storage slot that contains the required uint32.\n            uint256 mapIndex = _index / 8;\n            uint256 mapValue = _map.map[mapIndex];\n\n            // First three bits of the original `_index` denotes the position of the uint32 in that slot.\n            // So, '(_index & 7) * 32' is done to find the bit position of the uint32 in that storage slot.\n            uint256 bitOffset = (_index & 7) * 32;\n\n            // XORing a value A with B, and then with A again, gives the original value B.\n            // We will use this property to update the uint32 value in the slot.\n\n            // Shift the bits to the right and retrieve the uint32 value.\n            uint32 oldValue = uint32(mapValue >> bitOffset);\n\n            // Calculate the XOR of the new value and the existing value.\n            uint256 newValueXorOldValue = uint256(oldValue ^ _value);\n\n            // Finally, we XOR the slot with the XOR of the new value and the existing value,\n            // shifted to its proper position. The XOR operation will effectively replace the old value with the new value.\n            _map.map[mapIndex] = (newValueXorOldValue << bitOffset) ^ mapValue;\n        }\n    }\n}\n"
      },
      "contracts/state-transition/libraries/PriorityQueue.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {QueueIsEmpty} from \"../../common/L1ContractErrors.sol\";\n\n/// @notice The structure that contains meta information of the L2 transaction that was requested from L1\n/// @dev The weird size of fields was selected specifically to minimize the structure storage size\n/// @param canonicalTxHash Hashed L2 transaction data that is needed to process it\n/// @param expirationTimestamp Expiration timestamp for this request (must be satisfied before)\n/// @param layer2Tip Additional payment to the validator as an incentive to perform the operation\nstruct PriorityOperation {\n    bytes32 canonicalTxHash;\n    uint64 expirationTimestamp;\n    uint192 layer2Tip;\n}\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev The library provides the API to interact with the priority queue container\n/// @dev Order of processing operations from queue - FIFO (Fist in - first out)\nlibrary PriorityQueue {\n    using PriorityQueue for Queue;\n\n    /// @notice Container that stores priority operations\n    /// @param data The inner mapping that saves priority operation by its index\n    /// @param head The pointer to the first unprocessed priority operation, equal to the tail if the queue is empty\n    /// @param tail The pointer to the free slot\n    struct Queue {\n        mapping(uint256 priorityOpId => PriorityOperation priorityOp) data;\n        uint256 tail;\n        uint256 head;\n    }\n\n    /// @notice Returns zero if and only if no operations were processed from the queue\n    /// @return Index of the oldest priority operation that wasn't processed yet\n    function getFirstUnprocessedPriorityTx(Queue storage _queue) internal view returns (uint256) {\n        return _queue.head;\n    }\n\n    /// @return The total number of priority operations that were added to the priority queue, including all processed ones\n    function getTotalPriorityTxs(Queue storage _queue) internal view returns (uint256) {\n        return _queue.tail;\n    }\n\n    /// @return The total number of unprocessed priority operations in a priority queue\n    function getSize(Queue storage _queue) internal view returns (uint256) {\n        return uint256(_queue.tail - _queue.head);\n    }\n\n    /// @return Whether the priority queue contains no operations\n    function isEmpty(Queue storage _queue) internal view returns (bool) {\n        return _queue.tail == _queue.head;\n    }\n\n    /// @notice Add the priority operation to the end of the priority queue\n    function pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\n        // Save value into the stack to avoid double reading from the storage\n        uint256 tail = _queue.tail;\n\n        _queue.data[tail] = _operation;\n        _queue.tail = tail + 1;\n    }\n\n    /// @return The first unprocessed priority operation from the queue\n    function front(Queue storage _queue) internal view returns (PriorityOperation memory) {\n        // priority queue is empty\n        if (_queue.isEmpty()) {\n            revert QueueIsEmpty();\n        }\n\n        return _queue.data[_queue.head];\n    }\n\n    /// @notice Remove the first unprocessed priority operation from the queue\n    /// @return priorityOperation that was popped from the priority queue\n    function popFront(Queue storage _queue) internal returns (PriorityOperation memory priorityOperation) {\n        // priority queue is empty\n        if (_queue.isEmpty()) {\n            revert QueueIsEmpty();\n        }\n\n        // Save value into the stack to avoid double reading from the storage\n        uint256 head = _queue.head;\n\n        priorityOperation = _queue.data[head];\n        delete _queue.data[head];\n        _queue.head = head + 1;\n    }\n}\n"
      },
      "contracts/state-transition/libraries/PriorityTree.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the zkSync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {DynamicIncrementalMerkle} from \"../../common/libraries/DynamicIncrementalMerkle.sol\";\nimport {Merkle} from \"../../common/libraries/Merkle.sol\";\nimport {PriorityTreeCommitment} from \"../../common/Config.sol\";\nimport {NotHistoricalRoot, InvalidCommitment, InvalidStartIndex, InvalidUnprocessedIndex, InvalidNextLeafIndex} from \"../L1StateTransitionErrors.sol\";\n\nstruct PriorityOpsBatchInfo {\n    bytes32[] leftPath;\n    bytes32[] rightPath;\n    bytes32[] itemHashes;\n}\n\nbytes32 constant ZERO_LEAF_HASH = keccak256(\"\");\n\nlibrary PriorityTree {\n    using PriorityTree for Tree;\n    using DynamicIncrementalMerkle for DynamicIncrementalMerkle.Bytes32PushTree;\n\n    struct Tree {\n        uint256 startIndex; // priority tree started accepting priority ops from this index\n        uint256 unprocessedIndex; // relative to `startIndex`\n        mapping(bytes32 => bool) historicalRoots;\n        DynamicIncrementalMerkle.Bytes32PushTree tree;\n    }\n\n    /// @notice Returns zero if and only if no operations were processed from the tree\n    /// @return Index of the oldest priority operation that wasn't processed yet\n    function getFirstUnprocessedPriorityTx(Tree storage _tree) internal view returns (uint256) {\n        return _tree.startIndex + _tree.unprocessedIndex;\n    }\n\n    /// @return The total number of priority operations that were added to the priority queue, including all processed ones\n    function getTotalPriorityTxs(Tree storage _tree) internal view returns (uint256) {\n        return _tree.startIndex + _tree.tree._nextLeafIndex;\n    }\n\n    /// @return The total number of unprocessed priority operations in a priority queue\n    function getSize(Tree storage _tree) internal view returns (uint256) {\n        return _tree.tree._nextLeafIndex - _tree.unprocessedIndex;\n    }\n\n    /// @notice Add the priority operation to the end of the priority queue\n    function push(Tree storage _tree, bytes32 _hash) internal {\n        (, bytes32 newRoot) = _tree.tree.push(_hash);\n        _tree.historicalRoots[newRoot] = true;\n    }\n\n    /// @notice Set up the tree\n    function setup(Tree storage _tree, uint256 _startIndex) internal {\n        bytes32 initialRoot = _tree.tree.setup(ZERO_LEAF_HASH);\n        _tree.historicalRoots[initialRoot] = true;\n        _tree.startIndex = _startIndex;\n    }\n\n    /// @return Returns the tree root.\n    function getRoot(Tree storage _tree) internal view returns (bytes32) {\n        return _tree.tree.root();\n    }\n\n    /// @param _root The root to check.\n    /// @return Returns true if the root is a historical root.\n    function isHistoricalRoot(Tree storage _tree, bytes32 _root) internal view returns (bool) {\n        return _tree.historicalRoots[_root];\n    }\n\n    /// @notice Process the priority operations of a batch.\n    /// @dev Note, that the function below only checks that a certain segment of items is present in the tree.\n    /// It does not check that e.g. there are no zero items inside the provided `itemHashes`, so in theory proofs\n    /// that include non-existing priority operations could be created. This function relies on the fact\n    /// that the `itemHashes` of `_priorityOpsData` are hashes of valid priority transactions.\n    /// This fact is ensures by the fact the rolling hash of those is sent to the Executor by the bootloader\n    /// and so assuming that zero knowledge proofs are correct, so is the structure of the `itemHashes`.\n    function processBatch(Tree storage _tree, PriorityOpsBatchInfo memory _priorityOpsData) internal {\n        if (_priorityOpsData.itemHashes.length > 0) {\n            bytes32 expectedRoot = Merkle.calculateRootPaths(\n                _priorityOpsData.leftPath,\n                _priorityOpsData.rightPath,\n                _tree.unprocessedIndex,\n                _priorityOpsData.itemHashes\n            );\n            if (!_tree.historicalRoots[expectedRoot]) {\n                revert NotHistoricalRoot();\n            }\n            _tree.unprocessedIndex += _priorityOpsData.itemHashes.length;\n        }\n    }\n\n    /// @notice Allows to skip a certain number of operations.\n    /// @param _lastUnprocessed The new expected id of the unprocessed transaction.\n    /// @dev It is used when the corresponding transactions have been processed by priority queue.\n    function skipUntil(Tree storage _tree, uint256 _lastUnprocessed) internal {\n        if (_tree.startIndex > _lastUnprocessed) {\n            // Nothing to do, return\n            return;\n        }\n        uint256 newUnprocessedIndex = _lastUnprocessed - _tree.startIndex;\n        if (newUnprocessedIndex <= _tree.unprocessedIndex) {\n            // These transactions were already processed, skip.\n            return;\n        }\n\n        _tree.unprocessedIndex = newUnprocessedIndex;\n    }\n\n    /// @notice Initialize a chain from a commitment.\n    function initFromCommitment(Tree storage _tree, PriorityTreeCommitment memory _commitment) internal {\n        uint256 height = _commitment.sides.length; // Height, including the root node.\n        if (height == 0) {\n            revert InvalidCommitment();\n        }\n        _tree.startIndex = _commitment.startIndex;\n        _tree.unprocessedIndex = _commitment.unprocessedIndex;\n        _tree.tree._nextLeafIndex = _commitment.nextLeafIndex;\n        _tree.tree._sides = _commitment.sides;\n        bytes32 zero = ZERO_LEAF_HASH;\n        _tree.tree._zeros = new bytes32[](height);\n        for (uint256 i; i < height; ++i) {\n            _tree.tree._zeros[i] = zero;\n            zero = Merkle.efficientHash(zero, zero);\n        }\n        _tree.historicalRoots[_tree.tree.root()] = true;\n    }\n\n    /// @notice Reinitialize the tree from a commitment on L1.\n    function l1Reinit(Tree storage _tree, PriorityTreeCommitment memory _commitment) internal {\n        if (_tree.startIndex != _commitment.startIndex) {\n            revert InvalidStartIndex(_tree.startIndex, _commitment.startIndex);\n        }\n        if (_tree.unprocessedIndex > _commitment.unprocessedIndex) {\n            revert InvalidUnprocessedIndex(_tree.unprocessedIndex, _commitment.unprocessedIndex);\n        }\n        if (_tree.tree._nextLeafIndex < _commitment.nextLeafIndex) {\n            revert InvalidNextLeafIndex(_tree.tree._nextLeafIndex, _commitment.nextLeafIndex);\n        }\n\n        _tree.unprocessedIndex = _commitment.unprocessedIndex;\n    }\n\n    /// @notice Reinitialize the tree from a commitment on GW.\n    function checkGWReinit(Tree storage _tree, PriorityTreeCommitment memory _commitment) internal view {\n        if (_tree.startIndex != _commitment.startIndex) {\n            revert InvalidStartIndex(_tree.startIndex, _commitment.startIndex);\n        }\n        if (_tree.unprocessedIndex > _commitment.unprocessedIndex) {\n            revert InvalidUnprocessedIndex(_tree.unprocessedIndex, _commitment.unprocessedIndex);\n        }\n        if (_tree.tree._nextLeafIndex > _commitment.nextLeafIndex) {\n            revert InvalidNextLeafIndex(_tree.tree._nextLeafIndex, _commitment.nextLeafIndex);\n        }\n    }\n\n    /// @notice Returns the commitment to the priority tree.\n    function getCommitment(Tree storage _tree) internal view returns (PriorityTreeCommitment memory commitment) {\n        commitment.nextLeafIndex = _tree.tree._nextLeafIndex;\n        commitment.startIndex = _tree.startIndex;\n        commitment.unprocessedIndex = _tree.unprocessedIndex;\n        commitment.sides = _tree.tree._sides;\n    }\n}\n"
      },
      "contracts/state-transition/libraries/TransactionValidator.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nimport {Math} from \"@openzeppelin/contracts-v4/utils/math/Math.sol\";\n\nimport {L2CanonicalTransaction} from \"../../common/Messaging.sol\";\nimport {TX_SLOT_OVERHEAD_L2_GAS, MEMORY_OVERHEAD_GAS, L1_TX_INTRINSIC_L2_GAS, L1_TX_DELTA_544_ENCODING_BYTES, L1_TX_DELTA_FACTORY_DEPS_L2_GAS, L1_TX_MIN_L2_GAS_BASE, L1_TX_INTRINSIC_PUBDATA, L1_TX_DELTA_FACTORY_DEPS_PUBDATA} from \"../../common/Config.sol\";\nimport {TooMuchGas, InvalidUpgradeTxn, UpgradeTxVerifyParam, PubdataGreaterThanLimit, ValidateTxnNotEnoughGas, TxnBodyGasLimitNotEnoughGas} from \"../../common/L1ContractErrors.sol\";\n\n/// @title ZKsync Library for validating L1 -> L2 transactions\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\nlibrary TransactionValidator {\n    /// @dev Used to validate key properties of an L1->L2 transaction\n    /// @param _transaction The transaction to validate\n    /// @param _encoded The abi encoded bytes of the transaction\n    /// @param _priorityTxMaxGasLimit The max gas limit, generally provided from Storage.sol\n    /// @param _priorityTxMaxPubdata The maximal amount of pubdata that a single L1->L2 transaction can emit\n    function validateL1ToL2Transaction(\n        L2CanonicalTransaction memory _transaction,\n        bytes memory _encoded,\n        uint256 _priorityTxMaxGasLimit,\n        uint256 _priorityTxMaxPubdata\n    ) internal pure {\n        uint256 l2GasForTxBody = getTransactionBodyGasLimit(_transaction.gasLimit, _encoded.length);\n\n        // Ensuring that the transaction is provable\n        if (l2GasForTxBody > _priorityTxMaxGasLimit) {\n            revert TooMuchGas();\n        }\n        // Ensuring that the transaction cannot output more pubdata than is processable\n        if (l2GasForTxBody / _transaction.gasPerPubdataByteLimit > _priorityTxMaxPubdata) {\n            revert PubdataGreaterThanLimit(_priorityTxMaxPubdata, l2GasForTxBody / _transaction.gasPerPubdataByteLimit);\n        }\n\n        // Ensuring that the transaction covers the minimal costs for its processing:\n        // hashing its content, publishing the factory dependencies, etc.\n        if (\n            getMinimalPriorityTransactionGasLimit(\n                _encoded.length,\n                _transaction.factoryDeps.length,\n                _transaction.gasPerPubdataByteLimit\n            ) > l2GasForTxBody\n        ) {\n            revert ValidateTxnNotEnoughGas();\n        }\n    }\n\n    /// @dev Used to validate upgrade transactions\n    /// @param _transaction The transaction to validate\n    function validateUpgradeTransaction(L2CanonicalTransaction memory _transaction) internal pure {\n        // Restrict from to be within system contract range (0...2^16 - 1)\n        if (_transaction.from > type(uint16).max) {\n            revert InvalidUpgradeTxn(UpgradeTxVerifyParam.From);\n        }\n        if (_transaction.to > type(uint160).max) {\n            revert InvalidUpgradeTxn(UpgradeTxVerifyParam.To);\n        }\n        if (_transaction.paymaster != 0) {\n            revert InvalidUpgradeTxn(UpgradeTxVerifyParam.Paymaster);\n        }\n        if (_transaction.value != 0) {\n            revert InvalidUpgradeTxn(UpgradeTxVerifyParam.Value);\n        }\n        if (_transaction.maxFeePerGas != 0) {\n            revert InvalidUpgradeTxn(UpgradeTxVerifyParam.MaxFeePerGas);\n        }\n        if (_transaction.maxPriorityFeePerGas != 0) {\n            revert InvalidUpgradeTxn(UpgradeTxVerifyParam.MaxPriorityFeePerGas);\n        }\n        if (_transaction.reserved[0] != 0) {\n            revert InvalidUpgradeTxn(UpgradeTxVerifyParam.Reserved0);\n        }\n        if (_transaction.reserved[1] > type(uint160).max) {\n            revert InvalidUpgradeTxn(UpgradeTxVerifyParam.Reserved1);\n        }\n        if (_transaction.reserved[2] != 0) {\n            revert InvalidUpgradeTxn(UpgradeTxVerifyParam.Reserved2);\n        }\n        if (_transaction.reserved[3] != 0) {\n            revert InvalidUpgradeTxn(UpgradeTxVerifyParam.Reserved3);\n        }\n        if (_transaction.signature.length != 0) {\n            revert InvalidUpgradeTxn(UpgradeTxVerifyParam.Signature);\n        }\n        if (_transaction.paymasterInput.length != 0) {\n            revert InvalidUpgradeTxn(UpgradeTxVerifyParam.PaymasterInput);\n        }\n        if (_transaction.reservedDynamic.length != 0) {\n            revert InvalidUpgradeTxn(UpgradeTxVerifyParam.ReservedDynamic);\n        }\n    }\n\n    /// @dev Calculates the approximate minimum gas limit required for executing a priority transaction.\n    /// @param _encodingLength The length of the priority transaction encoding in bytes.\n    /// @param _numberOfFactoryDependencies The number of new factory dependencies that will be added.\n    /// @param _l2GasPricePerPubdata The L2 gas price for publishing the priority transaction on L2.\n    /// @return The minimum gas limit required to execute the priority transaction.\n    /// Note: The calculation includes the main cost of the priority transaction, however, in reality, the operator can spend a little more gas on overheads.\n    function getMinimalPriorityTransactionGasLimit(\n        uint256 _encodingLength,\n        uint256 _numberOfFactoryDependencies,\n        uint256 _l2GasPricePerPubdata\n    ) internal pure returns (uint256) {\n        uint256 costForComputation;\n        {\n            // Adding the intrinsic cost for the transaction, i.e. auxiliary prices which cannot be easily accounted for\n            costForComputation = L1_TX_INTRINSIC_L2_GAS;\n\n            // Taking into account the hashing costs that depend on the length of the transaction\n            // Note that L1_TX_DELTA_544_ENCODING_BYTES is the delta in the price for every 544 bytes of\n            // the transaction's encoding. It is taken as LCM between 136 and 32 (the length for each keccak256 round\n            // and the size of each new encoding word).\n            costForComputation += Math.ceilDiv(_encodingLength * L1_TX_DELTA_544_ENCODING_BYTES, 544);\n\n            // Taking into the account the additional costs of providing new factory dependencies\n            costForComputation += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_L2_GAS;\n\n            // There is a minimal amount of computational L2 gas that the transaction should cover\n            costForComputation = Math.max(costForComputation, L1_TX_MIN_L2_GAS_BASE);\n        }\n\n        uint256 costForPubdata = 0;\n        {\n            // Adding the intrinsic cost for the transaction, i.e. auxiliary prices which cannot be easily accounted for\n            costForPubdata = L1_TX_INTRINSIC_PUBDATA * _l2GasPricePerPubdata;\n\n            // Taking into the account the additional costs of providing new factory dependencies\n            costForPubdata += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_PUBDATA * _l2GasPricePerPubdata;\n        }\n\n        return costForComputation + costForPubdata;\n    }\n\n    /// @notice Based on the full L2 gas limit (that includes the batch overhead) and other\n    /// properties of the transaction, returns the l2GasLimit for the body of the transaction (the actual execution).\n    /// @param _totalGasLimit The L2 gas limit that includes both the overhead for processing the batch\n    /// and the L2 gas needed to process the transaction itself (i.e. the actual l2GasLimit that will be used for the transaction).\n    /// @param _encodingLength The length of the ABI-encoding of the transaction.\n    function getTransactionBodyGasLimit(\n        uint256 _totalGasLimit,\n        uint256 _encodingLength\n    ) internal pure returns (uint256 txBodyGasLimit) {\n        uint256 overhead = getOverheadForTransaction(_encodingLength);\n\n        // provided gas limit doesn't cover transaction overhead\n        if (_totalGasLimit < overhead) {\n            revert TxnBodyGasLimitNotEnoughGas();\n        }\n        unchecked {\n            // We enforce the fact that `_totalGasLimit >= overhead` explicitly above.\n            txBodyGasLimit = _totalGasLimit - overhead;\n        }\n    }\n\n    /// @notice Based on the total L2 gas limit and several other parameters of the transaction\n    /// returns the part of the L2 gas that will be spent on the batch's overhead.\n    /// @dev The details of how this function works can be checked in the documentation\n    /// of the fee model of ZKsync. The appropriate comments are also present\n    /// in the Rust implementation description of function `get_maximal_allowed_overhead`.\n    /// @param _encodingLength The length of the binary encoding of the transaction in bytes\n    function getOverheadForTransaction(\n        uint256 _encodingLength\n    ) internal pure returns (uint256 batchOverheadForTransaction) {\n        // The overhead from taking up the transaction's slot\n        batchOverheadForTransaction = TX_SLOT_OVERHEAD_L2_GAS;\n\n        // The overhead for occupying the bootloader memory can be derived from encoded_len\n        uint256 overheadForLength = MEMORY_OVERHEAD_GAS * _encodingLength;\n        batchOverheadForTransaction = Math.max(batchOverheadForTransaction, overheadForLength);\n    }\n}\n"
      },
      "contracts/transactionFilterer/GatewayTransactionFilterer.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Ownable2StepUpgradeable} from \"@openzeppelin/contracts-upgradeable-v4/access/Ownable2StepUpgradeable.sol\";\n\nimport {AlreadyWhitelisted, InvalidSelector, NotWhitelisted, ZeroAddress} from \"../common/L1ContractErrors.sol\";\nimport {ITransactionFilterer} from \"../state-transition/chain-interfaces/ITransactionFilterer.sol\";\nimport {IBridgehub} from \"../bridgehub/IBridgehub.sol\";\nimport {IAssetRouterBase} from \"../bridge/asset-router/IAssetRouterBase.sol\";\nimport {IL2AssetRouter} from \"../bridge/asset-router/IL2AssetRouter.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev Filters transactions received by the Mailbox\n/// @dev Only allows whitelisted senders to deposit to Gateway\ncontract GatewayTransactionFilterer is ITransactionFilterer, Ownable2StepUpgradeable {\n    /// @notice Event emitted when sender is whitelisted\n    event WhitelistGranted(address indexed sender);\n\n    /// @notice Event emitted when sender is removed from whitelist\n    event WhitelistRevoked(address indexed sender);\n\n    /// @notice The ecosystem's Bridgehub\n    IBridgehub public immutable BRIDGE_HUB;\n\n    /// @notice The L1 asset router\n    address public immutable L1_ASSET_ROUTER;\n\n    /// @notice Indicates whether the sender is whitelisted to deposit to Gateway\n    mapping(address sender => bool whitelisted) public whitelistedSenders;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IBridgehub _bridgeHub, address _assetRouter) {\n        BRIDGE_HUB = _bridgeHub;\n        L1_ASSET_ROUTER = _assetRouter;\n        _disableInitializers();\n    }\n\n    /// @notice Initializes a contract filterer for later use. Expected to be used in the proxy.\n    /// @param _owner The address which can upgrade the implementation.\n    function initialize(address _owner) external initializer {\n        if (_owner == address(0)) {\n            revert ZeroAddress();\n        }\n        _transferOwnership(_owner);\n    }\n\n    /// @notice Whitelists the sender.\n    /// @param sender Address of the tx sender.\n    function grantWhitelist(address sender) external onlyOwner {\n        if (whitelistedSenders[sender]) {\n            revert AlreadyWhitelisted(sender);\n        }\n        whitelistedSenders[sender] = true;\n        emit WhitelistGranted(sender);\n    }\n\n    /// @notice Revoke the sender from whitelist.\n    /// @param sender Address of the tx sender.\n    function revokeWhitelist(address sender) external onlyOwner {\n        if (!whitelistedSenders[sender]) {\n            revert NotWhitelisted(sender);\n        }\n        whitelistedSenders[sender] = false;\n        emit WhitelistRevoked(sender);\n    }\n\n    /// @notice Checks if the transaction is allowed\n    /// @param sender The sender of the transaction\n    /// @param l2Calldata The calldata of the L2 transaction\n    /// @return Whether the transaction is allowed\n    function isTransactionAllowed(\n        address sender,\n        address,\n        uint256,\n        uint256,\n        bytes calldata l2Calldata,\n        address\n    ) external view returns (bool) {\n        if (sender == L1_ASSET_ROUTER) {\n            bytes4 l2TxSelector = bytes4(l2Calldata[:4]);\n\n            if (IL2AssetRouter.setAssetHandlerAddress.selector == l2TxSelector) {\n                (, bytes32 decodedAssetId, ) = abi.decode(l2Calldata[4:], (uint256, bytes32, address));\n                return _checkCTMAssetId(decodedAssetId);\n            }\n\n            if (IAssetRouterBase.finalizeDeposit.selector != l2TxSelector) {\n                revert InvalidSelector(l2TxSelector);\n            }\n\n            (, bytes32 decodedAssetId, ) = abi.decode(l2Calldata[4:], (uint256, bytes32, bytes));\n            return _checkCTMAssetId(decodedAssetId);\n        }\n\n        return whitelistedSenders[sender];\n    }\n\n    function _checkCTMAssetId(bytes32 assetId) internal view returns (bool) {\n        address ctmAddress = BRIDGE_HUB.ctmAssetIdToAddress(assetId);\n        return ctmAddress != address(0);\n    }\n}\n"
      },
      "contracts/upgrades/BaseZkSyncUpgrade.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {SafeCast} from \"@openzeppelin/contracts-v4/utils/math/SafeCast.sol\";\n\nimport {ZKChainBase} from \"../state-transition/chain-deps/facets/ZKChainBase.sol\";\nimport {VerifierParams} from \"../state-transition/chain-interfaces/IVerifier.sol\";\nimport {IVerifier} from \"../state-transition/chain-interfaces/IVerifier.sol\";\nimport {L2ContractHelper} from \"../common/libraries/L2ContractHelper.sol\";\nimport {TransactionValidator} from \"../state-transition/libraries/TransactionValidator.sol\";\nimport {MAX_NEW_FACTORY_DEPS, SYSTEM_UPGRADE_L2_TX_TYPE, MAX_ALLOWED_MINOR_VERSION_DELTA} from \"../common/Config.sol\";\nimport {L2CanonicalTransaction} from \"../common/Messaging.sol\";\nimport {ProtocolVersionMinorDeltaTooBig, TimeNotReached, InvalidTxType, L2UpgradeNonceNotEqualToNewProtocolVersion, TooManyFactoryDeps, ProtocolVersionTooSmall, PreviousUpgradeNotFinalized, PreviousUpgradeNotCleaned, PatchCantSetUpgradeTxn, PreviousProtocolMajorVersionNotZero, NewProtocolMajorVersionNotZero, PatchUpgradeCantSetDefaultAccount, PatchUpgradeCantSetBootloader} from \"./ZkSyncUpgradeErrors.sol\";\nimport {SemVer} from \"../common/libraries/SemVer.sol\";\n\n/// @notice The struct that represents the upgrade proposal.\n/// @param l2ProtocolUpgradeTx The system upgrade transaction.\n/// @param bootloaderHash The hash of the new bootloader bytecode. If zero, it will not be updated.\n/// @param defaultAccountHash The hash of the new default account bytecode. If zero, it will not be updated.\n/// @param verifier The address of the new verifier. If zero, the verifier will not be updated.\n/// @param verifierParams The new verifier params. If all of its fields are 0, the params will not be updated.\n/// @param l1ContractsUpgradeCalldata Custom calldata for L1 contracts upgrade, it may be interpreted differently\n/// in each upgrade. Usually empty.\n/// @param postUpgradeCalldata Custom calldata for post upgrade hook, it may be interpreted differently in each\n/// upgrade. Usually empty.\n/// @param upgradeTimestamp The timestamp after which the upgrade can be executed.\n/// @param newProtocolVersion The new version number for the protocol after this upgrade. Should be greater than\n/// the previous protocol version.\nstruct ProposedUpgrade {\n    L2CanonicalTransaction l2ProtocolUpgradeTx;\n    bytes32 bootloaderHash;\n    bytes32 defaultAccountHash;\n    address verifier;\n    VerifierParams verifierParams;\n    bytes l1ContractsUpgradeCalldata;\n    bytes postUpgradeCalldata;\n    uint256 upgradeTimestamp;\n    uint256 newProtocolVersion;\n}\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Interface to which all the upgrade implementations should adhere\nabstract contract BaseZkSyncUpgrade is ZKChainBase {\n    /// @notice Changes the protocol version\n    event NewProtocolVersion(uint256 indexed previousProtocolVersion, uint256 indexed newProtocolVersion);\n\n    /// @notice Сhanges to the bytecode that is used in L2 as a bootloader (start program)\n    event NewL2BootloaderBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\n\n    /// @notice Сhanges to the bytecode that is used in L2 as a default account\n    event NewL2DefaultAccountBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\n\n    /// @notice Verifier address changed\n    event NewVerifier(address indexed oldVerifier, address indexed newVerifier);\n\n    /// @notice Verifier parameters changed\n    event NewVerifierParams(VerifierParams oldVerifierParams, VerifierParams newVerifierParams);\n\n    /// @notice Notifies about complete upgrade\n    event UpgradeComplete(uint256 indexed newProtocolVersion, bytes32 indexed l2UpgradeTxHash, ProposedUpgrade upgrade);\n\n    /// @notice The main function that will be delegate-called by the chain.\n    /// @dev This is a virtual function and should be overridden by custom upgrade implementations.\n    /// @param _proposedUpgrade The upgrade to be executed.\n    /// @return txHash The hash of the L2 system contract upgrade transaction.\n    function upgrade(ProposedUpgrade calldata _proposedUpgrade) public virtual returns (bytes32 txHash) {\n        // Note that due to commitment delay, the timestamp of the L2 upgrade batch may be earlier than the timestamp\n        // of the L1 block at which the upgrade occurred. This means that using timestamp as a signifier of \"upgraded\"\n        // on the L2 side would be inaccurate. The effects of this \"back-dating\" of L2 upgrade batches will be reduced\n        // as the permitted delay window is reduced in the future.\n        if (block.timestamp < _proposedUpgrade.upgradeTimestamp) {\n            revert TimeNotReached(_proposedUpgrade.upgradeTimestamp, block.timestamp);\n        }\n\n        (uint32 newMinorVersion, bool isPatchOnly) = _setNewProtocolVersion(_proposedUpgrade.newProtocolVersion);\n        _upgradeL1Contract(_proposedUpgrade.l1ContractsUpgradeCalldata);\n        _upgradeVerifier(_proposedUpgrade.verifier, _proposedUpgrade.verifierParams);\n        _setBaseSystemContracts(_proposedUpgrade.bootloaderHash, _proposedUpgrade.defaultAccountHash, isPatchOnly);\n\n        txHash = _setL2SystemContractUpgrade(_proposedUpgrade.l2ProtocolUpgradeTx, newMinorVersion, isPatchOnly);\n\n        _postUpgrade(_proposedUpgrade.postUpgradeCalldata);\n\n        emit UpgradeComplete(_proposedUpgrade.newProtocolVersion, txHash, _proposedUpgrade);\n    }\n\n    /// @notice Change default account bytecode hash, that is used on L2\n    /// @param _l2DefaultAccountBytecodeHash The hash of default account L2 bytecode\n    /// @param _patchOnly Whether only the patch part of the protocol version semver has changed\n    function _setL2DefaultAccountBytecodeHash(bytes32 _l2DefaultAccountBytecodeHash, bool _patchOnly) private {\n        if (_l2DefaultAccountBytecodeHash == bytes32(0)) {\n            return;\n        }\n\n        if (_patchOnly) {\n            revert PatchUpgradeCantSetDefaultAccount();\n        }\n\n        L2ContractHelper.validateBytecodeHash(_l2DefaultAccountBytecodeHash);\n\n        // Save previous value into the stack to put it into the event later\n        bytes32 previousDefaultAccountBytecodeHash = s.l2DefaultAccountBytecodeHash;\n\n        // Change the default account bytecode hash\n        s.l2DefaultAccountBytecodeHash = _l2DefaultAccountBytecodeHash;\n        emit NewL2DefaultAccountBytecodeHash(previousDefaultAccountBytecodeHash, _l2DefaultAccountBytecodeHash);\n    }\n\n    /// @notice Change bootloader bytecode hash, that is used on L2\n    /// @param _l2BootloaderBytecodeHash The hash of bootloader L2 bytecode\n    /// @param _patchOnly Whether only the patch part of the protocol version semver has changed\n    function _setL2BootloaderBytecodeHash(bytes32 _l2BootloaderBytecodeHash, bool _patchOnly) private {\n        if (_l2BootloaderBytecodeHash == bytes32(0)) {\n            return;\n        }\n\n        if (_patchOnly) {\n            revert PatchUpgradeCantSetBootloader();\n        }\n\n        L2ContractHelper.validateBytecodeHash(_l2BootloaderBytecodeHash);\n\n        // Save previous value into the stack to put it into the event later\n        bytes32 previousBootloaderBytecodeHash = s.l2BootloaderBytecodeHash;\n\n        // Change the bootloader bytecode hash\n        s.l2BootloaderBytecodeHash = _l2BootloaderBytecodeHash;\n        emit NewL2BootloaderBytecodeHash(previousBootloaderBytecodeHash, _l2BootloaderBytecodeHash);\n    }\n\n    /// @notice Change the address of the verifier smart contract\n    /// @param _newVerifier Verifier smart contract address\n    function _setVerifier(IVerifier _newVerifier) private {\n        // An upgrade to the verifier must be done carefully to ensure there aren't batches in the committed state\n        // during the transition. If verifier is upgraded, it will immediately be used to prove all committed batches.\n        // Batches committed expecting the old verifier will fail. Ensure all committed batches are finalized before the\n        // verifier is upgraded.\n        if (_newVerifier == IVerifier(address(0))) {\n            return;\n        }\n\n        IVerifier oldVerifier = s.verifier;\n        s.verifier = _newVerifier;\n        emit NewVerifier(address(oldVerifier), address(_newVerifier));\n    }\n\n    /// @notice Change the verifier parameters\n    /// @param _newVerifierParams New parameters for the verifier\n    function _setVerifierParams(VerifierParams calldata _newVerifierParams) private {\n        // An upgrade to the verifier params must be done carefully to ensure there aren't batches in the committed state\n        // during the transition. If verifier is upgraded, it will immediately be used to prove all committed batches.\n        // Batches committed expecting the old verifier params will fail. Ensure all committed batches are finalized before the\n        // verifier is upgraded.\n        if (\n            _newVerifierParams.recursionNodeLevelVkHash == bytes32(0) &&\n            _newVerifierParams.recursionLeafLevelVkHash == bytes32(0) &&\n            _newVerifierParams.recursionCircuitsSetVksHash == bytes32(0)\n        ) {\n            return;\n        }\n\n        VerifierParams memory oldVerifierParams = s.__DEPRECATED_verifierParams;\n        s.__DEPRECATED_verifierParams = _newVerifierParams;\n        emit NewVerifierParams(oldVerifierParams, _newVerifierParams);\n    }\n\n    /// @notice Updates the verifier and the verifier params\n    /// @param _newVerifier The address of the new verifier. If 0, the verifier will not be updated.\n    /// @param _verifierParams The new verifier params. If all of the fields are 0, the params will not be updated.\n    function _upgradeVerifier(address _newVerifier, VerifierParams calldata _verifierParams) internal {\n        _setVerifier(IVerifier(_newVerifier));\n        _setVerifierParams(_verifierParams);\n    }\n\n    /// @notice Updates the bootloader hash and the hash of the default account\n    /// @param _bootloaderHash The hash of the new bootloader bytecode. If zero, it will not be updated.\n    /// @param _defaultAccountHash The hash of the new default account bytecode. If zero, it will not be updated.\n    /// @param _patchOnly Whether only the patch part of the protocol version semver has changed.\n    function _setBaseSystemContracts(bytes32 _bootloaderHash, bytes32 _defaultAccountHash, bool _patchOnly) internal {\n        _setL2BootloaderBytecodeHash(_bootloaderHash, _patchOnly);\n        _setL2DefaultAccountBytecodeHash(_defaultAccountHash, _patchOnly);\n    }\n\n    /// @notice Sets the hash of the L2 system contract upgrade transaction for the next batch to be committed\n    /// @dev If the transaction is noop (i.e. its type is 0) it does nothing and returns 0.\n    /// @param _l2ProtocolUpgradeTx The L2 system contract upgrade transaction.\n    /// @param _newMinorProtocolVersion The new minor protocol version. It must be used as the `nonce` field\n    /// of the `_l2ProtocolUpgradeTx`.\n    /// @param _patchOnly Whether only the patch part of the protocol version semver has changed.\n    /// @return System contracts upgrade transaction hash. Zero if no upgrade transaction is set.\n    function _setL2SystemContractUpgrade(\n        L2CanonicalTransaction calldata _l2ProtocolUpgradeTx,\n        uint32 _newMinorProtocolVersion,\n        bool _patchOnly\n    ) internal returns (bytes32) {\n        // If the type is 0, it is considered as noop and so will not be required to be executed.\n        if (_l2ProtocolUpgradeTx.txType == 0) {\n            return bytes32(0);\n        }\n\n        if (_l2ProtocolUpgradeTx.txType != SYSTEM_UPGRADE_L2_TX_TYPE) {\n            revert InvalidTxType(_l2ProtocolUpgradeTx.txType);\n        }\n        if (_patchOnly) {\n            revert PatchCantSetUpgradeTxn();\n        }\n\n        bytes memory encodedTransaction = abi.encode(_l2ProtocolUpgradeTx);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            _l2ProtocolUpgradeTx,\n            encodedTransaction,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        TransactionValidator.validateUpgradeTransaction(_l2ProtocolUpgradeTx);\n\n        // We want the hashes of l2 system upgrade transactions to be unique.\n        // This is why we require that the `nonce` field is unique to each upgrade.\n        if (_l2ProtocolUpgradeTx.nonce != _newMinorProtocolVersion) {\n            revert L2UpgradeNonceNotEqualToNewProtocolVersion(_l2ProtocolUpgradeTx.nonce, _newMinorProtocolVersion);\n        }\n\n        _verifyFactoryDeps(_l2ProtocolUpgradeTx.factoryDeps);\n\n        bytes32 l2ProtocolUpgradeTxHash = keccak256(encodedTransaction);\n\n        s.l2SystemContractsUpgradeTxHash = l2ProtocolUpgradeTxHash;\n\n        return l2ProtocolUpgradeTxHash;\n    }\n\n    /// @notice Verifies that the factory deps provided are in the correct format\n    /// @param _hashes The list of hashes of factory deps\n    /// @dev Note, that unlike normal L1->L2 transactions, factory dependencies for\n    /// an upgrade transaction should be made available prior to the upgrade via publishing those\n    /// to the `BytecodesSupplier` contract.\n    function _verifyFactoryDeps(uint256[] calldata _hashes) private pure {\n        if (_hashes.length > MAX_NEW_FACTORY_DEPS) {\n            revert TooManyFactoryDeps();\n        }\n    }\n\n    /// @notice Changes the protocol version\n    /// @param _newProtocolVersion The new protocol version\n    function _setNewProtocolVersion(\n        uint256 _newProtocolVersion\n    ) internal virtual returns (uint32 newMinorVersion, bool patchOnly) {\n        uint256 previousProtocolVersion = s.protocolVersion;\n        if (_newProtocolVersion <= previousProtocolVersion) {\n            revert ProtocolVersionTooSmall();\n        }\n        // slither-disable-next-line unused-return\n        (uint32 previousMajorVersion, uint32 previousMinorVersion, ) = SemVer.unpackSemVer(\n            SafeCast.toUint96(previousProtocolVersion)\n        );\n        if (previousMajorVersion != 0) {\n            revert PreviousProtocolMajorVersionNotZero();\n        }\n\n        uint32 newMajorVersion;\n        // slither-disable-next-line unused-return\n        (newMajorVersion, newMinorVersion, ) = SemVer.unpackSemVer(SafeCast.toUint96(_newProtocolVersion));\n        if (newMajorVersion != 0) {\n            revert NewProtocolMajorVersionNotZero();\n        }\n\n        // Since `_newProtocolVersion > previousProtocolVersion`, and both old and new major version is 0,\n        // the difference between minor versions is >= 0.\n        uint256 minorDelta = newMinorVersion - previousMinorVersion;\n\n        if (minorDelta == 0) {\n            patchOnly = true;\n        }\n\n        // While this is implicitly enforced by other checks above, we still double check just in case\n        if (minorDelta > MAX_ALLOWED_MINOR_VERSION_DELTA) {\n            revert ProtocolVersionMinorDeltaTooBig(MAX_ALLOWED_MINOR_VERSION_DELTA, minorDelta);\n        }\n\n        // If the minor version changes also, we need to ensure that the previous upgrade has been finalized.\n        // In case the minor version does not change, we permit to keep the old upgrade transaction in the system, but it\n        // must be ensured in the other parts of the upgrade that the upgrade transaction is not overridden.\n        if (!patchOnly) {\n            // If the previous upgrade had an L2 system upgrade transaction, we require that it is finalized.\n            // Note it is important to keep this check, as otherwise ZK chains might skip upgrades by overwriting\n            if (s.l2SystemContractsUpgradeTxHash != bytes32(0)) {\n                revert PreviousUpgradeNotFinalized(s.l2SystemContractsUpgradeTxHash);\n            }\n            if (s.l2SystemContractsUpgradeBatchNumber != 0) {\n                revert PreviousUpgradeNotCleaned();\n            }\n        }\n\n        s.protocolVersion = _newProtocolVersion;\n        emit NewProtocolVersion(previousProtocolVersion, _newProtocolVersion);\n    }\n\n    /// @notice Placeholder function for custom logic for upgrading L1 contract.\n    /// Typically this function will never be used.\n    /// @param _customCallDataForUpgrade Custom data for an upgrade, which may be interpreted differently for each\n    /// upgrade.\n    function _upgradeL1Contract(bytes calldata _customCallDataForUpgrade) internal virtual {}\n\n    /// @notice placeholder function for custom logic for post-upgrade logic.\n    /// Typically this function will never be used.\n    /// @param _customCallDataForUpgrade Custom data for an upgrade, which may be interpreted differently for each\n    /// upgrade.\n    function _postUpgrade(bytes calldata _customCallDataForUpgrade) internal virtual {}\n}\n"
      },
      "contracts/upgrades/BaseZkSyncUpgradeGenesis.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {SafeCast} from \"@openzeppelin/contracts-v4/utils/math/SafeCast.sol\";\n\nimport {BaseZkSyncUpgrade} from \"./BaseZkSyncUpgrade.sol\";\nimport {ProtocolVersionTooSmall, ProtocolVersionDeltaTooLarge, PreviousUpgradeNotFinalized, PreviousUpgradeBatchNotCleared, ProtocolMajorVersionNotZero} from \"./ZkSyncUpgradeErrors.sol\";\nimport {MAX_ALLOWED_MINOR_VERSION_DELTA} from \"../common/Config.sol\";\nimport {SemVer} from \"../common/libraries/SemVer.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Interface to which all the upgrade implementations should adhere\nabstract contract BaseZkSyncUpgradeGenesis is BaseZkSyncUpgrade {\n    /// @notice Changes the protocol version\n    /// @param _newProtocolVersion The new protocol version\n    function _setNewProtocolVersion(\n        uint256 _newProtocolVersion\n    ) internal override returns (uint32 newMinorVersion, bool patchOnly) {\n        uint256 previousProtocolVersion = s.protocolVersion;\n        if (\n            // IMPORTANT Genesis Upgrade difference: Note this is the only thing change <= to <\n            _newProtocolVersion < previousProtocolVersion\n        ) {\n            revert ProtocolVersionTooSmall();\n        }\n        // slither-disable-next-line unused-return\n        (uint32 previousMajorVersion, uint32 previousMinorVersion, ) = SemVer.unpackSemVer(\n            SafeCast.toUint96(previousProtocolVersion)\n        );\n\n        if (previousMajorVersion != 0) {\n            revert ProtocolMajorVersionNotZero();\n        }\n\n        uint32 newMajorVersion;\n        // slither-disable-next-line unused-return\n        (newMajorVersion, newMinorVersion, ) = SemVer.unpackSemVer(SafeCast.toUint96(_newProtocolVersion));\n        if (newMajorVersion != 0) {\n            revert ProtocolMajorVersionNotZero();\n        }\n\n        // Since `_newProtocolVersion > previousProtocolVersion`, and both old and new major version is 0,\n        // the difference between minor versions is >= 0.\n        uint256 minorDelta = newMinorVersion - previousMinorVersion;\n\n        // IMPORTANT Genesis Upgrade difference: We never set patchOnly to `true` to allow to put a system upgrade transaction there.\n        patchOnly = false;\n\n        // While this is implicitly enforced by other checks above, we still double check just in case\n        if (minorDelta > MAX_ALLOWED_MINOR_VERSION_DELTA) {\n            revert ProtocolVersionDeltaTooLarge(minorDelta, MAX_ALLOWED_MINOR_VERSION_DELTA);\n        }\n\n        // If the minor version changes also, we need to ensure that the previous upgrade has been finalized.\n        // In case the minor version does not change, we permit to keep the old upgrade transaction in the system, but it\n        // must be ensured in the other parts of the upgrade that the upgrade transaction is not overridden.\n        if (!patchOnly) {\n            // If the previous upgrade had an L2 system upgrade transaction, we require that it is finalized.\n            // Note it is important to keep this check, as otherwise ZK chains might skip upgrades by overwriting\n            if (s.l2SystemContractsUpgradeTxHash != bytes32(0)) {\n                revert PreviousUpgradeNotFinalized(s.l2SystemContractsUpgradeTxHash);\n            }\n            if (s.l2SystemContractsUpgradeBatchNumber != 0) {\n                revert PreviousUpgradeBatchNotCleared();\n            }\n        }\n\n        s.protocolVersion = _newProtocolVersion;\n        emit NewProtocolVersion(previousProtocolVersion, _newProtocolVersion);\n    }\n}\n"
      },
      "contracts/upgrades/BytecodesSupplier.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {L2ContractHelper} from \"../common/libraries/L2ContractHelper.sol\";\nimport {BytecodeAlreadyPublished} from \"../common/L1ContractErrors.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Contract that is used to track published L2 bytecodes.\n/// It will be the contract to which the preimages for the factory dependencies protocol upgrade transaction\n/// will be submitted to.\n/// @dev The contract has no access control as anyone is allowed to publish any bytecode.\ncontract BytecodesSupplier {\n    /// @notice Event emitted when a bytecode is published.\n    event BytecodePublished(bytes32 indexed bytecodeHash, bytes bytecode);\n\n    /// @notice Mapping of bytecode hashes to the block number when they were published.\n    mapping(bytes32 bytecodeHash => uint256 blockNumber) public publishingBlock;\n\n    /// @notice Publishes the bytecode hash and the bytecode itself.\n    /// @param _bytecode Bytecode to be published.\n    function publishBytecode(bytes calldata _bytecode) public {\n        bytes32 bytecodeHash = L2ContractHelper.hashL2BytecodeCalldata(_bytecode);\n\n        if (publishingBlock[bytecodeHash] != 0) {\n            revert BytecodeAlreadyPublished(bytecodeHash);\n        }\n\n        publishingBlock[bytecodeHash] = block.number;\n\n        emit BytecodePublished(bytecodeHash, _bytecode);\n    }\n\n    /// @notice Publishes multiple bytecodes.\n    /// @param _bytecodes Array of bytecodes to be published.\n    function publishBytecodes(bytes[] calldata _bytecodes) external {\n        // solhint-disable-next-line gas-length-in-loops\n        for (uint256 i = 0; i < _bytecodes.length; ++i) {\n            publishBytecode(_bytecodes[i]);\n        }\n    }\n}\n"
      },
      "contracts/upgrades/DefaultUpgrade.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {Diamond} from \"../state-transition/libraries/Diamond.sol\";\nimport {BaseZkSyncUpgrade, ProposedUpgrade} from \"./BaseZkSyncUpgrade.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract DefaultUpgrade is BaseZkSyncUpgrade {\n    /// @notice The main function that will be delegate-called by the chain.\n    /// @param _proposedUpgrade The upgrade to be executed.\n    function upgrade(ProposedUpgrade calldata _proposedUpgrade) public override returns (bytes32) {\n        super.upgrade(_proposedUpgrade);\n        return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE;\n    }\n}\n"
      },
      "contracts/upgrades/GatewayUpgrade.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {BaseZkSyncUpgrade, ProposedUpgrade} from \"./BaseZkSyncUpgrade.sol\";\n\nimport {DataEncoding} from \"../common/libraries/DataEncoding.sol\";\n\nimport {Diamond} from \"../state-transition/libraries/Diamond.sol\";\nimport {PriorityQueue} from \"../state-transition/libraries/PriorityQueue.sol\";\nimport {PriorityTree} from \"../state-transition/libraries/PriorityTree.sol\";\nimport {GatewayUpgradeFailed} from \"./ZkSyncUpgradeErrors.sol\";\n\nimport {IGatewayUpgrade} from \"./IGatewayUpgrade.sol\";\nimport {IL2ContractDeployer} from \"../common/interfaces/IL2ContractDeployer.sol\";\nimport {L1GatewayBase} from \"./L1GatewayBase.sol\";\n\n// solhint-disable-next-line gas-struct-packing\nstruct GatewayUpgradeEncodedInput {\n    IL2ContractDeployer.ForceDeployment[] forceDeployments;\n    uint256 l2GatewayUpgradePosition;\n    bytes fixedForceDeploymentsData;\n    address ctmDeployer;\n    address oldValidatorTimelock;\n    address newValidatorTimelock;\n    address wrappedBaseTokenStore;\n}\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice This upgrade will be used to migrate Era to be part of the ZK chain ecosystem contracts.\ncontract GatewayUpgrade is BaseZkSyncUpgrade, L1GatewayBase, IGatewayUpgrade {\n    using PriorityQueue for PriorityQueue.Queue;\n    using PriorityTree for PriorityTree.Tree;\n\n    /// @notice The address of this contract.\n    /// @dev needed as this address is delegateCalled, and we delegateCall it again.\n    address public immutable THIS_ADDRESS;\n\n    constructor() {\n        THIS_ADDRESS = address(this);\n    }\n\n    /// @notice The main function that will be delegate-called by the chain.\n    /// @param _proposedUpgrade The upgrade to be executed.\n    /// @dev Doesn't require any access-control restrictions as the contract is used in the delegate call.\n    function upgrade(ProposedUpgrade calldata _proposedUpgrade) public override returns (bytes32) {\n        GatewayUpgradeEncodedInput memory encodedInput = abi.decode(\n            _proposedUpgrade.postUpgradeCalldata,\n            (GatewayUpgradeEncodedInput)\n        );\n\n        bytes32 baseTokenAssetId = DataEncoding.encodeNTVAssetId(block.chainid, s.__DEPRECATED_baseToken);\n\n        s.baseTokenAssetId = baseTokenAssetId;\n        s.priorityTree.setup(s.priorityQueue.getTotalPriorityTxs());\n        s.validators[encodedInput.oldValidatorTimelock] = false;\n        s.validators[encodedInput.newValidatorTimelock] = true;\n        ProposedUpgrade memory proposedUpgrade = _proposedUpgrade;\n\n        bytes memory gatewayUpgradeCalldata = abi.encode(\n            encodedInput.ctmDeployer,\n            encodedInput.fixedForceDeploymentsData,\n            getZKChainSpecificForceDeploymentsData(s, encodedInput.wrappedBaseTokenStore, s.__DEPRECATED_baseToken)\n        );\n        encodedInput.forceDeployments[encodedInput.l2GatewayUpgradePosition].input = gatewayUpgradeCalldata;\n\n        proposedUpgrade.l2ProtocolUpgradeTx.data = abi.encodeCall(\n            IL2ContractDeployer.forceDeployOnAddresses,\n            (encodedInput.forceDeployments)\n        );\n\n        // slither-disable-next-line controlled-delegatecall\n        (bool success, ) = THIS_ADDRESS.delegatecall(abi.encodeCall(IGatewayUpgrade.upgradeExternal, proposedUpgrade));\n        if (!success) {\n            revert GatewayUpgradeFailed();\n        }\n        return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE;\n    }\n\n    /// @notice The function that will be called from this same contract, we need an external call to be able to modify _proposedUpgrade (memory/calldata).\n    /// @dev Doesn't require any access-control restrictions as the contract is used in the delegate call.\n    function upgradeExternal(ProposedUpgrade calldata _proposedUpgrade) external override {\n        super.upgrade(_proposedUpgrade);\n    }\n}\n"
      },
      "contracts/upgrades/GovernanceUpgradeTimer.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {Ownable2Step} from \"@openzeppelin/contracts-v4/access/Ownable2Step.sol\";\nimport {ZeroAddress, TimerAlreadyStarted, CallerNotTimerAdmin, DeadlineNotYetPassed, NewDeadlineNotGreaterThanCurrent, NewDeadlineExceedsMaxDeadline} from \"../common/L1ContractErrors.sol\";\n\n/// @title Governance Upgrade Timer\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice This contract will be used by the governance to ensure that the chains have enough time\n/// to upgrade their implementation before finalizing the upgrade on L1.\n/// @notice The `startTimer` function should be called once the new version is published. It starts the\n/// timer and gives at least `INITIAL_DELAY` for the chains to upgrade. In case for any reason the timeline has to\n/// be extended, the owner of this contract can increase the timeline, but only the maximum of `MAX_ADDITIONAL_DELAY`\n/// is allowed.\ncontract GovernanceUpgradeTimer is Ownable2Step {\n    /// @notice The initial delay to be used.\n    uint256 public immutable INITIAL_DELAY;\n    /// @notice The maximal delay for the upgrade.\n    uint256 public immutable MAX_ADDITIONAL_DELAY;\n    /// @notice The address that can start the timer.\n    address public immutable TIMER_GOVERNANCE;\n\n    /// @notice The deadline which we should wait.\n    uint256 public deadline;\n    /// @notice The maximal deadline to which the owner of this contract can\n    /// increase the deadline.\n    uint256 public maxDeadline;\n\n    /// @dev Emitted when the timer is started, logging the initial `deadline` and `maxDeadline`.\n    /// @param deadline The initial deadline set for the timer.\n    /// @param maxDeadline The maximum deadline the timer can be extended to.\n    event TimerStarted(uint256 deadline, uint256 maxDeadline);\n\n    /// @dev Emitted when the owner changes the deadline.\n    /// @param newDeadline The new deadline set by the owner.\n    event DeadlineChanged(uint256 newDeadline);\n\n    /// @dev Initializes the contract with immutable values for `INITIAL_DELAY`, `MAX_ADDITIONAL_DELAY`, and `TIMER_GOVERNANCE`.\n    /// @param _initialDelay The initial delay in seconds to be added to the current block timestamp to set the deadline.\n    /// @param _maxAdditionalDelay The maximum number of seconds that can be added to the initial delay to set `maxDeadline`.\n    /// @param _timerGovernance The address of the timer administrator, who is allowed to start the timer.\n    /// @param _initialOwner The initial owner of the contract.\n    constructor(uint256 _initialDelay, uint256 _maxAdditionalDelay, address _timerGovernance, address _initialOwner) {\n        if (_timerGovernance == address(0)) {\n            revert ZeroAddress();\n        }\n\n        INITIAL_DELAY = _initialDelay;\n        MAX_ADDITIONAL_DELAY = _maxAdditionalDelay;\n        TIMER_GOVERNANCE = _timerGovernance;\n\n        _transferOwnership(_initialOwner);\n    }\n\n    /// @dev Modifier that restricts function access to the `TIMER_GOVERNANCE` address.\n    /// Reverts with a custom error if the caller is not `TIMER_GOVERNANCE`.\n    modifier onlyTimerAdmin() {\n        if (msg.sender != TIMER_GOVERNANCE) {\n            revert CallerNotTimerAdmin();\n        }\n        _;\n    }\n\n    /// @dev Starts the timer by setting the `deadline` and `maxDeadline`. Only callable by the `TIMER_GOVERNANCE`.\n    ///\n    /// Emits a {TimerStarted} event.\n    function startTimer() external onlyTimerAdmin {\n        if (deadline != 0) {\n            revert TimerAlreadyStarted();\n        }\n\n        deadline = block.timestamp + INITIAL_DELAY;\n        maxDeadline = deadline + MAX_ADDITIONAL_DELAY;\n\n        emit TimerStarted(deadline, maxDeadline);\n    }\n\n    /// @dev Checks if the current `deadline` has passed. Reverts if the deadline has already passed.\n    ///\n    /// Reverts with {DeadlineNotYetPassed} error if the current block timestamp is less than `deadline`.\n    function checkDeadline() external view {\n        if (block.timestamp < deadline) {\n            revert DeadlineNotYetPassed();\n        }\n    }\n\n    /// @dev Allows the owner to change the current `deadline` to a new value.\n    ///\n    /// The new deadline must be greater than the current deadline and must not exceed `maxDeadline`.\n    ///\n    /// Emits a {DeadlineChanged} event.\n    ///\n    /// @param newDeadline The new deadline to be set.\n    ///\n    /// Reverts with {NewDeadlineNotGreaterThanCurrent} if the new deadline is not greater than the current one.\n    /// Reverts with {NewDeadlineExceedsMaxDeadline} if the new deadline exceeds `maxDeadline`.\n    function changeDeadline(uint256 newDeadline) external onlyOwner {\n        if (newDeadline <= deadline) {\n            revert NewDeadlineNotGreaterThanCurrent();\n        }\n        if (newDeadline > maxDeadline) {\n            revert NewDeadlineExceedsMaxDeadline();\n        }\n\n        deadline = newDeadline;\n\n        emit DeadlineChanged(newDeadline);\n    }\n}\n"
      },
      "contracts/upgrades/IDefaultUpgrade.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {ProposedUpgrade} from \"./BaseZkSyncUpgrade.sol\";\n\ninterface IDefaultUpgrade {\n    function upgrade(ProposedUpgrade calldata _upgrade) external returns (bytes32);\n}\n"
      },
      "contracts/upgrades/IGatewayUpgrade.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {ProposedUpgrade} from \"./BaseZkSyncUpgrade.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Gateway upgrade interface. Used for the protocol upgrade that introduces the Gateway.\n */\ninterface IGatewayUpgrade {\n    /// @notice The upgrade function called from within this same contract\n    /// @dev This is needed for memory -> calldata conversion of the _upgrade arg.\n    /// @param _upgrade The upgrade to be executed.\n    function upgradeExternal(ProposedUpgrade calldata _upgrade) external;\n}\n"
      },
      "contracts/upgrades/IL1GenesisUpgrade.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {L2CanonicalTransaction} from \"../common/Messaging.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice L1 genesis upgrade interface. Every chain has to process an upgrade txs at its genesis.\n * @notice This is needed to set system params like the chainId and to deploy some system contracts.\n */\ninterface IL1GenesisUpgrade {\n    /// @dev emitted when a chain registers and a GenesisUpgrade happens\n    /// @param _zkChain the address of the zk chain\n    /// @param _l2Transaction the l2 genesis upgrade transaction\n    /// @param _protocolVersion the current protocol version\n    /// @param _factoryDeps the factory dependencies needed for the upgrade\n    event GenesisUpgrade(\n        address indexed _zkChain,\n        L2CanonicalTransaction _l2Transaction,\n        uint256 indexed _protocolVersion,\n        bytes[] _factoryDeps\n    );\n\n    /// @notice The main function that will be called by the Admin facet at genesis.\n    /// @param _l1GenesisUpgrade the address of the l1 genesis upgrade\n    /// @param _chainId the chain id\n    /// @param _protocolVersion the current protocol version\n    /// @param _l1CtmDeployerAddress the address of the l1 ctm deployer\n    /// @param _forceDeployments the force deployments\n    /// @param _factoryDeps the factory dependencies\n    function genesisUpgrade(\n        address _l1GenesisUpgrade,\n        uint256 _chainId,\n        uint256 _protocolVersion,\n        address _l1CtmDeployerAddress,\n        bytes calldata _forceDeployments,\n        bytes[] calldata _factoryDeps\n    ) external returns (bytes32);\n}\n"
      },
      "contracts/upgrades/L1GatewayBase.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IL1SharedBridgeLegacy} from \"../bridge/interfaces/IL1SharedBridgeLegacy.sol\";\nimport {IBridgehub} from \"../bridgehub/IBridgehub.sol\";\nimport {ETH_TOKEN_ADDRESS} from \"../common/Config.sol\";\nimport {ZKChainSpecificForceDeploymentsData} from \"../state-transition/l2-deps/IL2GenesisUpgrade.sol\";\n\nimport {ZKChainStorage} from \"../state-transition/chain-deps/ZKChainStorage.sol\";\n\nimport {L2WrappedBaseTokenStore} from \"../bridge/L2WrappedBaseTokenStore.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts-v4/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/// @title L1GatewayBase\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\nabstract contract L1GatewayBase {\n    /// @notice The function to retrieve the chain-specific upgrade data.\n    /// @param s The pointer to the storage of the chain.\n    /// @param _wrappedBaseTokenStore The address of the `L2WrappedBaseTokenStore` contract.\n    /// It is expected to be zero during creation of new chains and non-zero during upgrades.\n    /// @param _baseTokenAddress The L1 address of the base token of the chain. Note, that for\n    /// chains whose token originates from an L2, this address will be the address of its bridged\n    /// representation on L1.\n    function getZKChainSpecificForceDeploymentsData(\n        ZKChainStorage storage s,\n        address _wrappedBaseTokenStore,\n        address _baseTokenAddress\n    ) internal view returns (bytes memory) {\n        address sharedBridge = IBridgehub(s.bridgehub).sharedBridge();\n        address legacySharedBridge = IL1SharedBridgeLegacy(sharedBridge).l2BridgeAddress(s.chainId);\n\n        address l2WBaseToken;\n        if (_wrappedBaseTokenStore != address(0)) {\n            l2WBaseToken = L2WrappedBaseTokenStore(_wrappedBaseTokenStore).l2WBaseTokenAddress(s.chainId);\n        }\n\n        // It is required for a base token to implement the following methods\n        string memory baseTokenName;\n        string memory baseTokenSymbol;\n        if (_baseTokenAddress == ETH_TOKEN_ADDRESS) {\n            baseTokenName = string(\"Ether\");\n            baseTokenSymbol = string(\"ETH\");\n        } else {\n            try this.getTokenName(_baseTokenAddress) returns (string memory name) {\n                baseTokenName = name;\n            } catch {\n                baseTokenName = string(\"Base Token\");\n            }\n\n            try this.getTokenSymbol(_baseTokenAddress) returns (string memory symbol) {\n                baseTokenSymbol = symbol;\n            } catch {\n                // \"BT\" is an acronym for \"Base Token\"\n                baseTokenSymbol = string(\"BT\");\n            }\n        }\n\n        ZKChainSpecificForceDeploymentsData\n            memory additionalForceDeploymentsData = ZKChainSpecificForceDeploymentsData({\n                baseTokenAssetId: s.baseTokenAssetId,\n                l2LegacySharedBridge: legacySharedBridge,\n                predeployedL2WethAddress: l2WBaseToken,\n                baseTokenL1Address: _baseTokenAddress,\n                baseTokenName: baseTokenName,\n                baseTokenSymbol: baseTokenSymbol\n            });\n        return abi.encode(additionalForceDeploymentsData);\n    }\n\n    function getTokenName(address _token) external view returns (string memory) {\n        return IERC20Metadata(_token).name();\n    }\n\n    function getTokenSymbol(address _token) external view returns (string memory) {\n        return IERC20Metadata(_token).symbol();\n    }\n}\n"
      },
      "contracts/upgrades/L1GenesisUpgrade.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {SafeCast} from \"@openzeppelin/contracts-v4/utils/math/SafeCast.sol\";\n\nimport {Diamond} from \"../state-transition/libraries/Diamond.sol\";\nimport {BaseZkSyncUpgradeGenesis} from \"./BaseZkSyncUpgradeGenesis.sol\";\nimport {ProposedUpgrade} from \"./IDefaultUpgrade.sol\";\nimport {L2CanonicalTransaction} from \"../common/Messaging.sol\";\nimport {IL2GenesisUpgrade} from \"../state-transition/l2-deps/IL2GenesisUpgrade.sol\";\nimport {IL1GenesisUpgrade} from \"./IL1GenesisUpgrade.sol\";\nimport {IComplexUpgrader} from \"../state-transition/l2-deps/IComplexUpgrader.sol\";\nimport {L2_FORCE_DEPLOYER_ADDR, L2_COMPLEX_UPGRADER_ADDR, L2_GENESIS_UPGRADE_ADDR} from \"../common/L2ContractAddresses.sol\"; //, COMPLEX_UPGRADER_ADDR, GENESIS_UPGRADE_ADDR\nimport {REQUIRED_L2_GAS_PRICE_PER_PUBDATA, SYSTEM_UPGRADE_L2_TX_TYPE, PRIORITY_TX_MAX_GAS_LIMIT} from \"../common/Config.sol\";\nimport {SemVer} from \"../common/libraries/SemVer.sol\";\n\nimport {IBridgehub} from \"../bridgehub/IBridgehub.sol\";\n\nimport {VerifierParams} from \"../state-transition/chain-interfaces/IVerifier.sol\";\nimport {L2ContractHelper} from \"../common/libraries/L2ContractHelper.sol\";\nimport {L1GatewayBase} from \"./L1GatewayBase.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract L1GenesisUpgrade is IL1GenesisUpgrade, BaseZkSyncUpgradeGenesis, L1GatewayBase {\n    /// @notice The main function that will be called by the Admin facet.\n    /// @param _l1GenesisUpgrade the address of the l1 genesis upgrade\n    /// @param _chainId the chain id\n    /// @param _protocolVersion the current protocol version\n    /// @param _l1CtmDeployerAddress the address of the l1 ctm deployer\n    /// @param _fixedForceDeploymentsData the force deployments data\n    /// @param _factoryDeps the factory dependencies\n    function genesisUpgrade(\n        address _l1GenesisUpgrade,\n        uint256 _chainId,\n        uint256 _protocolVersion,\n        address _l1CtmDeployerAddress,\n        bytes calldata _fixedForceDeploymentsData,\n        bytes[] calldata _factoryDeps\n    ) public override returns (bytes32) {\n        address baseTokenAddress = IBridgehub(s.bridgehub).baseToken(_chainId);\n\n        L2CanonicalTransaction memory l2ProtocolUpgradeTx;\n\n        {\n            bytes memory complexUpgraderCalldata;\n            {\n                bytes memory additionalForceDeploymentsData = getZKChainSpecificForceDeploymentsData(\n                    s,\n                    address(0),\n                    baseTokenAddress\n                );\n                bytes memory l2GenesisUpgradeCalldata = abi.encodeCall(\n                    IL2GenesisUpgrade.genesisUpgrade,\n                    (_chainId, _l1CtmDeployerAddress, _fixedForceDeploymentsData, additionalForceDeploymentsData)\n                );\n                complexUpgraderCalldata = abi.encodeCall(\n                    IComplexUpgrader.upgrade,\n                    (L2_GENESIS_UPGRADE_ADDR, l2GenesisUpgradeCalldata)\n                );\n            }\n\n            // slither-disable-next-line unused-return\n            (, uint32 minorVersion, ) = SemVer.unpackSemVer(SafeCast.toUint96(_protocolVersion));\n            l2ProtocolUpgradeTx = L2CanonicalTransaction({\n                txType: SYSTEM_UPGRADE_L2_TX_TYPE,\n                from: uint256(uint160(L2_FORCE_DEPLOYER_ADDR)),\n                to: uint256(uint160(L2_COMPLEX_UPGRADER_ADDR)),\n                gasLimit: PRIORITY_TX_MAX_GAS_LIMIT,\n                gasPerPubdataByteLimit: REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n                maxFeePerGas: uint256(0),\n                maxPriorityFeePerGas: uint256(0),\n                paymaster: uint256(0),\n                // Note, that the protocol version is used as \"nonce\" for system upgrade transactions\n                nonce: minorVersion,\n                value: 0,\n                reserved: [uint256(0), 0, 0, 0],\n                data: complexUpgraderCalldata,\n                signature: new bytes(0),\n                factoryDeps: L2ContractHelper.hashFactoryDeps(_factoryDeps),\n                paymasterInput: new bytes(0),\n                reservedDynamic: new bytes(0)\n            });\n        }\n        ProposedUpgrade memory proposedUpgrade = ProposedUpgrade({\n            l2ProtocolUpgradeTx: l2ProtocolUpgradeTx,\n            bootloaderHash: bytes32(0),\n            defaultAccountHash: bytes32(0),\n            verifier: address(0),\n            verifierParams: VerifierParams({\n                recursionNodeLevelVkHash: bytes32(0),\n                recursionLeafLevelVkHash: bytes32(0),\n                recursionCircuitsSetVksHash: bytes32(0)\n            }),\n            l1ContractsUpgradeCalldata: new bytes(0),\n            postUpgradeCalldata: new bytes(0),\n            upgradeTimestamp: 0,\n            newProtocolVersion: _protocolVersion\n        });\n\n        Diamond.FacetCut[] memory emptyArray;\n        Diamond.DiamondCutData memory cutData = Diamond.DiamondCutData({\n            facetCuts: emptyArray,\n            initAddress: _l1GenesisUpgrade,\n            initCalldata: abi.encodeCall(this.upgrade, (proposedUpgrade))\n        });\n        Diamond.diamondCut(cutData);\n\n        emit GenesisUpgrade(address(this), l2ProtocolUpgradeTx, _protocolVersion, _factoryDeps);\n        return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE;\n    }\n\n    /// @notice the upgrade function.\n    function upgrade(ProposedUpgrade calldata _proposedUpgrade) public override returns (bytes32) {\n        super.upgrade(_proposedUpgrade);\n        return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE;\n    }\n}\n"
      },
      "contracts/upgrades/ZkSyncUpgradeErrors.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.21;\n\n// 0xd7f8c13e\nerror PreviousUpgradeBatchNotCleared();\n// 0x3c43ccce\nerror ProtocolMajorVersionNotZero();\n// 0xd7f50a9d\nerror PatchCantSetUpgradeTxn();\n// 0xd2c011d6\nerror L2UpgradeNonceNotEqualToNewProtocolVersion(uint256 nonce, uint256 protocolVersion);\n// 0x88d7b498\nerror ProtocolVersionTooSmall();\n// 0x5c598b60\nerror PreviousProtocolMajorVersionNotZero();\n// 0x72ea85ad\nerror NewProtocolMajorVersionNotZero();\n// 0xd328c12a\nerror ProtocolVersionMinorDeltaTooBig(uint256 limit, uint256 proposed);\n// 0xe1a9736b\nerror ProtocolVersionDeltaTooLarge(uint256 _proposedDelta, uint256 _maxDelta);\n// 0x559cc34e\nerror PatchUpgradeCantSetDefaultAccount();\n// 0x962fd7d0\nerror PatchUpgradeCantSetBootloader();\n// 0x101ba748\nerror PreviousUpgradeNotFinalized(bytes32 txHash);\n// 0xa0f47245\nerror PreviousUpgradeNotCleaned();\n// 0x76da24b9\nerror TooManyFactoryDeps();\n// 0x5cb29523\nerror InvalidTxType(uint256 txType);\n// 0x08753982\nerror TimeNotReached(uint256 expectedTimestamp, uint256 actualTimestamp);\n// 0xd92e233d\nerror ZeroAddress();\n\n// 0x388b6f68\nerror GatewayUpgradeFailed();\n"
      },
      "contracts/vendor/AddressAliasHelper.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.21;\n\nlibrary AddressAliasHelper {\n    uint160 private constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function converts the address that submitted a tx\n    /// to the inbox on L1 to the msg.sender viewed on L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + offset);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed on L2 to the\n    /// address that submitted a tx to the inbox on L1\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - offset);\n        }\n    }\n\n    /// @notice Utility function used to calculate the correct refund recipient\n    /// @param _refundRecipient the address that should receive the refund\n    /// @param _originalCaller the address that triggered the tx to L2\n    /// @return _recipient the corrected address that should receive the refund\n    function actualRefundRecipient(\n        address _refundRecipient,\n        address _originalCaller\n    ) internal view returns (address _recipient) {\n        if (_refundRecipient == address(0)) {\n            // If the `_refundRecipient` is not provided, we use the `_originalCaller` as the recipient.\n            // solhint-disable avoid-tx-origin\n            // slither-disable-next-line tx-origin\n            _recipient = _originalCaller == tx.origin\n                ? _originalCaller\n                : AddressAliasHelper.applyL1ToL2Alias(_originalCaller);\n            // solhint-enable avoid-tx-origin\n        } else if (_refundRecipient.code.length > 0) {\n            // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n            _recipient = AddressAliasHelper.applyL1ToL2Alias(_refundRecipient);\n        } else {\n            _recipient = _refundRecipient;\n        }\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-upgradeable-v4/contracts/access/Ownable2StepUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./OwnableUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    function __Ownable2Step_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
      },
      "lib/openzeppelin-contracts-upgradeable-v4/contracts/access/OwnableUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
      },
      "lib/openzeppelin-contracts-upgradeable-v4/contracts/interfaces/IERC5267Upgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267Upgradeable {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
      },
      "lib/openzeppelin-contracts-upgradeable-v4/contracts/proxy/utils/Initializable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-upgradeable-v4/contracts/security/PausableUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
      },
      "lib/openzeppelin-contracts-upgradeable-v4/contracts/token/ERC20/ERC20Upgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
      },
      "lib/openzeppelin-contracts-upgradeable-v4/contracts/token/ERC20/IERC20Upgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
      },
      "lib/openzeppelin-contracts-upgradeable-v4/contracts/token/ERC20/extensions/ERC20PermitUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20PermitUpgradeable.sol\";\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../utils/cryptography/EIP712Upgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 51\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }\n\n    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n    /**\n     * @inheritdoc IERC20PermitUpgradeable\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20PermitUpgradeable\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @inheritdoc IERC20PermitUpgradeable\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
      },
      "lib/openzeppelin-contracts-upgradeable-v4/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
      },
      "lib/openzeppelin-contracts-upgradeable-v4/contracts/token/ERC20/extensions/IERC20PermitUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
      },
      "lib/openzeppelin-contracts-upgradeable-v4/contracts/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n// EIP-2612 is Final as of 2022-11-01. This file is deprecated.\n\nimport \"./ERC20PermitUpgradeable.sol\";\n"
      },
      "lib/openzeppelin-contracts-upgradeable-v4/contracts/utils/AddressUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-upgradeable-v4/contracts/utils/ContextUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
      },
      "lib/openzeppelin-contracts-upgradeable-v4/contracts/utils/CountersUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-upgradeable-v4/contracts/utils/StringsUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-upgradeable-v4/contracts/utils/cryptography/ECDSAUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-upgradeable-v4/contracts/utils/cryptography/EIP712Upgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../interfaces/IERC5267Upgradeable.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 52\n */\nabstract contract EIP712Upgradeable is Initializable, IERC5267Upgradeable {\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /// @custom:oz-renamed-from _HASHED_NAME\n    bytes32 private _hashedName;\n    /// @custom:oz-renamed-from _HASHED_VERSION\n    bytes32 private _hashedVersion;\n\n    string private _name;\n    string private _version;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        _name = name;\n        _version = version;\n\n        // Reset prior values in storage if upgrading\n        _hashedName = 0;\n        _hashedVersion = 0;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\n        require(_hashedName == 0 && _hashedVersion == 0, \"EIP712: Uninitialized\");\n\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Name() internal virtual view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Version() internal virtual view returns (string memory) {\n        return _version;\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\n     */\n    function _EIP712NameHash() internal view returns (bytes32) {\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\n            bytes32 hashedName = _hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\n     */\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\n            bytes32 hashedVersion = _hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
      },
      "lib/openzeppelin-contracts-upgradeable-v4/contracts/utils/math/MathUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-upgradeable-v4/contracts/utils/math/SignedMathUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/access/AccessControl.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/access/AccessControlDefaultAdminRules.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControlDefaultAdminRules.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./AccessControl.sol\";\nimport \"./IAccessControlDefaultAdminRules.sol\";\nimport \"../utils/math/SafeCast.sol\";\nimport \"../interfaces/IERC5313.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows specifying special rules to manage\n * the `DEFAULT_ADMIN_ROLE` holder, which is a sensitive role with special permissions\n * over other roles that may potentially have privileged rights in the system.\n *\n * If a specific role doesn't have an admin role assigned, the holder of the\n * `DEFAULT_ADMIN_ROLE` will have the ability to grant it and revoke it.\n *\n * This contract implements the following risk mitigations on top of {AccessControl}:\n *\n * * Only one account holds the `DEFAULT_ADMIN_ROLE` since deployment until it's potentially renounced.\n * * Enforces a 2-step process to transfer the `DEFAULT_ADMIN_ROLE` to another account.\n * * Enforces a configurable delay between the two steps, with the ability to cancel before the transfer is accepted.\n * * The delay can be changed by scheduling, see {changeDefaultAdminDelay}.\n * * It is not possible to use another role to manage the `DEFAULT_ADMIN_ROLE`.\n *\n * Example usage:\n *\n * ```solidity\n * contract MyToken is AccessControlDefaultAdminRules {\n *   constructor() AccessControlDefaultAdminRules(\n *     3 days,\n *     msg.sender // Explicit initial `DEFAULT_ADMIN_ROLE` holder\n *    ) {}\n * }\n * ```\n *\n * _Available since v4.9._\n */\nabstract contract AccessControlDefaultAdminRules is IAccessControlDefaultAdminRules, IERC5313, AccessControl {\n    // pending admin pair read/written together frequently\n    address private _pendingDefaultAdmin;\n    uint48 private _pendingDefaultAdminSchedule; // 0 == unset\n\n    uint48 private _currentDelay;\n    address private _currentDefaultAdmin;\n\n    // pending delay pair read/written together frequently\n    uint48 private _pendingDelay;\n    uint48 private _pendingDelaySchedule; // 0 == unset\n\n    /**\n     * @dev Sets the initial values for {defaultAdminDelay} and {defaultAdmin} address.\n     */\n    constructor(uint48 initialDelay, address initialDefaultAdmin) {\n        require(initialDefaultAdmin != address(0), \"AccessControl: 0 default admin\");\n        _currentDelay = initialDelay;\n        _grantRole(DEFAULT_ADMIN_ROLE, initialDefaultAdmin);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlDefaultAdminRules).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC5313-owner}.\n     */\n    function owner() public view virtual returns (address) {\n        return defaultAdmin();\n    }\n\n    ///\n    /// Override AccessControl role management\n    ///\n\n    /**\n     * @dev See {AccessControl-grantRole}. Reverts for `DEFAULT_ADMIN_ROLE`.\n     */\n    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        require(role != DEFAULT_ADMIN_ROLE, \"AccessControl: can't directly grant default admin role\");\n        super.grantRole(role, account);\n    }\n\n    /**\n     * @dev See {AccessControl-revokeRole}. Reverts for `DEFAULT_ADMIN_ROLE`.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        require(role != DEFAULT_ADMIN_ROLE, \"AccessControl: can't directly revoke default admin role\");\n        super.revokeRole(role, account);\n    }\n\n    /**\n     * @dev See {AccessControl-renounceRole}.\n     *\n     * For the `DEFAULT_ADMIN_ROLE`, it only allows renouncing in two steps by first calling\n     * {beginDefaultAdminTransfer} to the `address(0)`, so it's required that the {pendingDefaultAdmin} schedule\n     * has also passed when calling this function.\n     *\n     * After its execution, it will not be possible to call `onlyRole(DEFAULT_ADMIN_ROLE)` functions.\n     *\n     * NOTE: Renouncing `DEFAULT_ADMIN_ROLE` will leave the contract without a {defaultAdmin},\n     * thereby disabling any functionality that is only available for it, and the possibility of reassigning a\n     * non-administrated role.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        if (role == DEFAULT_ADMIN_ROLE && account == defaultAdmin()) {\n            (address newDefaultAdmin, uint48 schedule) = pendingDefaultAdmin();\n            require(\n                newDefaultAdmin == address(0) && _isScheduleSet(schedule) && _hasSchedulePassed(schedule),\n                \"AccessControl: only can renounce in two delayed steps\"\n            );\n            delete _pendingDefaultAdminSchedule;\n        }\n        super.renounceRole(role, account);\n    }\n\n    /**\n     * @dev See {AccessControl-_grantRole}.\n     *\n     * For `DEFAULT_ADMIN_ROLE`, it only allows granting if there isn't already a {defaultAdmin} or if the\n     * role has been previously renounced.\n     *\n     * NOTE: Exposing this function through another mechanism may make the `DEFAULT_ADMIN_ROLE`\n     * assignable again. Make sure to guarantee this is the expected behavior in your implementation.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        if (role == DEFAULT_ADMIN_ROLE) {\n            require(defaultAdmin() == address(0), \"AccessControl: default admin already granted\");\n            _currentDefaultAdmin = account;\n        }\n        super._grantRole(role, account);\n    }\n\n    /**\n     * @dev See {AccessControl-_revokeRole}.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        if (role == DEFAULT_ADMIN_ROLE && account == defaultAdmin()) {\n            delete _currentDefaultAdmin;\n        }\n        super._revokeRole(role, account);\n    }\n\n    /**\n     * @dev See {AccessControl-_setRoleAdmin}. Reverts for `DEFAULT_ADMIN_ROLE`.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual override {\n        require(role != DEFAULT_ADMIN_ROLE, \"AccessControl: can't violate default admin rules\");\n        super._setRoleAdmin(role, adminRole);\n    }\n\n    ///\n    /// AccessControlDefaultAdminRules accessors\n    ///\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function defaultAdmin() public view virtual returns (address) {\n        return _currentDefaultAdmin;\n    }\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function pendingDefaultAdmin() public view virtual returns (address newAdmin, uint48 schedule) {\n        return (_pendingDefaultAdmin, _pendingDefaultAdminSchedule);\n    }\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function defaultAdminDelay() public view virtual returns (uint48) {\n        uint48 schedule = _pendingDelaySchedule;\n        return (_isScheduleSet(schedule) && _hasSchedulePassed(schedule)) ? _pendingDelay : _currentDelay;\n    }\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function pendingDefaultAdminDelay() public view virtual returns (uint48 newDelay, uint48 schedule) {\n        schedule = _pendingDelaySchedule;\n        return (_isScheduleSet(schedule) && !_hasSchedulePassed(schedule)) ? (_pendingDelay, schedule) : (0, 0);\n    }\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function defaultAdminDelayIncreaseWait() public view virtual returns (uint48) {\n        return 5 days;\n    }\n\n    ///\n    /// AccessControlDefaultAdminRules public and internal setters for defaultAdmin/pendingDefaultAdmin\n    ///\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function beginDefaultAdminTransfer(address newAdmin) public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _beginDefaultAdminTransfer(newAdmin);\n    }\n\n    /**\n     * @dev See {beginDefaultAdminTransfer}.\n     *\n     * Internal function without access restriction.\n     */\n    function _beginDefaultAdminTransfer(address newAdmin) internal virtual {\n        uint48 newSchedule = SafeCast.toUint48(block.timestamp) + defaultAdminDelay();\n        _setPendingDefaultAdmin(newAdmin, newSchedule);\n        emit DefaultAdminTransferScheduled(newAdmin, newSchedule);\n    }\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function cancelDefaultAdminTransfer() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _cancelDefaultAdminTransfer();\n    }\n\n    /**\n     * @dev See {cancelDefaultAdminTransfer}.\n     *\n     * Internal function without access restriction.\n     */\n    function _cancelDefaultAdminTransfer() internal virtual {\n        _setPendingDefaultAdmin(address(0), 0);\n    }\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function acceptDefaultAdminTransfer() public virtual {\n        (address newDefaultAdmin, ) = pendingDefaultAdmin();\n        require(_msgSender() == newDefaultAdmin, \"AccessControl: pending admin must accept\");\n        _acceptDefaultAdminTransfer();\n    }\n\n    /**\n     * @dev See {acceptDefaultAdminTransfer}.\n     *\n     * Internal function without access restriction.\n     */\n    function _acceptDefaultAdminTransfer() internal virtual {\n        (address newAdmin, uint48 schedule) = pendingDefaultAdmin();\n        require(_isScheduleSet(schedule) && _hasSchedulePassed(schedule), \"AccessControl: transfer delay not passed\");\n        _revokeRole(DEFAULT_ADMIN_ROLE, defaultAdmin());\n        _grantRole(DEFAULT_ADMIN_ROLE, newAdmin);\n        delete _pendingDefaultAdmin;\n        delete _pendingDefaultAdminSchedule;\n    }\n\n    ///\n    /// AccessControlDefaultAdminRules public and internal setters for defaultAdminDelay/pendingDefaultAdminDelay\n    ///\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function changeDefaultAdminDelay(uint48 newDelay) public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _changeDefaultAdminDelay(newDelay);\n    }\n\n    /**\n     * @dev See {changeDefaultAdminDelay}.\n     *\n     * Internal function without access restriction.\n     */\n    function _changeDefaultAdminDelay(uint48 newDelay) internal virtual {\n        uint48 newSchedule = SafeCast.toUint48(block.timestamp) + _delayChangeWait(newDelay);\n        _setPendingDelay(newDelay, newSchedule);\n        emit DefaultAdminDelayChangeScheduled(newDelay, newSchedule);\n    }\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function rollbackDefaultAdminDelay() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _rollbackDefaultAdminDelay();\n    }\n\n    /**\n     * @dev See {rollbackDefaultAdminDelay}.\n     *\n     * Internal function without access restriction.\n     */\n    function _rollbackDefaultAdminDelay() internal virtual {\n        _setPendingDelay(0, 0);\n    }\n\n    /**\n     * @dev Returns the amount of seconds to wait after the `newDelay` will\n     * become the new {defaultAdminDelay}.\n     *\n     * The value returned guarantees that if the delay is reduced, it will go into effect\n     * after a wait that honors the previously set delay.\n     *\n     * See {defaultAdminDelayIncreaseWait}.\n     */\n    function _delayChangeWait(uint48 newDelay) internal view virtual returns (uint48) {\n        uint48 currentDelay = defaultAdminDelay();\n\n        // When increasing the delay, we schedule the delay change to occur after a period of \"new delay\" has passed, up\n        // to a maximum given by defaultAdminDelayIncreaseWait, by default 5 days. For example, if increasing from 1 day\n        // to 3 days, the new delay will come into effect after 3 days. If increasing from 1 day to 10 days, the new\n        // delay will come into effect after 5 days. The 5 day wait period is intended to be able to fix an error like\n        // using milliseconds instead of seconds.\n        //\n        // When decreasing the delay, we wait the difference between \"current delay\" and \"new delay\". This guarantees\n        // that an admin transfer cannot be made faster than \"current delay\" at the time the delay change is scheduled.\n        // For example, if decreasing from 10 days to 3 days, the new delay will come into effect after 7 days.\n        return\n            newDelay > currentDelay\n                ? uint48(Math.min(newDelay, defaultAdminDelayIncreaseWait())) // no need to safecast, both inputs are uint48\n                : currentDelay - newDelay;\n    }\n\n    ///\n    /// Private setters\n    ///\n\n    /**\n     * @dev Setter of the tuple for pending admin and its schedule.\n     *\n     * May emit a DefaultAdminTransferCanceled event.\n     */\n    function _setPendingDefaultAdmin(address newAdmin, uint48 newSchedule) private {\n        (, uint48 oldSchedule) = pendingDefaultAdmin();\n\n        _pendingDefaultAdmin = newAdmin;\n        _pendingDefaultAdminSchedule = newSchedule;\n\n        // An `oldSchedule` from `pendingDefaultAdmin()` is only set if it hasn't been accepted.\n        if (_isScheduleSet(oldSchedule)) {\n            // Emit for implicit cancellations when another default admin was scheduled.\n            emit DefaultAdminTransferCanceled();\n        }\n    }\n\n    /**\n     * @dev Setter of the tuple for pending delay and its schedule.\n     *\n     * May emit a DefaultAdminDelayChangeCanceled event.\n     */\n    function _setPendingDelay(uint48 newDelay, uint48 newSchedule) private {\n        uint48 oldSchedule = _pendingDelaySchedule;\n\n        if (_isScheduleSet(oldSchedule)) {\n            if (_hasSchedulePassed(oldSchedule)) {\n                // Materialize a virtual delay\n                _currentDelay = _pendingDelay;\n            } else {\n                // Emit for implicit cancellations when another delay was scheduled.\n                emit DefaultAdminDelayChangeCanceled();\n            }\n        }\n\n        _pendingDelay = newDelay;\n        _pendingDelaySchedule = newSchedule;\n    }\n\n    ///\n    /// Private helpers\n    ///\n\n    /**\n     * @dev Defines if an `schedule` is considered set. For consistency purposes.\n     */\n    function _isScheduleSet(uint48 schedule) private pure returns (bool) {\n        return schedule != 0;\n    }\n\n    /**\n     * @dev Defines if an `schedule` is considered passed. For consistency purposes.\n     */\n    function _hasSchedulePassed(uint48 schedule) private view returns (bool) {\n        return schedule < block.timestamp;\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/access/IAccessControl.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/access/IAccessControlDefaultAdminRules.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/IAccessControlDefaultAdminRules.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlDefaultAdminRules declared to support ERC165 detection.\n *\n * _Available since v4.9._\n */\ninterface IAccessControlDefaultAdminRules is IAccessControl {\n    /**\n     * @dev Emitted when a {defaultAdmin} transfer is started, setting `newAdmin` as the next\n     * address to become the {defaultAdmin} by calling {acceptDefaultAdminTransfer} only after `acceptSchedule`\n     * passes.\n     */\n    event DefaultAdminTransferScheduled(address indexed newAdmin, uint48 acceptSchedule);\n\n    /**\n     * @dev Emitted when a {pendingDefaultAdmin} is reset if it was never accepted, regardless of its schedule.\n     */\n    event DefaultAdminTransferCanceled();\n\n    /**\n     * @dev Emitted when a {defaultAdminDelay} change is started, setting `newDelay` as the next\n     * delay to be applied between default admin transfer after `effectSchedule` has passed.\n     */\n    event DefaultAdminDelayChangeScheduled(uint48 newDelay, uint48 effectSchedule);\n\n    /**\n     * @dev Emitted when a {pendingDefaultAdminDelay} is reset if its schedule didn't pass.\n     */\n    event DefaultAdminDelayChangeCanceled();\n\n    /**\n     * @dev Returns the address of the current `DEFAULT_ADMIN_ROLE` holder.\n     */\n    function defaultAdmin() external view returns (address);\n\n    /**\n     * @dev Returns a tuple of a `newAdmin` and an accept schedule.\n     *\n     * After the `schedule` passes, the `newAdmin` will be able to accept the {defaultAdmin} role\n     * by calling {acceptDefaultAdminTransfer}, completing the role transfer.\n     *\n     * A zero value only in `acceptSchedule` indicates no pending admin transfer.\n     *\n     * NOTE: A zero address `newAdmin` means that {defaultAdmin} is being renounced.\n     */\n    function pendingDefaultAdmin() external view returns (address newAdmin, uint48 acceptSchedule);\n\n    /**\n     * @dev Returns the delay required to schedule the acceptance of a {defaultAdmin} transfer started.\n     *\n     * This delay will be added to the current timestamp when calling {beginDefaultAdminTransfer} to set\n     * the acceptance schedule.\n     *\n     * NOTE: If a delay change has been scheduled, it will take effect as soon as the schedule passes, making this\n     * function returns the new delay. See {changeDefaultAdminDelay}.\n     */\n    function defaultAdminDelay() external view returns (uint48);\n\n    /**\n     * @dev Returns a tuple of `newDelay` and an effect schedule.\n     *\n     * After the `schedule` passes, the `newDelay` will get into effect immediately for every\n     * new {defaultAdmin} transfer started with {beginDefaultAdminTransfer}.\n     *\n     * A zero value only in `effectSchedule` indicates no pending delay change.\n     *\n     * NOTE: A zero value only for `newDelay` means that the next {defaultAdminDelay}\n     * will be zero after the effect schedule.\n     */\n    function pendingDefaultAdminDelay() external view returns (uint48 newDelay, uint48 effectSchedule);\n\n    /**\n     * @dev Starts a {defaultAdmin} transfer by setting a {pendingDefaultAdmin} scheduled for acceptance\n     * after the current timestamp plus a {defaultAdminDelay}.\n     *\n     * Requirements:\n     *\n     * - Only can be called by the current {defaultAdmin}.\n     *\n     * Emits a DefaultAdminRoleChangeStarted event.\n     */\n    function beginDefaultAdminTransfer(address newAdmin) external;\n\n    /**\n     * @dev Cancels a {defaultAdmin} transfer previously started with {beginDefaultAdminTransfer}.\n     *\n     * A {pendingDefaultAdmin} not yet accepted can also be cancelled with this function.\n     *\n     * Requirements:\n     *\n     * - Only can be called by the current {defaultAdmin}.\n     *\n     * May emit a DefaultAdminTransferCanceled event.\n     */\n    function cancelDefaultAdminTransfer() external;\n\n    /**\n     * @dev Completes a {defaultAdmin} transfer previously started with {beginDefaultAdminTransfer}.\n     *\n     * After calling the function:\n     *\n     * - `DEFAULT_ADMIN_ROLE` should be granted to the caller.\n     * - `DEFAULT_ADMIN_ROLE` should be revoked from the previous holder.\n     * - {pendingDefaultAdmin} should be reset to zero values.\n     *\n     * Requirements:\n     *\n     * - Only can be called by the {pendingDefaultAdmin}'s `newAdmin`.\n     * - The {pendingDefaultAdmin}'s `acceptSchedule` should've passed.\n     */\n    function acceptDefaultAdminTransfer() external;\n\n    /**\n     * @dev Initiates a {defaultAdminDelay} update by setting a {pendingDefaultAdminDelay} scheduled for getting\n     * into effect after the current timestamp plus a {defaultAdminDelay}.\n     *\n     * This function guarantees that any call to {beginDefaultAdminTransfer} done between the timestamp this\n     * method is called and the {pendingDefaultAdminDelay} effect schedule will use the current {defaultAdminDelay}\n     * set before calling.\n     *\n     * The {pendingDefaultAdminDelay}'s effect schedule is defined in a way that waiting until the schedule and then\n     * calling {beginDefaultAdminTransfer} with the new delay will take at least the same as another {defaultAdmin}\n     * complete transfer (including acceptance).\n     *\n     * The schedule is designed for two scenarios:\n     *\n     * - When the delay is changed for a larger one the schedule is `block.timestamp + newDelay` capped by\n     * {defaultAdminDelayIncreaseWait}.\n     * - When the delay is changed for a shorter one, the schedule is `block.timestamp + (current delay - new delay)`.\n     *\n     * A {pendingDefaultAdminDelay} that never got into effect will be canceled in favor of a new scheduled change.\n     *\n     * Requirements:\n     *\n     * - Only can be called by the current {defaultAdmin}.\n     *\n     * Emits a DefaultAdminDelayChangeScheduled event and may emit a DefaultAdminDelayChangeCanceled event.\n     */\n    function changeDefaultAdminDelay(uint48 newDelay) external;\n\n    /**\n     * @dev Cancels a scheduled {defaultAdminDelay} change.\n     *\n     * Requirements:\n     *\n     * - Only can be called by the current {defaultAdmin}.\n     *\n     * May emit a DefaultAdminDelayChangeCanceled event.\n     */\n    function rollbackDefaultAdminDelay() external;\n\n    /**\n     * @dev Maximum time in seconds for an increase to {defaultAdminDelay} (that is scheduled using {changeDefaultAdminDelay})\n     * to take effect. Default to 5 days.\n     *\n     * When the {defaultAdminDelay} is scheduled to be increased, it goes into effect after the new delay has passed with\n     * the purpose of giving enough time for reverting any accidental change (i.e. using milliseconds instead of seconds)\n     * that may lock the contract. However, to avoid excessive schedules, the wait is capped by this function and it can\n     * be overrode for a custom {defaultAdminDelay} increase scheduling.\n     *\n     * IMPORTANT: Make sure to add a reasonable amount of time while overriding this value, otherwise,\n     * there's a risk of setting a high new delay that goes into effect almost immediately without the\n     * possibility of human intervention in the case of an input error (eg. set milliseconds instead of seconds).\n     */\n    function defaultAdminDelayIncreaseWait() external view returns (uint48);\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/access/Ownable2Step.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/interfaces/IERC1967.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/interfaces/IERC5313.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5313.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface for the Light Contract Ownership Standard.\n *\n * A standardized minimal interface required to identify an account that controls a contract\n *\n * _Available since v4.9._\n */\ninterface IERC5313 {\n    /**\n     * @dev Gets the address of the owner.\n     */\n    function owner() external view returns (address);\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/interfaces/draft-IERC1822.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/proxy/Proxy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/proxy/beacon/BeaconProxy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../Proxy.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/proxy/beacon/IBeacon.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/proxy/beacon/UpgradeableBeacon.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../../access/Ownable.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableBeacon: implementation is not a contract\");\n        _implementation = newImplementation;\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/proxy/transparent/ProxyAdmin.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(ITransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(ITransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        ITransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\n * does not implement this interface directly, and some of its functions are implemented by an internal dispatch\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\n * include them in the ABI so this interface must be used to interact with it.\n */\ninterface ITransparentUpgradeableProxy is IERC1967 {\n    function admin() external view returns (address);\n\n    function implementation() external view returns (address);\n\n    function changeAdmin(address) external;\n\n    function upgradeTo(address) external;\n\n    function upgradeToAndCall(address, bytes memory) external payable;\n}\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n *\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\n * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\n * implementation.\n *\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the compiler\n * will not check that there are no selector conflicts, due to the note above. A selector clash between any new function\n * and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This could\n * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     *\n     * CAUTION: This modifier is deprecated, as it could cause issues if the modified function has arguments, and the\n     * implementation provides a function with the same selector.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior\n     */\n    function _fallback() internal virtual override {\n        if (msg.sender == _getAdmin()) {\n            bytes memory ret;\n            bytes4 selector = msg.sig;\n            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {\n                ret = _dispatchUpgradeTo();\n            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n                ret = _dispatchUpgradeToAndCall();\n            } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {\n                ret = _dispatchChangeAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.admin.selector) {\n                ret = _dispatchAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {\n                ret = _dispatchImplementation();\n            } else {\n                revert(\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n            }\n            assembly {\n                return(add(ret, 0x20), mload(ret))\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function _dispatchAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address admin = _getAdmin();\n        return abi.encode(admin);\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _dispatchImplementation() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address implementation = _implementation();\n        return abi.encode(implementation);\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _dispatchChangeAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newAdmin = abi.decode(msg.data[4:], (address));\n        _changeAdmin(newAdmin);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     */\n    function _dispatchUpgradeTo() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newImplementation = abi.decode(msg.data[4:], (address));\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     */\n    function _dispatchUpgradeToAndCall() private returns (bytes memory) {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        _upgradeToAndCall(newImplementation, data, true);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * CAUTION: This function is deprecated. Use {ERC1967Upgrade-_getAdmin} instead.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev To keep this contract fully transparent, all `ifAdmin` functions must be payable. This helper is here to\n     * emulate some proxy functions being non-payable while still allowing value to pass through.\n     */\n    function _requireZeroValue() private {\n        require(msg.value == 0);\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/proxy/utils/Initializable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/token/ERC20/ERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/token/ERC20/extensions/IERC20Permit.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/utils/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/utils/Arrays.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Arrays.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./StorageSlot.sol\";\nimport \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    using StorageSlot for bytes32;\n\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds down (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\n        bytes32 slot;\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\n        // following https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getAddressSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\n        bytes32 slot;\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\n        // following https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getBytes32Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\n        bytes32 slot;\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\n        // following https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getUint256Slot();\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/utils/Create2.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := keccak256(start, 85)\n        }\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/utils/StorageSlot.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/utils/Strings.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/utils/introspection/ERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/utils/math/Math.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/utils/math/SafeCast.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/utils/math/SignedMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/utils/structs/EnumerableMap.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity ^0.8.0;\n\nimport \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), errorMessage);\n        return value;\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\n        return map._keys.values();\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(UintToUintMap storage map, uint256 key, string memory errorMessage) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key), errorMessage));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        AddressToUintMap storage map,\n        address key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, key, errorMessage));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
      },
      "lib/openzeppelin-contracts-v4/contracts/utils/structs/EnumerableSet.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
      }
    },
    "settings": {
      "viaIR": false,
      "codegen": "yul",
      "remappings": [
        "@ensdomains/=node_modules/@ensdomains/",
        "ds-test/=lib/forge-std/lib/ds-test/src/",
        "eth-gas-reporter/=node_modules/eth-gas-reporter/",
        "forge-std/=lib/forge-std/src/",
        "hardhat/=node_modules/hardhat/",
        "murky/=lib/murky/src/",
        "foundry-test/=test/foundry/",
        "l2-contracts/=../l2-contracts/contracts/",
        "@openzeppelin/contracts-v4/=lib/openzeppelin-contracts-v4/contracts/",
        "@openzeppelin/contracts-upgradeable-v4/=lib/openzeppelin-contracts-upgradeable-v4/contracts/",
        "@openzeppelin/=node_modules/@openzeppelin/",
        "erc4626-tests/=lib/openzeppelin-contracts-upgradeable-v4/lib/erc4626-tests/",
        "openzeppelin-contracts-upgradeable-v4/=lib/openzeppelin-contracts-upgradeable-v4/",
        "openzeppelin-contracts-v4/=lib/openzeppelin-contracts-v4/",
        "openzeppelin-contracts/=lib/murky/lib/openzeppelin-contracts/"
      ],
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [],
          "*": ["abi"]
        }
      },
      "optimizer": {
        "enabled": true,
        "mode": "3",
        "fallback_to_optimizing_for_size": false,
        "disable_system_request_memoization": true
      },
      "metadata": {},
      "libraries": {},
      "detectMissingLibraries": false,
      "enableEraVMExtensions": true,
      "forceEVMLA": false
    }
  },
  "contractName": "contracts/bridgehub/Bridgehub.sol:Bridgehub",
  "compilerSolcVersion": "zkVM-0.8.24-1.0.1",
  "compilerZksolcVersion": "v1.5.7",
  "optimizationUsed": true,
  "constructorArguments": "0x0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000f41eca3047b37dc7d88849de4a4dc07937ad6bc40000000000000000000000000000000000000000000000000000000000000064",
  "isSystem": true,
  "forceEvmla": false,
  "evmVersion": "cancun",
  "optimizerRuns": 200
}
