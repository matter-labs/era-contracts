// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

// solhint-disable no-console, gas-struct-packing, gas-custom-errors

import {Script, console2 as console} from "forge-std/Script.sol";
import {stdToml} from "forge-std/StdToml.sol";

import {IBridgehub} from "contracts/bridgehub/IBridgehub.sol";
import {Bridgehub} from "contracts/bridgehub/Bridgehub.sol";
import {L2ContractHelper} from "contracts/common/libraries/L2ContractHelper.sol";
import {AddressAliasHelper} from "contracts/vendor/AddressAliasHelper.sol";
import {L1AssetRouter} from "contracts/bridge/L1AssetRouter.sol";
import {IChainTypeManager} from "contracts/state-transition/IChainTypeManager.sol";
import {IGovernance} from "contracts/governance/IGovernance.sol";
import {DataEncoding} from "contracts/common/libraries/DataEncoding.sol";
import {Utils, ADDRESS_ONE} from "./Utils.sol";

/**
 * @title Prepare ZKChain Registration Calldata
 * @dev Script to prepare calldata for registering a new ZKChain on the bridgehub
 *
 * This script prepares calldata for registering a new ZKChain on the bridgehub
 * That includes 3 steps:
 * 1. Register base token on the bridgehub
 * 2. Register the new ZKChain on the bridgehub
 * 3. Initialize the L2 bridge on the L1 shared bridge
 *
 * The script precomputes the address of the L2 bridge to generate the calldata for the third step.
 * It assumes that L1 governance is the owner of the L2 bridge and the L2 bridge is deployed by the msg.sender of the script.
 *
 * The script reads the configuration from a TOML file `script-config/prepare-registration-calldata.toml`
 * and writes the output to a TOML file `script-out/output-prepare-registration-calldata.toml`.
 *
 * The output contains 4 fields:
 * - scheduleCalldataStageOne: calldata for scheduling the first stage
 * - executeCalldataStageOne: calldata for executing the first stage
 * - scheduleCalldataStageTwo: calldata for scheduling the second stage
 * - executeCalldataStageTwo: calldata for executing the second stage
 * (stage 2 of the execution is the registration of the L2 bridge on the L1 shared bridge)
 *
 * The separation is required to ensure that there is no period of time where the L2 bridge is registered, so users
 * can send their funds there, but they will be burned in case L2 bridge is not initialized by the chain operator.
 * It is meant to be executed only after the L2 bridge is deployed.
 *
 * How to use:
 * 1. Create a TOML file `script-config/prepare-registration-calldata.toml`, reference config at `deploy-script-config-template/config-prepare-registration-calldata.toml`.
 * 2. Run the script impersonating the address that will deploy the L2 bridge, `forge script --rpc-url $RPC --sender $DEPLOYER PrepareZKChainRegistrationCalldata.s.sol`
 * 3. Run the `scheduleCalldataStageOne` and `executeCalldataStageOne` on the L1 chain using governance.
 * 4. Deploy the L2 bridge using the address from step 2. This address doesn't need any special permissions, just has to be consistent across all the stages.
 * 5. Run the `scheduleCalldataStageTwo` and `executeCalldataStageTwo` on the L1 chain using governance.
 *
 */
contract PrepareZKChainRegistrationCalldataScript is Script {
    using stdToml for string;

    struct Config {
        // Admin of the yet-to-be-registered chain (L1-based address)
        address chainAdmin;
        // CTM proxy address
        address stateTransitionProxy;
        // Chain ID of the new chain
        uint256 chainId;
        // Chain ID of the era (required for the L2 bridge deployment)
        uint256 eraChainId;
        // Salt for createNewChain call, also used as a governance operation salt
        uint256 bridgehubCreateNewChainSalt;
        // Address of the new chain's base token
        address baseToken;
        // Diamond cut data is a "configuration" for the Diamond proxy that will be created for a new chain.
        // It can only be the one that's allowed by the CTM. It can be generated by the other scripts or taken from the
        // `etc/env/ecosystems/ENV.yaml` file in `zksync-era` repository
        bytes diamondCutData;
        // Address of the L1 ERC20 bridge proxy (required for the L2 bridge deployment)
        address erc20BridgeProxy;
        // Should be EVM emulator supported or not
        bool allowEvmEmulator;
    }

    // Addresses of the contracts in the L1 ecosystem that are fetched from the chain
    struct EcosystemContracts {
        // Address of the L1 shared bridge proxy
        address l1SharedBridgeProxy;
        // Bridgehub proxy address
        address bridgehub;
        // Address of the governance contract for the L1 ecosystem
        address governance;
    }

    struct ContractsBytecodes {
        // Default bytecode of the ERC-20 on L2 (BeaconProxy)
        bytes beaconProxy;
        // Bytecode of the L2 shared bridge
        bytes l2SharedBridgeBytecode;
        // Bytecode of the L2 shared bridge proxy (TransparentUpgradeableProxy)
        bytes l2SharedBridgeProxyBytecode;
    }

    Config internal config;
    EcosystemContracts internal ecosystem;
    ContractsBytecodes internal bytecodes;

    function run() public {
        console.log("Preparing ZK chain registration calldata");

        initializeConfig();

        checkBaseTokenAddress();

        IGovernance.Call[] memory calls;
        uint256 cnt = 0;
        if (!IBridgehub(ecosystem.bridgehub).tokenIsRegistered(config.baseToken)) {
            calls = new IGovernance.Call[](2);
            console.log("Adding a call to register base token on the bridgehub");
            IGovernance.Call memory baseTokenRegistrationCall = prepareRegisterBaseTokenCall();
            calls[cnt] = baseTokenRegistrationCall;
            ++cnt;
        } else {
            calls = new IGovernance.Call[](1);
        }

        IGovernance.Call memory registerChainCall = prepareRegisterZKChainCall();
        calls[cnt] = registerChainCall;
        ++cnt;

        address l2SharedBridgeProxy = computeL2BridgeAddress();
        IGovernance.Call memory initChainCall = prepareInitializeChainGovernanceCall(l2SharedBridgeProxy);

        scheduleTransparentCalldata(calls, initChainCall);
    }

    function initializeConfig() internal {
        // Grab config from output of l1 deployment
        string memory root = vm.projectRoot();
        string memory path = string.concat(root, "/script-config/prepare-registration-calldata.toml");
        console.log("Reading a config from", path);
        string memory toml = vm.readFile(path);

        // Config file must be parsed key by key, otherwise values returned
        // are parsed alphabetically and not by key.
        // https://book.getfoundry.sh/cheatcodes/parse-toml
        config.stateTransitionProxy = toml.readAddress("$.deployed_addresses.state_transition_proxy_addr");
        config.erc20BridgeProxy = toml.readAddress("$.deployed_addresses.erc20_bridge_proxy_addr");

        ecosystem.bridgehub = IChainTypeManager(config.stateTransitionProxy).BRIDGE_HUB();
        ecosystem.l1SharedBridgeProxy = address(Bridgehub(ecosystem.bridgehub).sharedBridge());
        ecosystem.governance = Bridgehub(ecosystem.bridgehub).owner();

        config.chainId = toml.readUint("$.chain.chain_id");
        config.eraChainId = toml.readUint("$.chain.era_chain_id");
        config.chainAdmin = toml.readAddress("$.chain.admin");
        config.diamondCutData = toml.readBytes("$.chain.diamond_cut_data");
        config.bridgehubCreateNewChainSalt = toml.readUint("$.chain.bridgehub_create_new_chain_salt");
        config.baseToken = toml.readAddress("$.chain.base_token_addr");
        config.allowEvmEmulator = toml.readBool("$.chain.allow_evm_emulator");

        bytecodes.l2SharedBridgeBytecode = Utils.readHardhatBytecode("/script-config/artifacts/L2SharedBridge.json");
        bytecodes.beaconProxy = Utils.readHardhatBytecode("/script-config/artifacts/BeaconProxy.json");
        bytecodes.l2SharedBridgeProxyBytecode = Utils.readHardhatBytecode(
            "/script-config/artifacts/TransparentUpgradeableProxy.json"
        );
    }

    function checkBaseTokenAddress() internal view {
        if (config.baseToken == address(0)) {
            revert("Base token address is not set");
        }

        // Check if it's ethereum address
        if (config.baseToken == ADDRESS_ONE) {
            return;
        }

        // Does not prevent registering a non-ERC-20 contract as a token
        // But calling the ERC-20 methods here on non-ERC-20 will fail without a readable revert message
        if (config.baseToken.code.length == 0) {
            revert("Token address is an EOA");
        }

        console.log("Using base token address:", config.baseToken);
    }

    function prepareRegisterBaseTokenCall() internal view returns (Call memory) {
        Bridgehub bridgehub = Bridgehub(ecosystem.bridgehub);

        bytes memory data = abi.encodeCall(
            bridgehub.addTokenAssetId,
            (DataEncoding.encodeNTVAssetId(block.chainid, config.baseToken))
        );

        return IGovernance.Call({target: ecosystem.bridgehub, value: 0, data: data});
    }

    // @dev Computes the address of the L2 bridge and the L2 bridge proxy
    // The variables that are used to compute the address are:
    // - Salt
    // - L2 bridge impl bytecode hash
    // - Era chain ID
    // - Beacon proxy bytecode hash
    // - L1 governance address(owner of the L2 bridge)
    // - L1 ERC20 bridge proxy address
    // - Default ERC20 proxy address
    // - Deployer's address
    function computeL2BridgeAddress() internal view returns (address) {
        bytes32 salt = "";
        bytes32 bridgeBytecodeHash = L2ContractHelper.hashL2Bytecode(bytecodes.l2SharedBridgeBytecode);
        bytes memory bridgeConstructorData = abi.encode(config.eraChainId);

        address deployer;
        address l2GovernanceAddress;

        // ZKsync's protocol design assumes that the addresses of all the smart contracts that are sending L1->L2
        // messages are aliased. We have to check if the sender is an EOA and apply the alias if it is not.
        if (isEOA(msg.sender)) {
            deployer = msg.sender;
        } else {
            deployer = AddressAliasHelper.applyL1ToL2Alias(msg.sender);
        }

        // If the governance address is an EOA, we use it directly, otherwise we apply the alias. On the Mainnet/Testnet
        // the governance address is a smart contract, but in case someone uses the script with different envs, we have
        // to check if the address is an EOA.
        if (isEOA(ecosystem.governance)) {
            l2GovernanceAddress = ecosystem.governance;
        } else {
            l2GovernanceAddress = AddressAliasHelper.applyL1ToL2Alias(ecosystem.governance);
        }

        address implContractAddress = L2ContractHelper.computeCreate2Address(
            deployer,
            salt,
            bridgeBytecodeHash,
            keccak256(bridgeConstructorData)
        );

        console.log("Computed L2 bridge impl address:", implContractAddress);
        console.log("Bridge bytecode hash:");
        console.logBytes32(bridgeBytecodeHash);
        console.log("Bridge constructor data:");
        console.logBytes(bridgeConstructorData);
        console.log("Deployer:", deployer);

        bytes32 l2StandardErc20BytecodeHash = L2ContractHelper.hashL2Bytecode(bytecodes.beaconProxy);

        // solhint-disable-next-line func-named-parameters
        bytes memory proxyInitializationParams = abi.encodeWithSignature(
            "initialize(address,address,bytes32,address)",
            ecosystem.l1SharedBridgeProxy,
            config.erc20BridgeProxy,
            l2StandardErc20BytecodeHash,
            l2GovernanceAddress
        );

        bytes memory l2SharedBridgeProxyConstructorData = abi.encode(
            implContractAddress,
            l2GovernanceAddress,
            proxyInitializationParams
        );

        address proxyContractAddress = L2ContractHelper.computeCreate2Address(
            deployer,
            salt,
            L2ContractHelper.hashL2Bytecode(bytecodes.l2SharedBridgeProxyBytecode),
            keccak256(l2SharedBridgeProxyConstructorData)
        );

        console.log("Computed L2 bridge proxy address:", proxyContractAddress);
        console.log("L1 shared bridge proxy:", ecosystem.l1SharedBridgeProxy);
        console.log("L1 ERC20 bridge proxy:", config.erc20BridgeProxy);
        console.log("L2 governor addr:", l2GovernanceAddress);

        return proxyContractAddress;
    }

    function prepareRegisterZKChainCall() internal view returns (IGovernance.Call memory) {
        Bridgehub bridgehub = Bridgehub(ecosystem.bridgehub);

        bytes memory data = abi.encodeCall(
            bridgehub.createNewChain,
            (
                config.chainId,
                config.stateTransitionProxy,
                config.baseToken,
                config.bridgehubCreateNewChainSalt,
                config.chainAdmin,
                config.diamondCutData
            )
        );

        return IGovernance.Call({target: ecosystem.bridgehub, value: 0, data: data});
    }

    function prepareInitializeChainGovernanceCall(
        address l2SharedBridgeProxy
    ) internal view returns (IGovernance.Call memory) {
        L1AssetRouter bridge = L1AssetRouter(ecosystem.l1SharedBridgeProxy);

        bytes memory data = abi.encodeCall(bridge.initializeChainGovernance, (config.chainId, l2SharedBridgeProxy));

        return IGovernance.Call({target: ecosystem.l1SharedBridgeProxy, value: 0, data: data});
    }

    // @dev Prepares a call to schedule a transparent operation on the governance contract
    // `calls` is an array of calls that will be executed in the first stage (add a token to BH, create a new chain)
    // `initChainGovCall` is a call that will be executed in the second stage (register the L2 bridge on the L1 shared bridge)
    function scheduleTransparentCalldata(Call[] memory calls, IGovernance.Call memory initChainGovCall) internal {
        IGovernance governance = IGovernance(ecosystem.governance);

        IGovernance.Operation memory operation = IGovernance.Operation({
            calls: calls,
            predecessor: bytes32(0),
            salt: bytes32(config.bridgehubCreateNewChainSalt)
        });

        bytes memory scheduleCalldata = abi.encodeCall(governance.scheduleTransparent, (operation, 0));
        bytes memory executeCalldata = abi.encodeCall(governance.execute, (operation));

        IGovernance.Call[] memory initChainGovArray = new IGovernance.Call[](1);
        initChainGovArray[0] = initChainGovCall;

        IGovernance.Operation memory operation2 = IGovernance.Operation({
            calls: initChainGovArray,
            predecessor: bytes32(0),
            salt: bytes32(config.bridgehubCreateNewChainSalt)
        });

        bytes memory scheduleCalldata2 = abi.encodeCall(governance.scheduleTransparent, (operation2, 0));
        bytes memory executeCalldata2 = abi.encodeCall(governance.execute, (operation2));

        saveOutput(scheduleCalldata, executeCalldata, scheduleCalldata2, executeCalldata2);
    }

    // Writes the output to a TOML file `script-out/output-prepare-registration-calldata.toml
    // For the detailed explanation of the output - look into the contract description
    function saveOutput(
        bytes memory schedule,
        bytes memory execute,
        bytes memory schedule2,
        bytes memory execute2
    ) internal {
        vm.serializeBytes("root", "scheduleCalldataStageOne", schedule);
        vm.serializeBytes("root", "executeCalldataStageOne", execute);
        vm.serializeBytes("root", "scheduleCalldataStageTwo", schedule2);
        string memory toml = vm.serializeBytes("root", "executeCalldataStageTwo", execute2);

        string memory root = vm.projectRoot();
        string memory path = string.concat(root, "/script-out/output-prepare-registration-calldata.toml");

        console.log("Writing the output to", path);
        vm.writeToml(toml, path);
    }

    function isEOA(address _addr) private view returns (bool) {
        uint32 size;
        assembly {
            size := extcodesize(_addr)
        }

        return (size == 0);
    }
}

// Done by the chain admin separately from this script:
// - add validators
// - deploy L2 contracts
// - set pubdata sending mode
// - set base token gas price multiplier
