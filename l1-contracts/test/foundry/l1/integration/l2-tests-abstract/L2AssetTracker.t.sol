// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;
// solhint-disable gas-custom-errors

import {StdStorage, Test, stdStorage, console} from "forge-std/Test.sol";

import {SharedL2ContractDeployer} from "./_SharedL2ContractDeployer.sol";
import {GW_ASSET_TRACKER, GW_ASSET_TRACKER_ADDR, L2_CHAIN_ASSET_HANDLER, L2_BOOTLOADER_ADDRESS, L2_BRIDGEHUB, L2_MESSAGE_ROOT, L2_MESSAGE_ROOT_ADDR} from "contracts/common/l2-helpers/L2ContractAddresses.sol";
import {ProcessLogsInput} from "contracts/state-transition/chain-interfaces/IExecutor.sol";

import {L2AssetTrackerData} from "./L2AssetTrackerData.sol";

abstract contract L2AssetTrackerTest is Test, SharedL2ContractDeployer {
    using stdStorage for StdStorage;

    function test_processLogsAndMessages() public {
        finalizeDepositWithChainId(271);
        finalizeDepositWithChainId(260);

        vm.chainId(GATEWAY_CHAIN_ID);

        bytes[] memory input2 = L2AssetTrackerData.getData2();
        for (uint256 i = 0; i < input2.length; i++) {
            this.printProcess(abi.decode(input2[i], (ProcessLogsInput)));
            return;
        }

        ProcessLogsInput[] memory testData = L2AssetTrackerData.getData();

        // TestData[] memory testData = new TestData[](3);
        // testData[0] = TestData({chainId: 260, l1BatchNumber: 3, l1TxHashes: new bytes32[](0), data: hex""});
        // testData[1] = TestData({chainId: 260, l1BatchNumber: 70, l1TxHashes: new bytes32[](0), data: hex""});

        // testData[2] = TestData({chainId: 260, l1BatchNumber: 71, l1TxHashes: l1TxHashes, data: hex""});
        //  testData[1] = TestData({chainId: 260, l1BatchNumber: 70, data: hex"});"

        /// Put data that needs to be printed here
        // this.printProcess( abi.decode(testData[2].data, (ProcessLogsInput)));
        // uint256 i = 2;

        //  testData[1 + i++] = TestData({chainId: 260, l1BatchNumber: 70, data: hex"000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000104000000000000000000000000000000000000000000000000000000000000009c64b3c3ac83a8873a5ea5f9a6df03ed1f8ebeed869ea212f5b956205476f3f395f05ddc0f6d5390e25a3e665922ad4f011f46381d7fcbab15067249470b6cbc240000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800800000000000000000000000000000000000000000000000000000000000100032175abd3980705a8324c3ca040907627173a507e447c682b34e5ac6d99a9e1e90000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000002e49c884fd10000000000000000000000000000000000000000000000000000000000000104b1f317b7effffcd4e3cf53784ae442ecc4e835c532aaf0e60a046fa8efb96e85000000000000000000000000d7458ac446323c9b84a3468ebdbc7568e0f25d20000000000000000000000000d7458ac446323c9b84a3468ebdbc7568e0f25d200000000000000000000000008eed0c30ec2dfa992ad6790bdf2461fd72c9fe4f000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001c101000000000000000000000000000000000000000000000000000000000000000900000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000457425443000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000045742544300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
        //"});  testData[1 + i++] = TestData({chainId: 260, l1BatchNumber: 70, data: hex"000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000001040000000000000000000000000000000000000000000000000000000000000048614ea6c09e2ee2eece56c3df38b4659ed1e1fe7c81115963acf675b8c4d51965f05ddc0f6d5390e25a3e665922ad4f011f46381d7fcbab15067249470b6cbc2400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008008000000000000000000000000000000000000000000000000000000000001000c023874fa7bd15545b4113c0651cfe6b75e1dbbd8bef3a542d506c3ccb5e3effe0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000006e101000000000000000000000000000000000000000000000000000000000000002001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000104000000000000000000000000000000000000000000000000000000000000010f3706534165ad652bef5f78b919f402eb8b676ce0e8780794c1283fd87b3104c200000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000006200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000004600100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100030000000000000000000000000000000000000000000000000000000000010003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000003249c884fd10000000000000000000000000000000000000000000000000000000000000104444c07697a6b15219c574dcc0ee09b479f6171009a6afd65b93e6f028cfa031b000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000024537c0f4cc8c67cbd2d516e96bba8365772c6e9000000000000000000000000053711f15b669ca7c49f904a9a258e061a956dfe0000000000000000000000002d6ec475d956190864257abde5f989e59695cf8a000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001c1010000000000000000000000000000000000000000000000000000000000000104000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000180000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000007546f6b656e204100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002414100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a4de2b6ef2483889458ee95fbf50571ed4e1085f00000000000000000000000024537c0f4cc8c67cbd2d516e96bba8365772c6e9000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001c000100000201041424537c0f4cc8c67cbd2d516e96bba8365772c6e90000000000000000000000000000000000000000000000000000000000000000000000

        // ProcessLogsInput memory input = abi.decode(data,(ProcessLogsInput));
        // Note: get this from real local txs

        // Initialize v30UpgradeChainBatchNumber for chain 271 with the correct placeholder value
        uint256 placeholderValue = uint256(
            keccak256(abi.encodePacked("V30_UPGRADE_CHAIN_BATCH_NUMBER_PLACEHOLDER_VALUE_FOR_GATEWAY"))
        );
        stdstore
            .target(address(L2_MESSAGE_ROOT_ADDR))
            .sig("v30UpgradeChainBatchNumber(uint256)")
            .with_key(271)
            .checked_write(placeholderValue);

        // Add the required previous batch roots for batches 1-4
        // The test is trying to add batch 5, so we need batches 1-4 to exist first
        bytes32 dummyBatchRoot = keccak256("dummy_batch_root");
        for (uint256 i = 1; i <= 4; i++) {
            stdstore
                .target(address(L2_MESSAGE_ROOT_ADDR))
                .sig("chainBatchRoots(uint256,uint256)")
                .with_key(271)
                .with_key(i)
                .checked_write(bytes32(uint256(dummyBatchRoot) + i));
        }

        for (uint256 i = 0; i < testData.length; i++) {
            // Set the current batch number to 4 so that batch 5 can be added next
            if (testData[i].batchNumber > 0) {
                stdstore
                    .target(address(L2_MESSAGE_ROOT_ADDR))
                    .sig("currentChainBatchNumber(uint256)")
                    .with_key(testData[i].chainId)
                    .checked_write(testData[i].batchNumber - 1);
            }

            storeChainBalance(
                testData[i].chainId,
                0x444c07697a6b15219c574dcc0ee09b479f6171009a6afd65b93e6f028cfa031b,
                100
            );
            storeChainBalance(
                testData[i].chainId,
                0xa6203e30497f83b9f5f056745b6ff94f7e22d88bacea03d4dd4393d66217a86f,
                100
            );
            storeChainBalance(
                testData[i].chainId,
                0x8592bf3100a24d737aba8ba9895f6801b9ec30200dc016dd8369f3171cbd1921,
                100
            );
            storeChainBalance(
                testData[i].chainId,
                0xb615cd4917043452e354e4797dc23e4d6106663f7a37249d54f5996dd2347710,
                100
            );
            storeChainBalance(
                testData[i].chainId,
                0xb1f317b7effffcd4e3cf53784ae442ecc4e835c532aaf0e60a046fa8efb96e85,
                100
            );
            storeChainBalance(
                testData[i].chainId,
                0xb5eab7cc8c9114c3115a034b49b3d87b0b352aa88c2a9d5ff7339cde105aa44c,
                100
            );

            stdstore
                .target(address(L2_CHAIN_ASSET_HANDLER))
                .sig("migrationNumber(uint256)")
                .with_key(271)
                .checked_write(1);

            bytes32[] memory txHashes = getTxHashes(testData[i]);

            // Loop over l1TxHashes in testData[i] and for each mark balanceChange version number as 1
            // Note: balanceChange is internal, so we calculate storage slot manually
            // balanceChange is at slot 155 in GWAssetTracker
            for (uint256 j = 0; j < txHashes.length; j++) {
                // Calculate storage slot: keccak256(txHash, keccak256(chainId, 155))
                bytes32 innerSlot = keccak256(abi.encode(testData[i].chainId, uint256(155)));
                bytes32 structSlot = keccak256(abi.encode(txHashes[j], innerSlot));
                // Write 1 to the version field (first byte of the struct)
                vm.store(address(GW_ASSET_TRACKER), structSlot, bytes32(uint256(1)));
            }

            vm.prank(L2_BRIDGEHUB.getZKChain(testData[i].chainId));

            (bool success, ) = GW_ASSET_TRACKER_ADDR.call(
                abi.encodeCall(GW_ASSET_TRACKER.processLogsAndMessages, testData[i])
            );

            require(success, string.concat("Failed to call GWAssetTracker ", vm.toString(i)));
            console.log("success", i);
        }
    }

    function getTxHashes(ProcessLogsInput memory input) public returns (bytes32[] memory) {
        bytes32[] memory txHashes = new bytes32[](input.logs.length);
        uint256 length = 0;
        for (uint256 i = 0; i < input.logs.length; i++) {
            if (input.logs[i].sender == L2_BOOTLOADER_ADDRESS) {
                length++;
            }
        }
        uint256 j;
        for (uint256 i = 0; i < input.logs.length; i++) {
            if (input.logs[i].sender == L2_BOOTLOADER_ADDRESS) {
                txHashes[j++] = input.logs[i].key;
            }
        }
        return txHashes;
    }

    function storeChainBalance(uint256 chainId, bytes32 assetId, uint256 balance) public {
        stdstore
            .target(address(GW_ASSET_TRACKER))
            .sig("chainBalance(uint256,bytes32)")
            .with_key(chainId)
            .with_key(assetId)
            .checked_write(balance);
    }

    function printProcess(ProcessLogsInput memory) public {
        /// its just here so that the ProcessLogsInput is printed in console
    }
}
